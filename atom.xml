<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>Zhen Lu&#39;s blog</title>
<link>https://leslie-lu.github.io/atom.html</link>
<atom:link href="https://leslie-lu.github.io/atom.xml" rel="self" type="application/rss+xml"/>
<description>Zhen Lu&#39;s blog</description>
<language>en</language>
<generator>quarto-1.3.450</generator>
<lastBuildDate>Fri, 30 Aug 2024 00:00:00 GMT</lastBuildDate>
<item>
  <title>星球JC | 胃癌早期筛查工具</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/08/30/docker/index.html</link>
  <description><![CDATA[ 




<blockquote class="blockquote">
<p>大家好，这一期预测模型星球Journal Club的分享来自中国医科大学的徐林玉同学，分享的是2019年发表在中科院医学1区的顶级期刊Gut上，题为“Development and validation of a prediction rule for estimating gastric cancer risk in the Chinese high-risk population: a nationwide multicentre study”的研究论文。</p>
</blockquote>
<section id="研究背景" class="level3">
<h3 class="anchored" data-anchor-id="研究背景">研究背景</h3>
<p>胃癌是中国第二常见的癌症，早期检测和治疗可以显著降低其死亡率。然而，由于高风险人群庞大，全面的胃镜筛查在经济和操作上都不切实际。当前，中国的国家筛查指南建议对高风险人群从40岁开始进行筛查，但由于高风险人群估计超过3亿人，全面的胃镜筛查并不可行。因此，迫切需要一种风险分层工具，作为胃镜检查前的初步筛查工具，以进一步识别真正的高风险个体；且当前中国国内尚无类似的工具。</p>
<p>现有的筛查工具主要基于已知的胃癌风险因素，如萎缩性胃炎和幽门螺杆菌感染。虽然有一些方法如ABC方法在日本被开发用于预测未来胃癌的发生，但其在中国高风险人群中的适用性仍存在疑问。此外，现有的生物标志物组合方法虽然在某些研究中表现良好，但其结果可能不适用于中国的高风险人群。因此，这项全国多中心横断面研究的目标是开发一种新的预测规则，用于二级预防（早发现、早诊断、早治疗），作为初步筛查工具，用于在中国无症状人群中识别高风险个体，以便进一步进行诊断性胃镜检查。</p>
</section>
<section id="研究方法" class="level3">
<h3 class="anchored" data-anchor-id="研究方法">研究方法</h3>
<section id="研究类型" class="level4">
<h4 class="anchored" data-anchor-id="研究类型">研究类型</h4>
<p>全国、多中心、横断面研究。</p>
</section>
<section id="研究人群" class="level4">
<h4 class="anchored" data-anchor-id="研究人群">研究人群</h4>
<p>年龄在40至80岁之间、无胃肠道症状的个体，符合中国胃癌高风险标准，并前往医院进行胃镜筛查。</p>
</section>
<section id="数据收集" class="level4">
<h4 class="anchored" data-anchor-id="数据收集">数据收集</h4>
<p>通过问卷调查、血清学检测（PG I、PG II、G-17、抗幽门螺杆菌IgG抗体）、胃镜检查和组织学检查收集数据。</p>
</section>
<section id="统计分析" class="level4">
<h4 class="anchored" data-anchor-id="统计分析">统计分析</h4>
<p>文章对数据的管理采取了中心化的管理，尽可能确保数据质量。参与者按2:1比例被随机分为开发队列和验证队列。开发队列用于模型开发，验证队列用于外部验证。文章利用Logistic回归模型开发预测规则。在开发队列中，通过univariate and multivariate analyses评估危险因素与胃癌的关联，其中，univariate analyses阈值设为p&lt;0.25，且multivariate analyses采用backward stepwise进行进一步的变量筛选。文章预测规则的设定基于regression coefficient-based scoring method（Points were assigned by dividing the regression coefficients by the absolute value of the smallest coefficient in the model and rounding up to the nearest integer）。模型整体性能通过R²和Brier评分进行衡量，区分能力通过AUC和discrimination slope评估，校准能力通过Hosmer-Lemeshow χ2统计量和calibration in the large进行评估。同时，评估模型预测的敏感度、特异度、准确率、阳性预测值（positive predictive value）、阴性预测值（negative predictive value）、阳性似然比（positive likelihood ratio）、阴性似然比（negative likelihood rario）和number needed to screen（defined as the number of participants who would need to undergo gastroscopy for one patient with GC to be identified）。文章对开发队列进行bootstrap抽样1000次作为内部验证，验证队列上进行外部验证。同时，基于u test比较模型在开发队列、验证队列上的AUC表现。此外，文章额外做了一部分工作，即将自身模型与当前现有文献中的预测模型进行效果的对比。数据分析使用IBM SPSS和R软件进行。</p>
</section>
</section>
<section id="研究结果" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="研究结果">研究结果</h3>
<p>此研究收集了2015年6月至2017年3月期间来自中国115家医院的数据，最终纳入14,929名合格参与者。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2024/08/30/docker/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408302129019.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">图1 研究对象纳入及定义</figcaption>
</figure>
</div>
<section id="预测规则的开发" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="预测规则的开发">预测规则的开发</h4>
<p>基于分数的预测规则的开发：采用单因素和多因素分析，确定了包括年龄、性别、PG I/II比率、G-17水平、幽门螺杆菌感染和饮食习惯（腌制和油炸食品消费）在内的7个预测因素。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2024/08/30/docker/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408302131409.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">Table 1</figcaption>
</figure>
</div>
<p>按照0–25分评分范围进行风险分层，将个体分为低风险（≤11）、中风险（12–16）和高风险（17–25）组。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2024/08/30/docker/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408302132079.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">图2 logistic回归模型中胃癌的预测因素及相关预测规则</figcaption>
</figure>
</div>
<p>其中，中高风险组的胃镜检查检测到70.8%的胃癌病例和70.3%的早期胃癌病例。低风险组的胃镜检查需求减少了66.7%。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2024/08/30/docker/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408302133117.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">Table 4</figcaption>
</figure>
</div>
<p>预测性能：开发的预测规则具有良好的性能表现。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2024/08/30/docker/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408302133591.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">图3 预测模型的性能指标</figcaption>
</figure>
</div>
</section>
<section id="与其他预测模型的性能比较" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="与其他预测模型的性能比较">与其他预测模型的性能比较</h4>
<p>该预测规则表现良好，并显示出显著优于其他三种替代预测方法（即Miki等人的ABC方法、中国的基于ELISA的ABC方法以及Tu等人的五种生物标志物方法）在识别胃癌患者方面的区分能力。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2024/08/30/docker/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408302134991.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">图4 验证队列中预测模型和替代预测模型的比较</figcaption>
</figure>
</div>
</section>
</section>
<section id="take-home-message" class="level3">
<h3 class="anchored" data-anchor-id="take-home-message">Take home message</h3>
<ol type="1">
<li><p>该预测规则在识别中国人群中胃镜检查前的高风险个体方面表现良好。可以作为一种准确且具有成本效益的大规模初步筛查工具，以提高胃癌（包括早期胃癌）的检测率，从而改善胃癌的二级预防。</p></li>
<li><p>文章不仅比较了自身模型在多中心外部验证中的效果，更是对比了现有模型，且表现均优于现有模型。</p></li>
<li><p>采用回归赋分的方式，对于人工智能算法解释性较好，能较好地在医院中进行推广应用；此外，采用赋分划分亚组的方式，关注到了模型实际可能带来的收益。</p></li>
</ol>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>
</section>

 ]]></description>
  <category>journal club</category>
  <guid>https://leslie-lu.github.io/blog/2024/08/30/docker/index.html</guid>
  <pubDate>Fri, 30 Aug 2024 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408302124427.png" medium="image" type="image/png"/>
</item>
<item>
  <title>github actions使用docker渲染quarto文档</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/08/29/docker/index.html</link>
  <description><![CDATA[ 




<p>在用github pages更新静态网站内容时，发现github actions突然报之前并未出现过的错误：</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2024/08/29/docker/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408292356507.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">error</figcaption>
</figure>
</div>
<p>错误表明系统在尝试调用UPower、Vulkan服务时遇到了问题，但是我也没找到到底是在哪里调用。而且UPower是一个用于管理电池电量和电源管理的服务，通常在桌面环境中使用。我尝试更新unbuntu上upower这些包的时候，发现github pages这种方式并没有给使用这类包的权限，看google上似乎也没有针对这个错误的比较好的解决方式。</p>
<p>没办法，只能选择换一种方法来render网站的内容，我又不想在本地利用quarto每次手动来render网页，最后只能尝试选择利用docker中配置的ubuntu环境来render github repository中更新的内容，然后再像以前一样，把render出来的html，重新利用actions publish到新的repository中，这样来更新网页内容，避开直接使用actions出现的这个错误。</p>
<p>我给docker的配置Dockfiles如下，给有可能遇见同样错误的同学参考：</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode dockerfile code-with-copy"><code class="sourceCode dockerfile"><span id="cb1-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># install R and dependencies</span></span>
<span id="cb1-2"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">ENV</span> DEBIAN_FRONTEND=noninteractive</span>
<span id="cb1-3"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Update package indices</span></span>
<span id="cb1-4"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">RUN</span> <span class="ex" style="color: null;
background-color: null;
font-style: inherit;">apt-get</span> update <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-qq</span></span>
<span id="cb1-5"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Install helper packages</span></span>
<span id="cb1-6"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">RUN</span> <span class="ex" style="color: null;
background-color: null;
font-style: inherit;">apt-get</span> install <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">--no-install-recommends</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-y</span> software-properties-common dirmngr</span>
<span id="cb1-7"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Add the signing key for the R repository</span></span>
<span id="cb1-8"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">RUN</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">wget</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-qO-</span> https://cloud.r-project.org/bin/linux/ubuntu/marutter_pubkey.asc <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">|</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">tee</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-a</span> /etc/apt/trusted.gpg.d/cran_ubuntu_key.asc</span>
<span id="cb1-9"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Add the R 4.0 repository from CRAN</span></span>
<span id="cb1-10"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">RUN</span> <span class="ex" style="color: null;
background-color: null;
font-style: inherit;">add-apt-repository</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"deb https://cloud.r-project.org/bin/linux/ubuntu </span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">$(</span><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">lsb_release</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-cs</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">)</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">-cran40/"</span></span>
<span id="cb1-11"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">RUN</span> <span class="ex" style="color: null;
background-color: null;
font-style: inherit;">apt-get</span> install <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">--no-install-recommends</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-y</span> r-base </span>
<span id="cb1-12"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">RUN</span> <span class="ex" style="color: null;
background-color: null;
font-style: inherit;">R</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-e</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"if (!requireNamespace('renv', quietly=TRUE)) install.packages('renv', repos = c(CRAN = 'https://cloud.r-project.org'))"</span></span>
<span id="cb1-13"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">WORKDIR</span> /project</span>
<span id="cb1-14"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">COPY</span> renv.lock .</span>
<span id="cb1-15"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">ENV</span> RENV_PATHS_LIBRARY /renv</span>
<span id="cb1-16"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">RUN</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">mkdir</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-p</span> renv</span>
<span id="cb1-17"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">COPY</span> .Rprofile .Rprofile</span>
<span id="cb1-18"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">COPY</span> renv/activate.R renv/activate.R</span>
<span id="cb1-19"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">COPY</span> renv/settings.json renv/settings.json</span>
<span id="cb1-20"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">RUN</span> <span class="ex" style="color: null;
background-color: null;
font-style: inherit;">R</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-e</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"renv::activate(); renv::restore(repos = 'https://cloud.r-project.org')"</span></span>
<span id="cb1-21"></span>
<span id="cb1-22"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># install python and dependencies</span></span>
<span id="cb1-23"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">RUN</span> <span class="ex" style="color: null;
background-color: null;
font-style: inherit;">apt-get</span> update <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">&amp;&amp;</span> <span class="ex" style="color: null;
background-color: null;
font-style: inherit;">apt-get</span> install <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-y</span> python3.10 python3-pip <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\</span></span>
<span id="cb1-24">    <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">&amp;&amp;</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rm</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-rf</span> /var/lib/apt/lists/<span class="pp" style="color: #AD0000;
background-color: null;
font-style: inherit;">*</span></span>
<span id="cb1-25"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">COPY</span> requirements.txt .</span>
<span id="cb1-26"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">RUN</span> <span class="ex" style="color: null;
background-color: null;
font-style: inherit;">pip3</span> install <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">--no-cache-dir</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">--break-system-packages</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-r</span> requirements.txt</span></code></pre></div>
<p>这样使用docker的方式就不会报错了：</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2024/08/29/docker/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408292348890.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">success</figcaption>
</figure>
</div>
<p>完整代码已经放在了<a href="https://mp.weixin.qq.com/s/4IR-KMAZ-q2VbI0Fz4fYRg">星球</a>里，感兴趣的同学可以自行查看。</p>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>

 ]]></description>
  <category>github</category>
  <category>quarto</category>
  <category>docker</category>
  <guid>https://leslie-lu.github.io/blog/2024/08/29/docker/index.html</guid>
  <pubDate>Thu, 29 Aug 2024 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408292348890.png" medium="image" type="image/png"/>
</item>
<item>
  <title>大图嵌小图</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/08/20/nested_layout/index.html</link>
  <description><![CDATA[ 




<section id="由来" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="由来">由来</h3>
<p>星球里不断有同学问到如何在一个大图中嵌入小图，这里简单介绍一下。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2024/08/20/nested_layout/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408200018820.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">Q1</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2024/08/20/nested_layout/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408200019279.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">Q2</figcaption>
</figure>
</div>
<p>我们使用生存曲线及risk table作为例子，其中生存曲线是大图，risk table是小图。常见的图形为：</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2024/08/20/nested_layout/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408200042969.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">survival curve</figcaption>
</figure>
</div>
<p>想要把risk table嵌入到生存曲线中。</p>
</section>
<section id="方法一" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="方法一">方法一</h3>
<p>使用grid包，借助于grid包中的viewport函数。viewport用于定义一个绘图区域，可以在一个图形设备中创建多个独立的绘图区域，每个区域都有自己的坐标系和尺寸。</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-1_6b9faa99cd1b0e0846b7c25e1284f7fe">
<div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># not run</span></span>
<span id="cb1-2">subvp <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">viewport</span>(<span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">width =</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.35</span>, <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">height =</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.35</span>, <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">x =</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.75</span>, <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">y =</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.75</span>)</span>
<span id="cb1-3">ggsurv<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">$</span>plot</span>
<span id="cb1-4"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">print</span>(ggsurv<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">$</span>table, <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">vp =</span> subvp)</span></code></pre></div>
</div>
<p>viewport创建了一个子视口，它定义了一个相对主视口的区域。效果如下：</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2024/08/20/nested_layout/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408200034399.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">option 1</figcaption>
</figure>
</div>
</section>
<section id="方法二" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="方法二">方法二</h3>
<p>使用annotation_custom函数，它可以在图形中添加自定义的图形元素。</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-2_ca1fffe6d3dc9025eb45468c335cc631">
<div class="sourceCode cell-code" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># not run</span></span>
<span id="cb2-2">ggsurv<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">$</span>plot <span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">annotation_custom</span>(<span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">ggplotGrob</span>(ggsurv<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">$</span>table), <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">xmin=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1900</span>, <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">xmax=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3000</span>, <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">ymin=</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.6</span>, <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">ymax=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>)</span></code></pre></div>
</div>
<p>ggplotGrob将ggsurv$table转换为grob对象，以便在图形中使用。效果如下：</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2024/08/20/nested_layout/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408200037108.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">option 2</figcaption>
</figure>
</div>
</section>
<section id="方法三" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="方法三">方法三</h3>
<p>使用ggpp包。</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-3_7a8899ed28d6bf91362d1e79c6f457c5">
<div class="sourceCode cell-code" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># not run</span></span>
<span id="cb3-2">sub_plot<span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">=</span> tibble<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">::</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">tibble</span>(</span>
<span id="cb3-3">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">x=</span> .<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">98</span>, <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">y=</span> .<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">98</span>, <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">plot=</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">list</span>(ggsurv<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">$</span>table)</span>
<span id="cb3-4">)</span>
<span id="cb3-5">ggsurv<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">$</span>plot <span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> </span>
<span id="cb3-6">    <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">geom_plot_npc</span>(<span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">data =</span> sub_plot, <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">aes</span>(<span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">npcx =</span> x, <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">npcy =</span> y, <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">label =</span> plot))</span></code></pre></div>
</div>
<p>使用geom_plot_npc函数将子图添加到主图中，label表示要添加的子图。效果如下：</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2024/08/20/nested_layout/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408200040329.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">option 3</figcaption>
</figure>
</div>
<p>完整代码已经放在了<a href="https://mp.weixin.qq.com/s/4IR-KMAZ-q2VbI0Fz4fYRg">星球</a>里，感兴趣的同学可以自行查看。</p>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>
</section>

 ]]></description>
  <category>r</category>
  <category>ggplot2</category>
  <guid>https://leslie-lu.github.io/blog/2024/08/20/nested_layout/index.html</guid>
  <pubDate>Tue, 20 Aug 2024 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408200034399.png" medium="image" type="image/png"/>
</item>
<item>
  <title>欢迎加入预测模型星球</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/08/14/clinical_prediction_model/index.html</link>
  <description><![CDATA[ 




<section id="由来" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="由来">由来</h3>
<p>前面我们给大家推荐了这本几位非常厉害的教授老师主编的<a href="https://mp.weixin.qq.com/s/QQDM3aqyjaOSXXlZznJRDg">《临床预测模型方法与应用》</a>，陆陆续续地，在各个平台上，大家都反馈已经收到了这本书，并且这本书还很大很厚，涵盖了方法学、操作、专题以及案例。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2024/08/14/clinical_prediction_model/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408141829108.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">feedback</figcaption>
</figure>
</div>
<p>那这时候，就有同学和我说，按照以往看书的习惯，收到书的前一俩周，还是可以翻翻，但是后面就会慢慢地放在那里，然后就不了了之了。</p>
<p>所以，我们就想，能不能有一个平台，让大家一起学习这本书，一起讨论、交流，一起进步呢？</p>
</section>
<section id="预测模型星球" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="预测模型星球">预测模型星球</h3>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2024/08/14/clinical_prediction_model/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408141822826.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">知识星球</figcaption>
</figure>
</div>
<p>向大家完整介绍下这个星球，也鼓励更多想要讨论交流的小伙伴进入到我的星球里面，大家一起愉快地学习。</p>
<ol type="1">
<li>首先，你要有实体书，不然我们每周讨论学习某一个章节的时候，你可能会有点懵。</li>
</ol>
<p>购买的二维码链接在<a href="https://mp.weixin.qq.com/s/QQDM3aqyjaOSXXlZznJRDg">这里</a>。</p>
<ol start="2" type="1">
<li>知识星球的目的是和大家一起营造一个国内高质量的预测模型类研究的知识圈，让星球里的人能够受益。</li>
</ol>
<p>来到这里你会遇到一群志同道合的人，一起学习、相互交流、共同促进。这个交流圈高度专注于预测类研究领域。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2024/08/14/clinical_prediction_model/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408141840460.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">content</figcaption>
</figure>
</div>
<ol start="3" type="1">
<li><p>我们会每周一起学习讨论这本书的一个章节，每周一次，每次一个小时或一个章节，讨论的内容会包括这一章的重点内容、难点、案例分析等。</p></li>
<li><p>除了这本书，如果未来人数足够，我们还会不定期地邀请一些同样从事预测类研究的博士生、学者，来和大家分享他们的研究成果、经验、心得等。</p></li>
</ol>
<p>后续我们会根据星球中同学们的需求，不定时地开展更多主题的workshop，具体时间请关注我们的公众号和<a href="https://t.zsxq.com/5ecjA">星球</a>，我们会在这两个平台上发布最新的信息。</p>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>
</section>

 ]]></description>
  <category>workshop</category>
  <category>prediction model</category>
  <guid>https://leslie-lu.github.io/blog/2024/08/14/clinical_prediction_model/index.html</guid>
  <pubDate>Wed, 14 Aug 2024 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408141822826.jpg" medium="image" type="image/jpeg"/>
</item>
<item>
  <title>星球第二期workshop上线</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/08/11/workshop_002/index.html</link>
  <description><![CDATA[ 




<p>我们<a href="https://mp.weixin.qq.com/s/4IR-KMAZ-q2VbI0Fz4fYRg">星球</a>正式上线第二期workshop啦！</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2024/08/11/workshop_002/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408111605260.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">workshop</figcaption>
</figure>
</div>
<p>本期workshop主题是“Sample Size Calculations in Clinical Research”。本期workshop将从临床研究中不同试验设计的角度出发，介绍如何基于不同设计类型（平行设计、交叉设计、析因设计、成组序贯设计等）、比较类型（非劣效、等效、优效试验）、主要终点指标等因素进行样本量计算。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2024/08/11/workshop_002/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408111619582.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">screenshot</figcaption>
</figure>
</div>
<p>目前暂定的安排是每周一节一小时，直到本期workshop的全部内容结束。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2024/08/11/workshop_002/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408111620421.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">used files</figcaption>
</figure>
</div>
<p>后续我们会根据星球中同学们的需求，不定时地开展更多主题的workshop，具体时间请关注我们的公众号和<a href="https://mp.weixin.qq.com/s/4IR-KMAZ-q2VbI0Fz4fYRg">星球</a>，我们会在这两个平台上发布最新的信息。</p>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>

 ]]></description>
  <category>workshop</category>
  <category>sample size</category>
  <category>clinical research</category>
  <guid>https://leslie-lu.github.io/blog/2024/08/11/workshop_002/index.html</guid>
  <pubDate>Sun, 11 Aug 2024 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408111605260.jpg" medium="image" type="image/jpeg"/>
</item>
<item>
  <title>星球第一期workshop上线</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/08/04/workshop_001/index.html</link>
  <description><![CDATA[ 




<p>我们<a href="https://mp.weixin.qq.com/s/4IR-KMAZ-q2VbI0Fz4fYRg">星球</a>正式上线第一期workshop啦！</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2024/08/04/workshop_001/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408041637573.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">workshop</figcaption>
</figure>
</div>
<p>本期workshop主题是“Statistical Methods for Analysis with Missing Data”。本期workshop将从缺失数据的概念、缺失数据的类型、缺失数据的机制、缺失数据的影响、缺失数据的处理方法等方面展开讲解，帮助大家更好地理解缺失数据的问题，掌握缺失数据的处理方法。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2024/08/04/workshop_001/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408041641868.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">screenshot</figcaption>
</figure>
</div>
<p>目前暂定的安排是每周一节一小时，直到本期workshop的全部内容结束。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2024/08/04/workshop_001/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408041644463.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">used files</figcaption>
</figure>
</div>
<p>后续我们会根据星球中同学们的需求，不定时地开展更多主题的workshop，具体时间请关注我们的公众号和<a href="https://mp.weixin.qq.com/s/4IR-KMAZ-q2VbI0Fz4fYRg">星球</a>，我们会在这两个平台上发布最新的信息。</p>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>

 ]]></description>
  <category>workshop</category>
  <category>missing data</category>
  <category>statistical methods</category>
  <guid>https://leslie-lu.github.io/blog/2024/08/04/workshop_001/index.html</guid>
  <pubDate>Sun, 04 Aug 2024 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408041637573.jpg" medium="image" type="image/jpeg"/>
</item>
<item>
  <title>倾向性评分加权</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/08/03/propensity_score_weighting/index.html</link>
  <description><![CDATA[ 




<section id="背景介绍" class="level3">
<h3 class="anchored" data-anchor-id="背景介绍">背景介绍</h3>
<p>对于非RCT类的观察性研究，由于分组的非随机性，导致了研究偏倚的存在，致使观察到的效应很多时候往往并不可用。为了解决这个问题，研究者们提出了倾向性评分的方法，通过倾向性评分的计算，可以使得试验组和对照组之间的分布更加接近，从而减少了研究偏倚的影响。</p>
<p>我们公众号以往有过五篇类似的介绍内容，分别是：</p>
<ol type="1">
<li><a href="https://mp.weixin.qq.com/s/S5nd__7fflKBekeOKCJQEQ">倾向性评分分析</a></li>
<li><a href="https://mp.weixin.qq.com/s/HuyE_79VJMY1e0VoRgcLbA">倾向性评分分析的统计学考虑</a></li>
<li><a href="https://mp.weixin.qq.com/s/j8olCbIDN06UCHgWirzq3g">倾向性评分匹配的生存分析怎么做</a></li>
<li><a href="https://mp.weixin.qq.com/s/hMXiND44bFGD57c7t7wGaw">倾向性评分overlapping weighting的SAS实现（一）</a></li>
<li><a href="https://mp.weixin.qq.com/s/fxqrH0Im2y_oqfg3K63Epw">生存资料倾向性评分OW的SAS实现（二）</a></li>
</ol>
<p>其中，后面两篇文章提到了倾向性评分加权中的overlapping weighting方法，这篇文章将对倾向性评分加权的方法进行详细介绍。</p>
</section>
<section id="因果效应" class="level3">
<h3 class="anchored" data-anchor-id="因果效应">因果效应</h3>
<p>首先，我们来看下几种因果效应。</p>
<p>ATE即平均处理效应（average treatment effect），是指在试验组和对照组之间的处理效应的差异。理想情况下，随机对照试验估计出来的效应即ATE，但是在实际研究中，由于种种原因，我们往往无法进行随机对照试验。由于ATE的估计人群是试验组和对照组的总体，ATE假设两组受试者是有相同的概率/机会接受某一种处理的，然而，实际研究中，研究者往往更加关注的是ATE的局部估计，即在某一特定的人群中（一般是接受治疗的试验组），处理的效应是多少，而这个效应即为ATT（average treatment effect on the treated）。由于ATT只需要对处理组人群估计因果处理效应，对于RCT而言，潜在的治疗效果和治疗组分配是相互独立的，因此，ATT即为ATE；然而，对于非RCT类研究而言，二者是不同的。</p>
<p>我们还可以计算ATC（average treatment effect on the control），即对于未接受治疗的人群，如果接受治疗，其效应是多少。此外，还有ATM（average treatment effect among the evenly matchable），即在对照组中，找到与试验组相匹配的人群，计算在这个匹配的总体人群中的治疗效应；ATO（average treatment effect among the overlap population），即在试验组和对照组的重叠人群中，计算治疗效应。相比于ATM，ATO有着更好的方差属性，由于其不像ATM那样匹配要求，转而是选择两组重叠的中间人群，因此，ATO的估计更加稳健。</p>
</section>
<section id="倾向性评分加权" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="倾向性评分加权">倾向性评分加权</h3>
<p>针对以上五种因果效应，我们可以通过倾向性评分加权的方法来进行相应的估计。这里直接给出五种权重的计算公式：</p>
<ol type="1">
<li>ATE：<img src="https://latex.codecogs.com/png.latex?w_%7BATE%7D%20=%20%5Cfrac%7BZ_i%7D%7Be_i%7D%20+%20%5Cfrac%7B1%20-%20Z_i%7D%7B1%20-%20e_i%7D"></li>
<li>ATT：<img src="https://latex.codecogs.com/png.latex?w_%7BATT%7D%20=%20%5Cfrac%7Be_iZ_i%7D%7Be_i%7D%20+%20%5Cfrac%7Be_i(1-Z_i)%7D%7B1-e_i%7D"></li>
<li>ATC：<img src="https://latex.codecogs.com/png.latex?w_%7BATC%7D%20=%20%5Cfrac%7B(1-e_i)Z_i%7D%7Be_i%7D%20+%20%5Cfrac%7B(1-e_i)%20(1-Z_i)%7D%7B1%20-%20e_i%7D"></li>
<li>ATM：<img src="https://latex.codecogs.com/png.latex?w_%7BATC%7D%20=%20%5Cfrac%7B(1-e_i)Z_i%7D%7Be_i%7D%20+%20%5Cfrac%7B(1-e_i)%20(1-Z_i)%7D%7B1%20-%20e_i%7D"></li>
<li>ATO：<img src="https://latex.codecogs.com/png.latex?w_%7BAT0%7D%20=%20(1-e_i)Z_i%20+%20e_i(1-Z_i)"></li>
</ol>
<p>以上五种加权的示例以及具体实现的全部代码，我们已经放在了<a href="https://mp.weixin.qq.com/s/4IR-KMAZ-q2VbI0Fz4fYRg">星球</a>里，感兴趣的同学可以自行查看。</p>
<p>这里我们展示下加权后人群的分布情况。</p>
<section id="原始人群的ps分布" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="原始人群的ps分布">原始人群的ps分布</h4>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2024/08/03/propensity_score_weighting/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408031942417.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">ps of original population</figcaption>
</figure>
</div>
</section>
<section id="ate" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="ate">ATE</h4>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2024/08/03/propensity_score_weighting/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408031944764.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">ATE</figcaption>
</figure>
</div>
</section>
<section id="att" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="att">ATT</h4>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2024/08/03/propensity_score_weighting/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408031945648.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">ATT</figcaption>
</figure>
</div>
</section>
<section id="atc" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="atc">ATC</h4>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2024/08/03/propensity_score_weighting/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408031946706.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">ATC</figcaption>
</figure>
</div>
</section>
<section id="atm" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="atm">ATM</h4>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2024/08/03/propensity_score_weighting/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408031946718.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">ATM</figcaption>
</figure>
</div>
</section>
<section id="ato" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="ato">ATO</h4>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2024/08/03/propensity_score_weighting/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408031947889.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">ATO</figcaption>
</figure>
</div>
</section>
</section>
<section id="总结" class="level3">
<h3 class="anchored" data-anchor-id="总结">总结</h3>
<p>相信通过以上可视化的展示，大家会更容易理解倾向性评分加权的方法对目标人群的选择以及治疗效应的解释。借助于合适的效应加权，我们可以估计出治疗效应并对于以上五种治疗效应的估计值。</p>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>
</section>

 ]]></description>
  <category>propensity score</category>
  <category>weighting</category>
  <guid>https://leslie-lu.github.io/blog/2024/08/03/propensity_score_weighting/index.html</guid>
  <pubDate>Sat, 03 Aug 2024 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408031947889.png" medium="image" type="image/png"/>
</item>
<item>
  <title>预测模型领域新书推荐</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/07/19/new_book/index.html</link>
  <description><![CDATA[ 




<blockquote class="blockquote">
<p>首先，今天这篇不是软文哦。</p>
</blockquote>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2024/07/19/new_book/https:/img01.yzcdn.cn/upload_files/2024/07/19/FlaDOPwuw67QXR1EG_dIwX858yNM.jpg!large.webp" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">临床预测模型方法与应用</figcaption>
</figure>
</div>
<p>非常高兴向大家推荐和我们课题组一直保持良好合作的荷兰 Utrecht University <a href="https://www.uu.nl/staff/JWang6">王俊峰教授</a>参与主编的新书《<a href="https://shop19174385.m.youzan.com/wscgoods/detail/3f2t7uivrox5lr1?scan=1&amp;activity=none&amp;from=kdt&amp;qr=directgoods_4268678081&amp;shopAutoEnter=1&amp;is_share=1&amp;from_uuid=4760198145&amp;goodsImg=https%3A%2F%2Fimg01.yzcdn.cn%2Fupload_files%2F2024%2F07%2F19%2FFlaDOPwuw67QXR1EG_dIwX858yNM.jpg&amp;sf=wx_sm&amp;share_cmpt=native_wechat">临床预测模型方法与应用</a>》。</p>
<p>王老师是临床预测模型领域内的专家，大家感兴趣的可以去看王老师的<a href="https://scholar.google.com/citations?hl=en&amp;user=00iVjcAAAAAJ">google scolar</a>。在和王老师合作做项目的过程中，我也是收获很多，扫除了一些知识上的盲点和疑区。因而，对于关注我的同学们而言，如果有对临床预测模型感兴趣的，我也是非常推荐这本书。</p>
<p>这本书由南京医科大学公共卫生学院的陈峰教授作序，主编人员都是在预测模型、生物统计领域内有着丰富经验和深刻见解的科研人员，王老师在我们合作的项目文章里也给与了我悉心的指导，北京天坛医院<a href="https://scholar.google.com/citations?user=lRMQ1TQAAAAJ&amp;hl=en">谷鸿秋教授</a>也是刚刚作为一作发表了<a href="https://www.nejm.org/doi/full/10.1056/NEJMoa2400314">NEJM</a>，这本书可以说是大咖云集了。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2024/07/19/new_book/https:/img01.yzcdn.cn/upload_files/2024/07/19/FhenV4zyYep1OLarEbPTNGwBTxQE.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">序言</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2024/07/19/new_book/https:/img01.yzcdn.cn/upload_files/2024/07/19/FgbP3FuafNrK00Art1Rl0ocpCIZ7.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">序言</figcaption>
</figure>
</div>
<p>相信很多做科研的同学，一直想找一本这个方向领域的权威且全面的中文书，这本书应该是一个不错的选择。如果是对预测模型感兴趣的小伙伴可以直接下单预定啦，也可以关注下8月份王老师在北大、复旦的讲座。这本书8月份会正式上市，目前可以扫码下图进行预定。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2024/07/19/new_book/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202407191947983.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">预定</figcaption>
</figure>
</div>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>

 ]]></description>
  <category>prediction model</category>
  <category>book</category>
  <guid>https://leslie-lu.github.io/blog/2024/07/19/new_book/index.html</guid>
  <pubDate>Fri, 19 Jul 2024 00:00:00 GMT</pubDate>
  <media:content url="https://img01.yzcdn.cn/upload_files/2024/07/19/FlaDOPwuw67QXR1EG_dIwX858yNM.jpg!large.webp" medium="image" type="image/webp"/>
</item>
<item>
  <title>2023年最新JCR影响因子发布</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/06/23/JCR_2023/index.html</link>
  <description><![CDATA[ 




<section id="年最新jcr影响因子" class="level3">
<h3 class="anchored" data-anchor-id="年最新jcr影响因子">2023年最新JCR影响因子</h3>
<p>最新的影响因子前几天已经发布了，和去年一样，大家在公众号后台回复”<strong>JCR2023</strong>”，即可拿到最全的总结excel表格，包括2023年的最新影响因子，以及各个学科的排名，希望对大家有所帮助。</p>
</section>
<section id="关注的一些期刊" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="关注的一些期刊">关注的一些期刊</h3>
<p>几乎全部的期刊影响因子都回落到了几年前的水平。</p>
<p>四大神刊中JAMA几近腰斩，柳叶刀系列的多个子刊也是如此。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2024/06/23/JCR_2023/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202406231742280.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">柳叶刀系列</figcaption>
</figure>
</div>
<p>医工交叉领域也是普遍下滑。medical informatics数字医疗部分，lancet digital health和npj Digital Medicine分别是23.8和12.4分。</p>
<p>以往动辄二三十分的盛况不再。</p>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>
</section>

 ]]></description>
  <category>sci</category>
  <category>jcr</category>
  <guid>https://leslie-lu.github.io/blog/2024/06/23/JCR_2023/index.html</guid>
  <pubDate>Sun, 23 Jun 2024 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202406231731181.png" medium="image" type="image/png"/>
</item>
<item>
  <title>常用损失函数</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/06/07/loss_function/index.html</link>
  <description><![CDATA[ 




<section id="loss-function" class="level3">
<h3 class="anchored" data-anchor-id="loss-function">loss function</h3>
<p>在机器学习/深度学习任务中，衡量模型预测值与真实值之间的差异的指标称为损失函数。损失函数是模型训练的关键组成部分，它可以帮助我们优化模型参数，使得模型的预测值更加接近真实值。预测任务的目标也是最小化损失函数，如，我们利用反向传播算法等方法，通过更新损失函数相对于模型参数的梯度来最小化损失函数，提高模型的预测能力。此外，有效的损失函数还可以帮助我们平衡模型的偏差和方差，提高模型的泛化能力。</p>
<p>依据预测任务的不同，损失函数可以分为回归任务和分类任务两大类。回归任务的损失函数通常是均方误差（MSE）或平均绝对误差（MAE），而分类任务的损失函数则有交叉熵损失函数、Hinge损失函数等。本文将介绍常用的损失函数及其应用场景。</p>
<section id="均方误差mse" class="level4">
<h4 class="anchored" data-anchor-id="均方误差mse">均方误差（MSE）</h4>
<p>均方误差（Mean Squared Error，MSE）是回归任务中最常用的损失函数之一，它衡量模型预测值与真实值之间的差异。MSE的计算公式如下：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AMSE%20=%20%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi=1%7D%5E%7Bn%7D%20(y_i%20-%20%5Chat%7By%7D_i)%5E2%0A"></p>
<p>可以看到，MSE是预测值与真实值之间差值的平方和的均值，它对较大差异分配更高的惩罚。MSE非负，越小，说明模型的预测值与真实值之间的差异越小，模型的预测能力越好。MSE对异常值敏感，因为它是差值的平方和，异常值的平方会放大差异，导致模型的预测能力下降。</p>
<p>其在pytorch中的实现：</p>
<div id="mse" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1">torch.nn.MSELoss(reduction<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'mean'</span>)</span></code></pre></div>
</div>
</section>
<section id="平均绝对误差mae" class="level4">
<h4 class="anchored" data-anchor-id="平均绝对误差mae">平均绝对误差（MAE）</h4>
<p>平均绝对误差（Mean Absolute Error，MAE）是回归任务中另一种常用的损失函数。MAE的计算公式如下：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AMAE%20=%20%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi=1%7D%5E%7Bn%7D%20%7Cy_i%20-%20%5Chat%7By%7D_i%7C%0A"></p>
<p>相比于MSE，MAE是预测值与真实值之间差值的绝对值的均值，它对异常值不敏感，因为它是差值的绝对值的和，不会对某一异常值的差异分配过高的权重。MAE的值越小，说明模型的预测值与真实值之间的差异越小，模型的预测能力越好。</p>
<p>针对MAE和MSE的优缺点，我们可以根据具体的任务需求选择合适的损失函数。如果任务需要重点关注异常值，可以选择MSE，否则选择MAE。</p>
<div id="mae" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1">torch.nn.L1Loss(reduction<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'mean'</span>)</span></code></pre></div>
</div>
</section>
<section id="huber-loss" class="level4">
<h4 class="anchored" data-anchor-id="huber-loss">Huber loss</h4>
<p>Huber loss是一种结合了MSE和MAE的损失函数，它在差值较小的情况下使用MSE，差值较大的情况下使用MAE。Huber loss的计算公式如下：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AL_%7B%5Cdelta%7D(y,%20%5Chat%7By%7D)%20=%20%5Cleft%5C%7B%0A%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cfrac%7B1%7D%7B2%7D(y%20-%20%5Chat%7By%7D)%5E2,%20&amp;%20%5Ctext%7Bif%20%7D%20%7Cy%20-%20%5Chat%7By%7D%7C%20%5Cleq%20%5Cdelta%20%5C%5C%0A%5Cdelta%20%7Cy%20-%20%5Chat%7By%7D%7C%20-%20%5Cfrac%7B1%7D%7B2%7D%20%5Cdelta%5E2,%20&amp;%20%5Ctext%7Botherwise%7D%0A%5Cend%7Barray%7D%0A%5Cright.%0A"></p>
<p>其中，<img src="https://latex.codecogs.com/png.latex?%5Cdelta">是一个超参数，用于控制MSE和MAE之间的平衡。Huber loss对异常值不敏感，同时保留了MSE的平滑性，是一种较为稳健的损失函数。</p>
<div id="smoothl1loss" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1">torch.nn.SmoothL1Loss(reduction<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'mean'</span>)</span></code></pre></div>
</div>
</section>
<section id="二元交叉熵损失函数binary-cross-entropy-loss" class="level4">
<h4 class="anchored" data-anchor-id="二元交叉熵损失函数binary-cross-entropy-loss">二元交叉熵损失函数（Binary Cross Entropy Loss）</h4>
<p>交叉熵损失函数（Cross Entropy Loss）是二分类任务中最常用的损失函数之一，我们前面也以及<a href="https://mp.weixin.qq.com/s/y2gZKXebDv3tKha7Hu5Djw">介绍过</a>。交叉熵损失函数的计算公式如下：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AL(y,%20%5Chat%7By%7D)%20=%20-%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi=1%7D%5E%7Bn%7D%20y_i%20%5Clog(%5Chat%7By%7D_i)%20+%20(1%20-%20y_i)%20%5Clog(1%20-%20%5Chat%7By%7D_i)%0A"></p>
<p>其中，<img src="https://latex.codecogs.com/png.latex?y_i">是真实标签，<img src="https://latex.codecogs.com/png.latex?%5Chat%7By%7D_i">是模型预测的概率值。交叉熵损失函数对于模型预测的概率值和真实标签之间的差异进行了惩罚，使得模型更加关注预测正确的类别。交叉熵损失函数是一种凸函数，可以通过梯度下降等方法进行优化。</p>
<div id="bce" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1">torch.nn.BCELoss(weight<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">None</span>, reduction<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'mean'</span>)</span></code></pre></div>
</div>
</section>
<section id="多类交叉熵损失函数categorical-cross-entropy-loss" class="level4">
<h4 class="anchored" data-anchor-id="多类交叉熵损失函数categorical-cross-entropy-loss">多类交叉熵损失函数（Categorical Cross Entropy Loss）</h4>
<p>多类交叉熵损失函数是多分类任务中常用的损失函数之一，它是交叉熵损失函数的扩展。多类交叉熵损失函数的计算公式如下：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AL(y,%20%5Chat%7By%7D)%20=%20-%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi=1%7D%5E%7Bn%7D%20%5Csum_%7Bj=1%7D%5E%7Bm%7D%20y_%7Bij%7D%20%5Clog(%5Chat%7By%7D_%7Bij%7D)%0A"></p>
<p>其中，<img src="https://latex.codecogs.com/png.latex?y_%7Bij%7D">是真实标签，<img src="https://latex.codecogs.com/png.latex?%5Chat%7By%7D_%7Bij%7D">是模型预测的概率值。</p>
<div id="ce" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1">torch.nn.CrossEntropyLoss(weight<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">None</span>,ignore_index<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">100</span>, reduction<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'mean'</span>)</span></code></pre></div>
</div>
</section>
<section id="hinge损失函数" class="level4">
<h4 class="anchored" data-anchor-id="hinge损失函数">Hinge损失函数</h4>
<p>Hinge损失函数是支持向量机（SVM）中常用的损失函数之一，它适用于二分类任务。Hinge损失函数的计算公式如下：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AL(y,%20%5Chat%7By%7D)%20=%20%5Cmax(0,%201%20-%20y%20%5Ccdot%20%5Chat%7By%7D)%0A"></p>
<p>Hinge损失函数旨在最大化决策边界的间隔，即使得正确分类的样本距离决策边界的距离尽可能大。Hinge损失函数对于误分类的样本进行了惩罚，使得模型更加关注分类边界附近的样本，从而尽可能把数据点推向远离决策边界的方向。</p>
<p>代码已经放进了<a href="https://mp.weixin.qq.com/s/4IR-KMAZ-q2VbI0Fz4fYRg">星球</a>里。</p>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>
</section>
</section>

 ]]></description>
  <category>python</category>
  <category>machine learning</category>
  <category>deep learning</category>
  <category>loss function</category>
  <guid>https://leslie-lu.github.io/blog/2024/06/07/loss_function/index.html</guid>
  <pubDate>Fri, 07 Jun 2024 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202406072019199.png" medium="image" type="image/png"/>
</item>
<item>
  <title>Python中机器学习模型的校准</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/05/17/calibration/index.html</link>
  <description><![CDATA[ 




<section id="calibration" class="level3">
<h3 class="anchored" data-anchor-id="calibration">calibration</h3>
<p>在我们利用机器学习模型来建模分类预测时，首要关注的指标能力当然是dircrimination，即模型的预测区分能力。常见的指标有sensitivity、specificity、AUROC等。我们在上一篇<a href="https://mp.weixin.qq.com/s/wolSW-kdUU8IC293KR9gKg">文章</a>中介绍了如何选择最优分类阈值，这里我们接着介绍在选择了最优阈值后，如何评估模型的<a href="https://mp.weixin.qq.com/s/OdSDu3XXXTbTz_-lYirs5w">校准能力</a>。</p>
<p>所谓校准能力，即模型预测的概率与实际发生的概率<strong>一致</strong>。</p>
<p>通俗来解释这个事情：比如说，我们模型预测某个病人患病的概率是0.8，那么，按照概率定义理解，模型预测概率为0.8时，100个人中应该有80个人最终患病，这个结果体现了模型的校准能力和稳定性。如果模型预测概率为0.8时，实际只有20个人患病，那么，模型的校准能力就不够好，你也不会信任这个模型在实际应用中的预测结果。这就是校准能力的重要性，即你的模型最终输出的概率值要准确反映出事件实际发生的概率。</p>
</section>
<section id="如何评价calibration" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="如何评价calibration">如何评价calibration</h3>
<section id="calibration-plot" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="calibration-plot">calibration plot</h4>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2024/05/17/calibration/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202405171632445.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">calibration curve</figcaption>
</figure>
</div>
<p>上图是一个典型的calibration curve，也是我们在文章中常见的图。</p>
<p>我们将模型预测概率cut或者quantile成5或者10个区间（bin），每个区间预测概率的均值作为x轴，每个区间实际发生的概率作为y轴，然后画出来这个曲线。这个图是评价模型校准能力的一个直观指标。python中可以轻松实现这个工作：</p>
<div id="calibration--plot" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> sklearn.calibration <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> calibration_curve</span>
<span id="cb1-2">y_means, pred_means <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> calibration_curve(y_true, y_pred, n_bins<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">10</span>,strategy)</span></code></pre></div>
</div>
<p>理想情况下，所有点都在对角线上，即模型预测的概率与实际发生的概率完全一致。如果点在对角线上方，说明模型低估，反之，高估。</p>
<p>calibration level的定义有：</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2024/05/17/calibration/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202405171653641.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">calibration level<span class="citation" data-cites="RN410">(Alonzo 2009)</span></figcaption>
</figure>
</div>
</section>
<section id="其他指标" class="level4">
<h4 class="anchored" data-anchor-id="其他指标">其他指标</h4>
<p>除了calibration plot，我们还可以用其他指标来评价模型的校准能力，比如说Brier score、Hosmer-Lemeshow test、calibration in the large等。这里不做详细介绍。</p>
<p>我们感兴趣的是，当我们通过上述方法评价了模型的校准能力后，如果发现模型的校准能力不够好，我们应该怎么办？</p>
</section>
</section>
<section id="calibrate-model" class="level3">
<h3 class="anchored" data-anchor-id="calibrate-model">calibrate model</h3>
<p>我们已经发现，模型输出值并不能代表概率。python中一般有<strong>predict_proba</strong>方法，即这个方法其实并不能保证输出的概率是真实的概率。</p>
<div id="predict_proba" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> sklearn.ensemble <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> RandomForestClassifier</span>
<span id="cb2-2">model<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> RandomForestClassifier().fit(X_train, y_train)</span>
<span id="cb2-3">y_pred <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> model.predict_proba(X_test)[:,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>]</span></code></pre></div>
</div>
<p>所以，我们需要对模型进行校准。</p>
<section id="platt-scaling" class="level4">
<h4 class="anchored" data-anchor-id="platt-scaling">Platt scaling</h4>
<p>Platt scaling是一种常见的校准方法，其原理是对模型输出的概率以及真实标签，用一个logistic regression模型来拟合，从而实现对模型输出的概率进行校准，拿到最终的概率。</p>
<div id="platt-scaling" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> sklearn.calibration <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> CalibratedClassifierCV</span>
<span id="cb3-2">calibrated <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> CalibratedClassifierCV(model, method<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'sigmoid'</span>, cv<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>)</span>
<span id="cb3-3">calibrated.fit(X_train, y_train)</span></code></pre></div>
</div>
</section>
<section id="isotonic-regression" class="level4">
<h4 class="anchored" data-anchor-id="isotonic-regression">Isotonic regression</h4>
<p>Isotonic regression是另一种校准方法，其原理是对模型输出的概率以及真实标签，用一个isotonic regression模型来拟合，从而实现对模型输出的概率进行校准。</p>
<div id="isotonic-regression" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> sklearn.isotonic <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> IsotonicRegression</span>
<span id="cb4-2">ir <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> IsotonicRegression().fit(y_pred, y_test)</span></code></pre></div>
</div>
</section>
<section id="bayesian-binning-into-quantiles" class="level4">
<h4 class="anchored" data-anchor-id="bayesian-binning-into-quantiles">bayesian binning into quantiles</h4>
<p>BBQ是一种基于贝叶斯的校准方法，其原理是将预测概率分成若干个区间，然后在每个区间内对概率进行校准。该方法结合了分箱（binning）和贝叶斯推断的优点，可以在样本量较小时仍然保持较好的校准效果。</p>
<p>还有其他方法可以供尝试。</p>
</section>
</section>
<section id="take-home-message" class="level3">
<h3 class="anchored" data-anchor-id="take-home-message">take home message</h3>
<p>在利用机器学习模型进行分类预测时，我们不可忽视模型的校准能力。</p>
<p>代码已经放进了<a href="https://mp.weixin.qq.com/s/4IR-KMAZ-q2VbI0Fz4fYRg">星球</a>里。</p>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>
</section>
</section>
<section id="references" class="level3">



<!-- -->


</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-RN410" class="csl-entry">
Alonzo, T. A. 2009. <span>“Clinical Prediction Models: A Practical Approach to Development, Validation, and Updating: By Ewout w. Steyerberg.”</span> Generic. Oxford University Press.
</div>
</div></section><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@online{lu2024,
  author = {Lu, Zhen},
  title = {Python中机器学习模型的校准},
  date = {2024-05-17},
  url = {https://leslie-lu.github.io//blog/2024/05/17/calibration},
  langid = {en}
}
</code></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-lu2024" class="csl-entry quarto-appendix-citeas">
Lu, Zhen. 2024. <span>“Python中机器学习模型的校准.”</span> May 17, 2024.
<a href="https://leslie-lu.github.io//blog/2024/05/17/calibration">https://leslie-lu.github.io//blog/2024/05/17/calibration</a>.
</div></div></section></div> ]]></description>
  <category>python</category>
  <category>machine learning</category>
  <category>calibration</category>
  <guid>https://leslie-lu.github.io/blog/2024/05/17/calibration/index.html</guid>
  <pubDate>Fri, 17 May 2024 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202405171632445.png" medium="image" type="image/png"/>
</item>
<item>
  <title>Hierarchical composite endpoints治疗效应的可视化</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/05/13/hierarchical_composite_endpoints/index.html</link>
  <description><![CDATA[ 




<section id="复合终点" class="level3">
<h3 class="anchored" data-anchor-id="复合终点">复合终点</h3>
<p>有时，根据主要研究目的，我们很难从多个终点指标中选出其中某一个作为主要终点，此时，我们可以利用<strong>复合终点</strong>来作为主要终点。</p>
<p>Hierarchical composite endpoints (<a href="https://cran.r-project.org/web/packages/hce/hce.pdf">HCE</a>)可以整合不同类型、不同重要性终点成一个有序终点指标，以表示患者经历的不同严重程度的终点。如，在固定随访的RCT中，outcomes of interest可以是death、hospitalization，而这两个终点存在严重程度的差异。很明显，死亡是最严重的。同样最终死亡的两个患者，生存时间更长，意味治疗效应更好；同样最终住院的两个患者，入院前时间更长，治疗效应更好；同样未住院的两个患者，某一实验室指标的change from baseline更大，效应更好。</p>
<p>对于这种HCE，我们可以计算win odds<span class="citation" data-cites="RN1185">(Gasparyan et al. 2021)</span>来比较组间差异，然而，治疗效应的可视化受到复合终点的影响，不容易像单纯的生存曲线那样用合适的工具可视化出来。</p>
<p>针对这一问题，AstraZeneca的Martin Karpefors等人提出了一种新的方法，即<em>maraca plot<span class="citation" data-cites="RN1187">(Karpefors, Lindholm, and Gasparyan 2023)</span></em>。这种方法可以将复合终点中time to event(TTE)以及连续性终点的治疗效应可视化出来，同时也可以用来比较不同治疗组之间的差异。对应的<a href="https://cran.r-project.org/web/packages/maraca/index.html">R包</a>可以方便地实现这一点。</p>
</section>
<section id="maraca-plot" class="level3">
<h3 class="anchored" data-anchor-id="maraca-plot">maraca plot</h3>
<p>maraca基于ggplot2，其中，对于TTE采用Kaplan-Meier曲线展示cumulative proportions，对于连续性终点可选用箱线图、violin plot以及scatter plot展示连续性分布。这种方法可以同时展示HCE的不同组成成分。</p>
<p>来看一个例子。</p>
<div class="cell" data-hash="index_cache/html/libraries_aae59afc246ff0df0303add1d49e7116">
<div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">library</span>(maraca)</span>
<span id="cb1-2"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">data</span>(hce_scenario_a, <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">package =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"maraca"</span>)</span>
<span id="cb1-3">data <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> hce_scenario_a</span>
<span id="cb1-4">data <span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">|&gt;</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">head</span>()</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  SUBJID              GROUP GROUPN      AVAL0       AVAL    TRTP
1      1          Outcome I      0 120.440921   120.4409  Active
2      2 Continuous outcome  40000   3.345229 40003.3452 Control
3      3 Continuous outcome  40000  22.802615 40022.8026  Active
4      4          Outcome I      0 577.311386   577.3114 Control
5      5         Outcome II  10000 781.758081 10781.7581  Active
6      6        Outcome III  20000 985.097981 20985.0980 Control</code></pre>
</div>
</div>
<p>具体变量意义，大家可以查看<code>?hce_scenario_a</code>。</p>
<p>可视化如下：</p>
<div class="cell" data-layout-align="center" data-hash="index_cache/html/maraca-plot_90f126d45e058f991796050627aaba01">
<div class="sourceCode cell-code" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1">column_names <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">c</span>(<span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">outcome =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"GROUP"</span>, <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">arm =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"TRTP"</span>, <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">value =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"AVAL0"</span>)</span>
<span id="cb3-2">tte_outcomes <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">c</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Outcome I"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Outcome II"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Outcome III"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Outcome IV"</span>)</span>
<span id="cb3-3">continuous_outcome <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Continuous outcome"</span></span>
<span id="cb3-4">arm_levels <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">c</span>(<span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">active =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Active"</span>, <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">control =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Control"</span>)</span>
<span id="cb3-5">maraca_object <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">maraca</span>(</span>
<span id="cb3-6">  data, tte_outcomes, continuous_outcome, arm_levels, column_names,</span>
<span id="cb3-7">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">fixed_followup =</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">365</span>, <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">compute_win_odds =</span> <span class="cn" style="color: #8f5902;
background-color: null;
font-style: inherit;">TRUE</span></span>
<span id="cb3-8">)</span>
<span id="cb3-9">AZ_colors <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">c</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"#830051"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"#F0AB00"</span>)</span>
<span id="cb3-10"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">plot</span>(maraca_object, <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">density_plot_type =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"default"</span>) <span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">theme_bw</span>() <span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span></span>
<span id="cb3-11">  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">scale_color_manual</span>(<span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">values =</span> AZ_colors) <span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span></span>
<span id="cb3-12">  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">scale_fill_manual</span>(<span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">values =</span> AZ_colors)</span></code></pre></div>
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://leslie-lu.github.io/blog/2024/05/13/hierarchical_composite_endpoints/index_files/figure-html/maraca-plot-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="结果解释" class="level3">
<h3 class="anchored" data-anchor-id="结果解释">结果解释</h3>
<p>怎么看这张图？</p>
<p>首先是x轴上HCE的5个组成成分，x轴上每个成分的长度大小，代表了患者达到不同成分终点的比例，可以看到，continuous outcome的比例最大，说明这个终点的患者所占比例最大。其次，cumulative percentage显示active组在四个TTE终点上是存在差异的。再然后是continuous outcome的分布，偏向x轴右侧代表change from baseline更大。而这些结合起来，就是win odds的结果，可以看到，和我们从可视化的角度看到的结果是一致的。</p>
<p>代码已经放进了<a href="https://mp.weixin.qq.com/s/4IR-KMAZ-q2VbI0Fz4fYRg">星球</a>里。</p>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">



<!-- -->


</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">Did you find this page helpful? Consider sharing it 🙌</h2><div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-RN1185" class="csl-entry">
Gasparyan, S. B., E. K. Kowalewski, F. Folkvaljon, O. Bengtsson, J. Buenconsejo, J. Adler, and G. G. Koch. 2021. <span>“Power and Sample Size Calculation for the Win Odds Test: Application to an Ordinal Endpoint in COVID-19 Trials.”</span> Journal Article. <em>Journal of Biopharmaceutical Statistics</em> 31 (6): 765–87.
</div>
<div id="ref-RN1187" class="csl-entry">
Karpefors, M., D. Lindholm, and S. B. Gasparyan. 2023. <span>“The Maraca Plot: A Novel Visualization of Hierarchical Composite Endpoints.”</span> Journal Article. <em>Clinical Trials (London, England)</em> 20 (1): 84–88. <a href="https://doi.org/10.1177/17407745221134949">https://doi.org/10.1177/17407745221134949</a>.
</div>
</div></section><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@online{lu2024,
  author = {Lu, Zhen},
  title = {Hierarchical Composite {endpoints治疗效应的可视化}},
  date = {2024-05-13},
  url = {https://leslie-lu.github.io//blog/2024/05/13/hierarchical_composite_endpoints},
  langid = {en}
}
</code></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-lu2024" class="csl-entry quarto-appendix-citeas">
Lu, Zhen. 2024. <span>“Hierarchical Composite
Endpoints治疗效应的可视化.”</span> May 13, 2024. <a href="https://leslie-lu.github.io//blog/2024/05/13/hierarchical_composite_endpoints">https://leslie-lu.github.io//blog/2024/05/13/hierarchical_composite_endpoints</a>.
</div></div></section></div> ]]></description>
  <category>r</category>
  <category>clinical trial</category>
  <category>endpoint</category>
  <guid>https://leslie-lu.github.io/blog/2024/05/13/hierarchical_composite_endpoints/index.html</guid>
  <pubDate>Mon, 13 May 2024 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202405131659328.png" medium="image" type="image/png"/>
</item>
<item>
  <title>最优分类阈值</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/05/11/optimal_threshold/index.html</link>
  <description><![CDATA[ 




<p>这里我们借助<em>scikit-learn</em>来探讨分类问题中阈值的选择。</p>
<section id="数据准备和参数选择" class="level3">
<h3 class="anchored" data-anchor-id="数据准备和参数选择">数据准备和参数选择</h3>
<p>首先是数据准备：</p>
<div id="libraries-n-things" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> matplotlib.pyplot <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> plt</span>
<span id="cb1-2"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> numpy <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> np</span>
<span id="cb1-3"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> pandas <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> pd</span>
<span id="cb1-4"></span>
<span id="cb1-5"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> sklearn.datasets <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> load_breast_cancer</span>
<span id="cb1-6"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> sklearn.model_selection <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> train_test_split</span>
<span id="cb1-7"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> sklearn.metrics <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> confusion_matrix</span>
<span id="cb1-8"></span>
<span id="cb1-9">np.set_printoptions(suppress<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">True</span>, precision<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">8</span>, linewidth<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1000</span>)</span>
<span id="cb1-10">pd.options.mode.chained_assignment <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">None</span></span>
<span id="cb1-11">pd.set_option(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'display.max_columns'</span>, <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">None</span>)</span>
<span id="cb1-12">pd.set_option(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'display.width'</span>, <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">None</span>)</span>
<span id="cb1-13"></span>
<span id="cb1-14">data <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> load_breast_cancer()</span>
<span id="cb1-15">X <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> data[<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"data"</span>]</span>
<span id="cb1-16">y <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> data[<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"target"</span>]</span>
<span id="cb1-17"></span>
<span id="cb1-18">Xtrain, Xvalid, ytrain, yvalid <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> train_test_split(X, y, test_size<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">.20</span>, random_state<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">516</span>)</span>
<span id="cb1-19"></span>
<span id="cb1-20"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"Xtrain.shape: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>Xtrain<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>shape<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span>
<span id="cb1-21"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"Xvalid.shape: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>Xvalid<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>shape<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Xtrain.shape: (455, 30)
Xvalid.shape: (114, 30)</code></pre>
</div>
</div>
<p>模型我们这里选择<em>随机森林</em>。超参的选择，基于<code>GridSearchCV</code>，这里也不赘述。有一个点需要说明，由于使用的是肿瘤数据集，在这种情况下，我们更关注的是<code>recall</code>，即尽量减少假阴性的情况。因而，我们在训练模型时，也是将recall作为评价指标。</p>
<div id="train-model-rf" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> sklearn.ensemble <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> RandomForestClassifier</span>
<span id="cb3-2"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> sklearn.model_selection <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> GridSearchCV</span>
<span id="cb3-3"></span>
<span id="cb3-4">param_grid <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> {</span>
<span id="cb3-5">    <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"n_estimators"</span>: [<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">100</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">150</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">250</span>],</span>
<span id="cb3-6">    <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"min_samples_leaf"</span>: [<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">4</span>],</span>
<span id="cb3-7">    <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"ccp_alpha"</span>: [<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">.1</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">.2</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">.3</span>]</span>
<span id="cb3-8">    }</span>
<span id="cb3-9"></span>
<span id="cb3-10">mdl <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> GridSearchCV(</span>
<span id="cb3-11">    RandomForestClassifier(random_state<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">516</span>), </span>
<span id="cb3-12">    param_grid, </span>
<span id="cb3-13">    scoring<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"recall"</span>, </span>
<span id="cb3-14">    cv<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span></span>
<span id="cb3-15">    )</span>
<span id="cb3-16"></span>
<span id="cb3-17">mdl.fit(Xtrain, ytrain)</span>
<span id="cb3-18"></span>
<span id="cb3-19"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"best parameters: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>mdl<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>best_params_<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>best parameters: {'ccp_alpha': 0, 'min_samples_leaf': 4, 'n_estimators': 100}</code></pre>
</div>
</div>
</section>
<section id="模型预测" class="level3">
<h3 class="anchored" data-anchor-id="模型预测">模型预测</h3>
<p>拿到模型后，自然我们可以开始预测：</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1">ypred <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> mdl.predict_proba(Xvalid)[:,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>]</span>
<span id="cb5-2">ypred</span></code></pre></div>
<div id="predict" class="cell-output cell-output-display" data-execution_count="3">
<pre><code>array([0.005     , 0.82743637, 0.97088095, 0.        , 0.        , 1.        , 0.98020202, 0.67380556, 0.        , 0.99333333, 0.9975    , 0.30048576, 0.9528113 , 0.99666667, 0.04102381, 0.99444444, 1.        , 0.828226  , 0.        , 0.        , 0.97916667, 1.        , 0.99607143, 0.90425163, 0.        , 0.02844156, 0.99333333, 0.98183333, 0.9975    , 0.08869769, 0.97369841, 0.        , 1.        , 0.71100866, 0.96022727, 0.        , 0.71200885, 0.06103175, 0.005     , 0.99490476, 0.1644127 , 0.        , 0.23646934, 1.        , 0.57680164, 0.64901715, 0.9975    , 0.61790818, 0.95509668, 0.99383333, 0.04570455, 0.97575758, 1.        , 0.47115815, 0.92422619, 0.77371415, 0.        , 1.        , 0.26198657, 0.        , 0.28206638, 0.95216162, 0.98761905, 0.99464286, 0.98704762, 0.85579351, 0.10036905, 0.00222222, 0.98011905, 0.99857143, 0.92285967, 0.95180556, 0.97546947, 0.84433189, 0.005     , 0.99833333, 0.83616339, 1.        , 0.9955    , 1.        , 0.99833333, 1.        ,
       0.86399315, 0.9807381 , 0.        , 0.99833333, 0.9975    , 0.        , 0.98733333, 0.96822727, 0.23980827, 0.7914127 , 0.        , 0.98133333, 1.        , 1.        , 0.89251019, 0.9498226 , 0.18943254, 0.83494391, 0.9975    , 1.        , 0.77079113, 0.99722222, 0.30208297, 1.        , 0.92111977, 0.99428571, 0.91936508, 0.47118074, 0.98467172, 0.006     , 0.05750305, 0.96954978])</code></pre>
</div>
</div>
<p>这个时候，我们要讲的东西就来了。一般地，我们会选择0.50作为分类阈值，即大于0.50的为正类，小于0.50的为负类。</p>
<div id="threshold-0.50" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb7" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1">ypred <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> mdl.predict_proba(Xvalid)[:,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>].reshape(<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>)</span>
<span id="cb7-2">yhat <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> mdl.predict(Xvalid).reshape(<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>)</span>
<span id="cb7-3">preds <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.concatenate([ypred, yhat], axis<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>)</span>
<span id="cb7-4"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(preds)</span>
<span id="cb7-5"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(confusion_matrix(yvalid, yhat))</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[0.005      0.        ]
 [0.82743637 1.        ]
 [0.97088095 1.        ]
 [0.         0.        ]
 [0.         0.        ]
 [1.         1.        ]
 [0.98020202 1.        ]
 [0.67380556 1.        ]
 [0.         0.        ]
 [0.99333333 1.        ]
 [0.9975     1.        ]
 [0.30048576 0.        ]
 [0.9528113  1.        ]
 [0.99666667 1.        ]
 [0.04102381 0.        ]
 [0.99444444 1.        ]
 [1.         1.        ]
 [0.828226   1.        ]
 [0.         0.        ]
 [0.         0.        ]
 [0.97916667 1.        ]
 [1.         1.        ]
 [0.99607143 1.        ]
 [0.90425163 1.        ]
 [0.         0.        ]
 [0.02844156 0.        ]
 [0.99333333 1.        ]
 [0.98183333 1.        ]
 [0.9975     1.        ]
 [0.08869769 0.        ]
 [0.97369841 1.        ]
 [0.         0.        ]
 [1.         1.        ]
 [0.71100866 1.        ]
 [0.96022727 1.        ]
 [0.         0.        ]
 [0.71200885 1.        ]
 [0.06103175 0.        ]
 [0.005      0.        ]
 [0.99490476 1.        ]
 [0.1644127  0.        ]
 [0.         0.        ]
 [0.23646934 0.        ]
 [1.         1.        ]
 [0.57680164 1.        ]
 [0.64901715 1.        ]
 [0.9975     1.        ]
 [0.61790818 1.        ]
 [0.95509668 1.        ]
 [0.99383333 1.        ]
 [0.04570455 0.        ]
 [0.97575758 1.        ]
 [1.         1.        ]
 [0.47115815 0.        ]
 [0.92422619 1.        ]
 [0.77371415 1.        ]
 [0.         0.        ]
 [1.         1.        ]
 [0.26198657 0.        ]
 [0.         0.        ]
 [0.28206638 0.        ]
 [0.95216162 1.        ]
 [0.98761905 1.        ]
 [0.99464286 1.        ]
 [0.98704762 1.        ]
 [0.85579351 1.        ]
 [0.10036905 0.        ]
 [0.00222222 0.        ]
 [0.98011905 1.        ]
 [0.99857143 1.        ]
 [0.92285967 1.        ]
 [0.95180556 1.        ]
 [0.97546947 1.        ]
 [0.84433189 1.        ]
 [0.005      0.        ]
 [0.99833333 1.        ]
 [0.83616339 1.        ]
 [1.         1.        ]
 [0.9955     1.        ]
 [1.         1.        ]
 [0.99833333 1.        ]
 [1.         1.        ]
 [0.86399315 1.        ]
 [0.9807381  1.        ]
 [0.         0.        ]
 [0.99833333 1.        ]
 [0.9975     1.        ]
 [0.         0.        ]
 [0.98733333 1.        ]
 [0.96822727 1.        ]
 [0.23980827 0.        ]
 [0.7914127  1.        ]
 [0.         0.        ]
 [0.98133333 1.        ]
 [1.         1.        ]
 [1.         1.        ]
 [0.89251019 1.        ]
 [0.9498226  1.        ]
 [0.18943254 0.        ]
 [0.83494391 1.        ]
 [0.9975     1.        ]
 [1.         1.        ]
 [0.77079113 1.        ]
 [0.99722222 1.        ]
 [0.30208297 0.        ]
 [1.         1.        ]
 [0.92111977 1.        ]
 [0.99428571 1.        ]
 [0.91936508 1.        ]
 [0.47118074 0.        ]
 [0.98467172 1.        ]
 [0.006      0.        ]
 [0.05750305 0.        ]
 [0.96954978 1.        ]]
[[35  3]
 [ 1 75]]</code></pre>
</div>
</div>
<p>但是，这个阈值是可以调整的。我们可以通过调整阈值来达到不同的目的。比如，我们可以通过调整阈值来减少假阴性的情况，这在类别不平衡时尤为重要。</p>
</section>
<section id="阈值的选择" class="level3">
<h3 class="anchored" data-anchor-id="阈值的选择">阈值的选择</h3>
<p>我们介绍几种常用的方法。</p>
<section id="阳性类别prevalance" class="level4">
<h4 class="anchored" data-anchor-id="阳性类别prevalance">1. 阳性类别prevalance</h4>
<p>我们看下这个数据集中阳性类别的比例：</p>
<div id="positive-prevalance" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb9" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"Proportion of positives in training set: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>ytrain<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">sum</span>() <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span> ytrain<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>shape[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">:.2f}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Proportion of positives in training set: 0.62</code></pre>
</div>
</div>
<p>这个toy数据集很夸张哈，达到了0.62。在实际应用中，这个比例可能只有10%或者1%。这里我们只是拿它示例哈，用这个prevalance来作为阈值。</p>
<div id="threshold-prevalance" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb11" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1">thresh <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> ytrain.<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">sum</span>() <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span> ytrain.shape[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]</span>
<span id="cb11-2">yhat <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.where(ypred <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;=</span> thresh, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>)</span>
<span id="cb11-3"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(confusion_matrix(yvalid, yhat))</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[34  4]
 [ 0 76]]</code></pre>
</div>
</div>
<p>考虑prevalance的方法，可以在类别不平衡的情况下，减少假阴性的情况。</p>
</section>
<section id="最优f1指数" class="level4">
<h4 class="anchored" data-anchor-id="最优f1指数">2. 最优F1指数</h4>
<p>F1指数是precision和recall的调和平均数。我们可以通过最大F1指数来选择最优的阈值。</p>
<div id="threshold-f1" class="cell" data-execution_count="7">
<div class="cell-output cell-output-stdout">
<pre><code>Threshold using optimal f1-score: 0.471.</code></pre>
</div>
</div>
<p>F1最高为0.471，我们采用它来进行预测：</p>
<div id="threshold-f1-predict" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb14" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1">thresh <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">.471</span></span>
<span id="cb14-2">yhat <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.where(ypred <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;=</span> thresh, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>)</span>
<span id="cb14-3"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(confusion_matrix(yvalid, yhat))</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[34  4]
 [ 0 76]]</code></pre>
</div>
</div>
</section>
<section id="roc曲线" class="level4">
<h4 class="anchored" data-anchor-id="roc曲线">3. ROC曲线</h4>
<p>我们可以通过<a href="https://mp.weixin.qq.com/s/Zw85hAdx7VdwCioG5NwHQw">ROC曲线</a>来选择最优的阈值。ROC曲线下的面积AUC越大，说明模型越好。我们可以选择ROC曲线最靠近左上角的点作为最优阈值。</p>
<div class="cell" data-execution_count="9">
<div class="cell-output cell-output-display">
<div id="threshold-roc" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="https://leslie-lu.github.io/blog/2024/05/11/optimal_threshold/index_files/figure-html/threshold-roc-output-1.png" class="figure-img" width="445" height="447"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="prc曲线" class="level4">
<h4 class="anchored" data-anchor-id="prc曲线">4. PRC曲线</h4>
<p>PRC曲线是<a href="https://mp.weixin.qq.com/s/Zw85hAdx7VdwCioG5NwHQw">precision-recall曲线</a>。相比于ROC曲线，PRC曲线更适合类别不平衡的情况。我们主要选择PRC曲线最靠近右上角的点作为最优阈值。</p>
<div class="cell" data-execution_count="10">
<div class="cell-output cell-output-display">
<div id="threshold-prc" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="https://leslie-lu.github.io/blog/2024/05/11/optimal_threshold/index_files/figure-html/threshold-prc-output-1.png" class="figure-img" width="445" height="447"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Selected threshold using precision-recall curve: 0.674.</code></pre>
</div>
</div>
</section>
<section id="分别关注precision和recall" class="level4">
<h4 class="anchored" data-anchor-id="分别关注precision和recall">5. 分别关注precision和recall</h4>
<p>我们可以通过调整阈值来分别关注precision和recall。比如，我们可以通过调整阈值来提高recall，减少假阴性的情况。</p>
<div class="cell" data-execution_count="11">
<div class="cell-output cell-output-display">
<div id="threshold-pre-recall" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="https://leslie-lu.github.io/blog/2024/05/11/optimal_threshold/index_files/figure-html/threshold-pre-recall-output-1.png" class="figure-img" width="614" height="374"></p>
</figure>
</div>
</div>
</div>
<p><br></p>
<p>代码已经放进了<a href="https://mp.weixin.qq.com/s/4IR-KMAZ-q2VbI0Fz4fYRg">星球</a>里。</p>
<p><br></p>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>
</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@online{lu2024,
  author = {Lu, Zhen},
  title = {最优分类阈值},
  date = {2024-05-11},
  url = {https://leslie-lu.github.io//blog/2024/05/11/optimal_threshold},
  langid = {en}
}
</code></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-lu2024" class="csl-entry quarto-appendix-citeas">
Lu, Zhen. 2024. <span>“最优分类阈值.”</span> May 11, 2024. <a href="https://leslie-lu.github.io//blog/2024/05/11/optimal_threshold">https://leslie-lu.github.io//blog/2024/05/11/optimal_threshold</a>.
</div></div></section></div> ]]></description>
  <category>python</category>
  <category>machine learning</category>
  <guid>https://leslie-lu.github.io/blog/2024/05/11/optimal_threshold/index.html</guid>
  <pubDate>Sat, 11 May 2024 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202405112020810.png" medium="image" type="image/png"/>
</item>
<item>
  <title>空间中的向量</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2020/03/12/index.html</link>
  <description><![CDATA[ 




<p>我们知道，向量的坐标表示方法并不是唯一的，它的具体表示和空间中基底的选择密切相关。</p>
<section id="向量的坐标" class="level3">
<h3 class="anchored" data-anchor-id="向量的坐标">向量的坐标</h3>
<p>向量的坐标依赖于选取的基底。</p>
<p>对于二维向量u=[4,5]⊤而言，我们一直以来都理所当然地认定一个事实：它表示一条在x轴上投影为4、y轴上投影为5的有向线段，它的坐标是(4,5)。这其实是基于一个没有刻意强调前提：利用方向为x轴、y轴正方向，且长度为1的两个向量，即Ex=[1,0]⊤，Ey=[0,1]⊤作为上述讨论的基础。因此，对于向量u而言，其完整的写法应该为u=4Ex + 5Ey，进一步展开就是u=4[1,0]⊤ + 5[0,1]⊤，这种形式的表意是最完整的。</p>
<p>这里被选中作为向量u基准的一组向量是Ex和Ey，它们被称为基底。基底的每一个成员向量被称为基向量，而坐标对应的就是各个基向量前的系数。一般情况下，若不做特殊说明，那么基向量都是选取沿着坐标轴正方向且长度为1的向量，这样方便描述和计算。</p>
<p>关于向量u的完整准确的说法是：在基底(Ex,Ey)下，其坐标是[4,5]⊤。也就是说，坐标必须依托于指定的基底才有意义。因此，要想准确地描述向量，首先就要确定一组基底，然后通过求出向量在各个基向量上的投影值，最后才能确定在这个基上的坐标值。</p>
</section>
<section id="向量在不同基底上表示为不同坐标" class="level3">
<h3 class="anchored" data-anchor-id="向量在不同基底上表示为不同坐标">向量在不同基底上表示为不同坐标</h3>
<p>一个指定的向量可以在多组不同的基底上进行坐标表示，在不同的基底表示下，坐标自然也是不同的。根据一组基底对应的坐标值去求另一组基底所对应的坐标值，这就是以后我们将会反复用到的坐标变换。</p>
<p>根据我们之前关于向量内积的介绍，最好是事先把基向量的模长转化为1。这样一来，从向量内积的内涵可以看出，若基向量的模长是1，那么就可以用目标向量内积基向量，从而可以直接获得该向量在这个基向量方向上的对应坐标值。实际上，对于任何一个向量，想要找到同方向上模长为1的向量并不是一件难事，只要让向量的各成分分别除以向量的模长即可，就能使向量的模长为单位1。而向量的坐标就是指定基的对应系数。</p>
</section>
<section id="构成基底的条件" class="level3">
<h3 class="anchored" data-anchor-id="构成基底的条件">构成基底的条件</h3>
<p>在一个n维空间中，不是随便选取n个向量都能作为一组基底，构成基底的向量必须满足这样的条件：在n维空间中，任意一个向量都可以表示为这一组基向量的线性组合，并且这种线性组合的表示方式（也就是系数）必须是唯一的。</p>
<ul>
<li><p>向量数量足够</p>
<p>若想成为三维空间中的一组基底，首先，其中的每个基向量的维数都必须是3；其次，基向量的个数也必须为3个。若数量不足，如只有两个三维向量a1和a2（假设它们是不共线的两个向量），那么无论对这两个向量怎么进行线性组合，它们都只能表示二者所构成的平面上的任意向量，而三维空间中位于该二维平面上外的任何一个向量，都无法由a1和a2的线性组合进行表示。</p></li>
<li><p>满足线性无关</p>
<p>如何确保表示方法的唯一性呢？这里我们引入向量线性无关的概念。一组向量需要满足线性无关的条件，即其中任何一个向量都不能通过其余向量的线性组合的形式进行表示。</p>
<p>换句话说，当且仅当x1=x2=x3=…=xn=0的等式关系成立时，线性组合x1u1 + x2u2 + x3u3 + … + xnun才能生成零向量，若xi中有非零值存在，那么这一组向量就是线性相关的。一组向量满足线性无关的条件等效于满足线性组合表示方法的唯一性（可以从反证法的角度说明线性无关和表示方法的唯一性是等价的）。</p>
<p>在这个三维空间中，要求所选取的3个基向量线性无关。若它们线性相关，那么x3就可以表示为x1和x2的线性组合，换句话说，备选的3个向量就处在一个平面上了。这样，自然无法通过线性组合的方法来表示三维空间中位于平面外的任何一个向量了，即3个三维向量之间由于彼此线性相关，因此无法张成整个三维空间，只能张成三维空间中的二维平面甚至是退化为一条直线。</p>
<p>若三维空间中基向量的个数超过3个，则是不行的。如，假设有4个向量试图成为该空间的一组基向量，任选出其中的3个向量，按照前提，假设它们之间满足线性无关性，那么对于第4个向量，由于它也处于三维空间中，则它一定能够被前3个向量的线性组合所表示。那么，三维空间中的这4个向量显示是线性相关的，无法满足向量构成基底的唯一性条件。</p></li>
</ul>
</section>
<section id="构成基底的条件-1" class="level3">
<h3 class="anchored" data-anchor-id="构成基底的条件-1">构成基底的条件</h3>
<p>对于一组向量，由它的所有线性组合所构成的空间称为这一组向量的张成空间。张成空间对所讨论向量的线性无关性没有要求，这些向量可以是线性相关的。</p>
<p>两个线性无关的二维向量，它们构成了二维空间中的一组基底，因此它们的张成空间就是整个二维空间；两个线性相关的共线二维向量，它们的张成空间是一条穿过原点的一维直线；等。</p>
<p>向量的个数和维数都不是其张成空间维数及形态的决定因素，具体的情况需要结合向量的线性无关性进行整体考量，这就会涉及秩的相关概念。</p>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>
</section>

 ]]></description>
  <category>biostatistics</category>
  <category>linear algebra</category>
  <guid>https://leslie-lu.github.io/blog/2020/03/12/index.html</guid>
  <pubDate>Thu, 12 Mar 2020 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202409021427240.webp" medium="image" type="image/webp"/>
</item>
<item>
  <title>Python与向量</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2020/03/11/index.html</link>
  <description><![CDATA[ 




<p>Python中一般使用numpy库生成一个向量，但其默认生成的是行向量。</p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> numpy <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> np</span>
<span id="cb1-2"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 行向量</span></span>
<span id="cb1-3">a<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.array([<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">4</span>])</span>
<span id="cb1-4"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(a)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1 2 3 4]</code></pre>
</div>
</div>
<p>但我们一般使用列向量的形式，因此需要对其做一些处理。有人想，转置处理就可以了，也就是把向量的行索引和列索隐交换位置。但是numpy重的转置方法对于一维数组是无效的：</p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1">a<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.array([<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">4</span>])</span>
<span id="cb3-2"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(a.transpose()) <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#从程序的运行结果来看，确实是无效的</span></span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1 2 3 4]</code></pre>
</div>
</div>
<p>应该如何表示一个列向量呢？</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1">A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.array([<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">4</span>])</span>
<span id="cb5-2">A_t<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> A[:, np.newaxis] <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#增加一个维度</span></span>
<span id="cb5-3"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(A_t)</span>
<span id="cb5-4"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(A_t.shape) <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#列向量本身就是二维表示的</span></span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[1]
 [2]
 [3]
 [4]]
(4, 1)</code></pre>
</div>
</div>
<p>这种做法比较复杂，更直观更简单的实现方法是：显然，我们一直把向量看作是一个维数为1的数组，其实也可以看作是行数为1或列数为1的一个二维数组。而二维数组对应的就是矩阵，因此向量还可以看作是一个特殊的矩阵，即可以把行向量看作是一个1<em>m的特殊矩阵，可以把列向量看作是一个n</em>1的特殊矩阵。</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb7" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 在对行向量进行初始化时，使用了numpy中的二维数组的初始化方法，因此在语句中多嵌套了一层中括号</span></span>
<span id="cb7-2">A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.array([[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">4</span>]])</span>
<span id="cb7-3"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(A)</span>
<span id="cb7-4"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(A.T) <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#此时可以直接通过行向量转置的方法生成对应的列向量</span></span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[1 2 3 4]]
[[1]
 [2]
 [3]
 [4]]</code></pre>
</div>
</div>
<section id="向量的加法" class="level3">
<h3 class="anchored" data-anchor-id="向量的加法">向量的加法</h3>
<p>两个维数相同的向量才能进行加法运算，只要将相同位置上的元素对应相加即可，结果向量的维数保持不变。</p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb9" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1">u<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.array([[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>]]).T</span>
<span id="cb9-2">u</span>
<span id="cb9-3">v<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.array([[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">6</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">7</span>]]).T</span>
<span id="cb9-4"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(u<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span>v)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[ 6]
 [ 8]
 [10]]</code></pre>
</div>
</div>
</section>
<section id="向量的数乘" class="level3">
<h3 class="anchored" data-anchor-id="向量的数乘">向量的数乘</h3>
<p>向量的数乘就是将参与乘法运算的标量同向量的每个元素分别相乘，以此得到最终的结果向量，结果向量的维数依然保持不变。从几何意义上来看，向量的数乘就是将向量沿着所在直线的方向拉伸相应的倍数，拉伸方向和参与运算的标量符号一致。</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb11" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1">u<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.array([[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>]]).T</span>
<span id="cb11-2"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span>u)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[3]
 [6]
 [9]]</code></pre>
</div>
</div>
</section>
<section id="向量间的乘法内积和外积" class="level3">
<h3 class="anchored" data-anchor-id="向量间的乘法内积和外积">向量间的乘法：内积和外积</h3>
<p>向量间的乘法分为内积和外积两种形式。</p>
<p>向量的内积运算：参与内积运算的两个向量必须维数相等，运算规则是先将对应位置上的元素相乘，然后合并相加，最终运算结果是一个标量。可能这样说不太好理解，要是从几何表示上看，内积的意义就非常清晰了。</p>
<p>内积的几何表示<code>u*v= |u||v|cosθ</code>，它表示向量u在向量v方向上的投影长度乘以向量v的模长。需要注意的是，在实际运算向量内积时，无论是行向量间的内积还是列向量间的内积，最终的运算结果都是一样的。</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb13" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1">u<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.array([<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>])</span>
<span id="cb13-2">v<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.array([<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">4</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">7</span>])</span>
<span id="cb13-3"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 若使用numpy库中的内积运算函数dot进行运算，传入的参数必须是用一维数组表示的行向量</span></span>
<span id="cb13-4"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(np.dot(u,v)) <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#一维乘一维，结果还是一维</span></span>
<span id="cb13-5"></span>
<span id="cb13-6">uC<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> u[:,np.newaxis]</span>
<span id="cb13-7">vC<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> v[:,np.newaxis]</span>
<span id="cb13-8"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(uC)</span>
<span id="cb13-9"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(vC)</span>
<span id="cb13-10"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(np.dot(uC,vC)) <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#行数为1的二维数组，即二维数组形式的行向量，报错</span></span>
<span id="cb13-11"></span>
<span id="cb13-12">u<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.array([[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>]])</span>
<span id="cb13-13">v<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.array([[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">4</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">7</span>]])</span>
<span id="cb13-14"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(np.dot(u,v)) <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#列数为1的二维数组，即二维数组形式的行向量，报错</span></span>
<span id="cb13-15"></span>
<span id="cb13-16">u<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.array([[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>]]).T</span>
<span id="cb13-17">v<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.array([[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">4</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">7</span>]]).T</span>
<span id="cb13-18"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(np.dot(u,v)) <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#列数为1的二维数组，即二维数组形式的列向量，报错</span></span></code></pre></div>
</div>
<p>二维数组形式的向量怎么进行内积运算呢？我们知道二维数组表示下得向量的本质上是矩阵，只不过是行数或列数为1的特殊矩阵。若将这种表示方法下的向量作为传入内积运算函数dot的参数，就需要依据矩阵的乘法法则来计算。</p>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb14" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1">u<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.array([[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>]])</span>
<span id="cb14-2">v<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.array([[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">4</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">7</span>]]).T</span>
<span id="cb14-3"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(np.dot(u,v)) <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#二维乘二维，结果还是二维</span></span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[37]]</code></pre>
</div>
</div>
<p>向量的外积运算：这里只讨论在二维平面和三维空间中的运算情况。</p>
<p>在二维平面中，与内积类似，外积也有一种表达式：u*v= |u||v|sinθ。在二维平面中，向量的外积表示两个向量张成的平行四边形的“面积”。当然，这个面积要打上引号，因为若两个向量的夹角大于180度，那么向量外积运算所得到的结果为负。</p>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb16" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1">u<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.array([<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>])</span>
<span id="cb16-2">v<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.array([<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">4</span>])</span>
<span id="cb16-3"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(np.cross(u,v)) <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#一维乘一维，结果还是一维</span></span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>7</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>/tmp/ipykernel_353/2827165229.py:3: DeprecationWarning: Arrays of 2-dimensional vectors are deprecated. Use arrays of 3-dimensional vectors instead. (deprecated in NumPy 2.0)
  print(np.cross(u,v)) #一维乘一维，结果还是一维</code></pre>
</div>
</div>
<p>而在三维空间中，外积要复杂一点，其计算所得到的结果是一个向量而不是一个数值。其最终得到的结果向量也是有明确的物理含义的，即表示u和v两个向量张成平面的法向量。</p>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb19" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1">x<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.array([<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">9</span>])</span>
<span id="cb19-2">y<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.array([<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">4</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">12</span>])</span>
<span id="cb19-3"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(np.cross(x,y))</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[  0 -27   9]</code></pre>
</div>
</div>
</section>
<section id="向量先数乘后叠加向量的线性组合" class="level3">
<h3 class="anchored" data-anchor-id="向量先数乘后叠加向量的线性组合">向量先数乘后叠加：向量的线性组合</h3>
<p>基于向量加法和数量乘法这两类基本运算，将其进行组合应用。针对向量u和v，先求出标量c和向量u的数量积，再求出标量d和向量v的数量积，最后再将二者进行叠加，就得到向量u和v的线性组合cu+dv，这里的标量c和d可以取任意值，包括0。</p>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb21" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1">u<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.array([[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>]]).T</span>
<span id="cb21-2">v<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.array([[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">4</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">6</span>]]).T</span>
<span id="cb21-3">w<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.array([[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">7</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">8</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">9</span>]]).T</span>
<span id="cb21-4"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span>u <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">4</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span>v <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span>w)</span>
<span id="cb21-5"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(u)</span>
<span id="cb21-6">u.shape</span>
<span id="cb21-7">np.array([[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>]]).shape</span>
<span id="cb21-8"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(np.dot(u.T,v.T)) <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#报错，带有第二个维度无法进行向量内积</span></span></code></pre></div>
</div>
<p>进一步思考：我们知道，两个向量相加，在几何上就是将两个向量首尾依次连接，所得到的结果向量就是连接最初的起点和最终的终点的有向连线。我们假定有3个非零的三维列向量u、v和w，讨论以下几种不同的线性组合情况：</p>
<ul>
<li><p>第一种情况：cu的所有线性组合构成的图像</p>
<p>由于标量c可以取0，因而cu的所有线性组合构成的图像可以表示为三维空间中一条穿过原点(0,0,0)的直线，包括原点本身。</p></li>
<li><p>第二种情况：cu+dv的所有线性组合构成的图像</p>
<ol type="1">
<li><p>当向量u和向量v不在一条直线上时，即u和v不共线</p>
<p><code>cu+dv</code>的所有线性组合构成的图像可以表示为三维空间中的一个通过原点(0,0,0)的二维平面。</p></li>
<li><p>当向量u和向量v处在一条直线上时</p>
<p>则<code>cu+dv</code>的所有线性组合构成的图像可以表示为三维空间中一条穿过原点(0,0,0)的直线，包括原点本身。</p></li>
</ol></li>
<li><p>第三种情况：cu+dv+ew的所有线性组合构成的图像</p>
<ol type="1">
<li><p>当向量u、v、w不在一个平面上时，cu+dv+ew的所有线性组合构成的图像是整个三维空间。</p></li>
<li><p>当向量u、v、w处在一个平面上时，cu+dv+ew的所有线性组合构成的图像是三维空间中的一个通过原点(0,0,0)的二维平面。</p></li>
<li><p>当向量u、v、w处在一条直线上时，cu+dv+ew的所有线性组合构成的图像是三维空间中一条穿过原点(0,0,0)的直线，包括原点本身。</p></li>
</ol></li>
</ul>
<p>我们发现，在讨论上述线性组合的多种不同情况时，均反复提到了共线、共面的概念。这些特殊的性质会对一组向量线性组合所得到的结果向量在空间中的位置产生重要影响，它们构成了线性代数中非常重要的概念。后面我们也将使用更加专业的词汇对其进行描述和介绍，即线性相关和线性无关。</p>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>
</section>

 ]]></description>
  <category>biostatistics</category>
  <category>linear algebra</category>
  <category>python</category>
  <guid>https://leslie-lu.github.io/blog/2020/03/11/index.html</guid>
  <pubDate>Wed, 11 Mar 2020 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202409021427240.webp" medium="image" type="image/webp"/>
</item>
<item>
  <title>线性代数之向量</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2020/03/10/index.html</link>
  <description><![CDATA[ 




<p>空间是贯穿整个线性代数的主干脉络和核心概念。下面我们学习利用向量这个工具对空间进行定量描述。</p>
<section id="关于向量" class="level3">
<h3 class="anchored" data-anchor-id="关于向量">关于向量</h3>
<p>直观地说，把一组数字排列成一行或一列，就称为向量。它可以作为对空间进行描述的有力工具。</p>
<p>如一个简单的二维向量[4,5]⊤，这个向量有两个成分：第一个成分是数字4，第二个成分是数字5。其可以理解为二维平面中x坐标为4，y坐标为5的一个点，也可以理解为以平面中的原点(0,0)为起点，(4,5)为重点的一条有向线段，这就是二维向量的空间表示。一个向量中成分的个数就是该向量的维数。</p>
<p>不过，向量也不局限于用来直接描述空间中的点坐标和有向线段，也可以凭借基础的数据表示功能，成为一种描述事物属性的便捷工具。</p>
<p>如你的考试成绩为：语文85分，数学92分，英语89分。由于这三门课具有不同科目属性，因此，可以使用一个三维向量来对其进行表示，即score=[85,92,89]⊤。此时不仅仅可以把向量score看作是一个盛放数据的容器，似乎也可以利用它讲科目考试成绩和空间建立起某种关联。</p>
<p>又如，在自然语言处理中，也少不了向量这个重要的工具。程序在进行文本阅读时，首先会对文本材料进行分词处理，然后使用向量对词汇进行表示。这是因为向量很适合将对象的属性和特征对应到高维空间中进行定量表达，同时在此基础上进行进一步的后续处理，如判断词汇之间的相似性等。</p>
<p>我们陆续接触到一些数据处理的基本方法：如投影、降维等，这些方法都是在向量描述的基础上实现的。</p>
</section>
<section id="列向量" class="level3">
<h3 class="anchored" data-anchor-id="列向量">列向量</h3>
<p>向量对应地就拥有两种表达方式：若元素是纵向排列的，就称为列向量；若元素是横向排列的，就成为行向量。在没有特殊说明的情况下，一般都默认为列向量。为什么会偏爱列向量呢？主要是为了方便后续的向量坐标变换、空间之间的映射等计算过程的处理。</p>
<p>将一个矩阵A所表示的映射作用于某个向量x上时，习惯上将其写成矩阵乘以向量的表达形式，即Ax。这种写法的数据表示基础就是：向量x必须是一个列向量。</p>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>
</section>

 ]]></description>
  <category>biostatistics</category>
  <category>linear algebra</category>
  <guid>https://leslie-lu.github.io/blog/2020/03/10/index.html</guid>
  <pubDate>Tue, 10 Mar 2020 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202409021427240.webp" medium="image" type="image/webp"/>
</item>
<item>
  <title>协方差分析</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2020/02/23/index.html</link>
  <description><![CDATA[ 




<p>医学试验设计一个很重要的目的就是为了排除非处理因素的干扰影响，使试验误差的估计降到最低限度，从而可以准确地获得处理因素的试验效应。但在某些实际问题中，有些因素在目前还不能控制或难以控制。如在动物饲养试验中，各组动物所增加的平均体重不仅仅与各种饲料营养价值高低有关，还与各动物的进食量有关，甚至与各动物的初始体重等因素及其交互作用都有关系。如果直接进行方差分析，会因为混杂因素的影响而无法得出正确的结论。</p>
<p>协方差分析是将回归分析与方差分析结合起来使用的一种分析方法。在协方差分析中，先将定量的影响因素（即难以控制的混杂因素）看作自变量/协变量，建立因变量随自变量变化的回归方程，利用回归方程把因变量的变化中受不易控制的定量因素的影响扣除掉，从而能够较合理地比较定性的影响因素处在不同水平下，经回归分析手段修正以后的因变量的总体均数之间是否有显著性的差别，这就是协方差分析的基本思想。</p>
<p>协方差分析用于比较一个变量Y在一个或几个因素不同水平上的差异，但Y在受这些因素影响的同时，还受到另一个变量X的影响，且X变量的取值难以人为控制，不能作为方差分析中的一个因素处理。此时如果X与Y之间可以建立回归关系，则可以用协方差分析的方法排除X对Y的影响，然后再用方差分析的方法对各因素水平的差异进行统计推断。在协方差分析中，我们称Y为因变量，X为协变量，即在方差分析中用来校正因变量的数值型变量。</p>
<p>也许有人会问随机因素的影响也是不能人为控制的，为什么不能把X作为一种随机因素处理呢？</p>
<p>这里的差异主要在于作为随机因素处理时，虽然每一水平的影响是不能人为控制的，但我们至少可以得到几个属于同一水平的重复，因此可以把它们分别用另一因素的不同水平处理，最后在方差分析时，我们才能排除这一随机因素的影响，对另一因素的各水平进行比较。</p>
<p>例如，当我们考虑动物窝别对增重的影响时，一般可把它当作随机因素处理。一方面是由于它不易数量化，另一方面是同一窝一般有几只动物，可分别接受另一因素不同水平的处理。如果我们考虑试验开始时动物初始体重的影响，这时一般的方法是选初始体重相同的动物作为一组，分别接受另一因素的不同水平处理，此时用方差分析没有问题。但显然，这种方法往往是很困难的，一般需要很大的样本。若可供试验的动物样本很少，初始体重又有明显差异，无法选出体重相当的动物，那就只好认为初始体重X与最终体重Y有回归关系，采用协方差分析的方法排除初始体重的影响，再来比较其他因素如饲料种类、数量对增重的影响。协方差分析既利用了回归分析的基本方法，又用到了方差分析的基本方法，这就是协方差分析的基本思想。</p>
<p>消除初始体重影响的另一种方法是对最终体重与初始体重的差值进行统计分析，这种方法与协方差分析的生物学意义是不同的。对差值进行分析的生物学假设是初始体重对以后的体重增量没有任何影响，而协方差分析则是假设体重增量中包含初始体重的影响（不仅仅是初始体重对最终体重的影响），这种影响的大小与初始体重成正比，如果这一比值为1，协方差分析与对差值进行方差分析是相同的。但如果比值不为1，它们的结果将是不同的。也就是说，协方差分析假设使初始体重不同的因素在以后的生长过程中也会发挥作用，而对差值进行方差分析则是假设这些因素以后不再发挥作用，这两种生物学假设是有很大区别的。</p>
<p>在学习中需要注意统计学知识背后的研究假设。由于协方差分析包含了对协变量影响是否存在及其大小等一系列统计检验与估计，它显然比对差值进行分析等方法有更广泛的适用范围，因此除非有明显的证据说明对差值进行分析的生物学假设是正确的，一般情况下还是应采用协方差分析方法。</p>
<p>在医学研究中，很多情况下都需要借助协方差分析来排除非处理因素的干扰，从而准确地估计处理因素的试验效应。如，评价3种药物治疗高脂血症的效果，寻求各方面自然条件基本相同的受试者是很困难的，但是把患者的年龄、体重指数、用药前的血脂水平等作为协变量进行协方差分析，就简单很多。同样，比较几种不同营养奶粉对婴幼儿体重增长的作用差异，把研究对象的性别、年龄、基线体重等混杂因子作为协变量进行协方差分析，则是非常有效的统计分析方法。</p>
<p>和方差分析一样，协方差分析也属于参数分析，因变量Y应当满足以下假设条件：</p>
<ol type="1">
<li><p>在效应因子的每一个水平上，因变量Y服从正态分布，且方差相等；</p></li>
<li><p>在效应因子的每一个水平上，因变量Y和协变量X呈线性关系，且斜率相同。</p></li>
</ol>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>

 ]]></description>
  <category>biostatistics</category>
  <category>ancova</category>
  <guid>https://leslie-lu.github.io/blog/2020/02/23/index.html</guid>
  <pubDate>Sun, 23 Feb 2020 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408291336046.webp" medium="image" type="image/webp"/>
</item>
<item>
  <title>试验设计与方差分析（4）</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2020/02/22/index.html</link>
  <description><![CDATA[ 




<section id="重复测量设计" class="level3">
<h3 class="anchored" data-anchor-id="重复测量设计">重复测量设计</h3>
<p>重复测量是指对同一观察对象的同一观察指标在不同的时间点上进行多次测量，用于分析观察指标在不同时间上的变化规律。</p>
<p>这类测量资料在医学研究中比较常见，例如，药效分析中常分析给药后不同时间的疗效比较，由于同一受试对象在不同时点的观测值之间往往彼此不独立，存在某种程度的相关，因此不能满足常规统计方法所要求的独立性假定，使得其分析方法有别于一般的统计分析方法。</p>
<p>最常见的重复测量资料是前后测量设计，如高血压患者治疗前后的血压，其设计与配对设计t检验的试验表达完全相同，但却是两种不同类型的设计，其区别在于：</p>
<ol type="1">
<li><p>配对设计中同一对子的两个试验单位可以随机分配处理，两个试验单位同期观察试验结果，可以比较处理组间差异，而前后测量设计不能同期观察试验结果；</p></li>
<li><p>配对t检验要求同一对子的两个试验单位的观察结果分别与差值相互独立，差值服从正态分布，而前后测量设计前后两次测量的结果通常与差值不独立；</p></li>
<li><p>配对设计用平均差值推断处理作用，而前后测量设计除了分析平均差值外，还可以进行相关回归分析。</p></li>
</ol>
<p>重复测量设计大体有两类，一类是对每个人在同一时间不同因子组合间测量，另外一类是对每个人在不同时间点上重复。前者常见于裂区设计，而后者常见于经典试验设计，即包括前测、处理一次或几次后测的情况，后者比前者要多见。不论沿裂区方向还是沿时间点方向重复，个体内因子无一例外的都是重复测量因子。</p>
<p>重复测量设计的特点是一定有个体内因子，但不一定有个体间因子，后者是不同处理组合或不同个体组，而且即使有不同组群（如男性和女性），但人人都经历重复测量，而不是一组接受重复测量，另一组不接受。</p>
<p>具有重复测量的设计，即在给予某种处理后，在几个不同的时间点上从同一个受试对象身上重复获得指标的观测值，有时是从同一个个体的不同部位上重复获得指标的观测值。由于这种设计符合许多医学试验本身的特点，故在医学科研中应用的频率相当高。</p>
<p>如果试验中共有k个试验因素，其中只有m个因素与重复测量有关，则称为具有m个重复测量的k因素设计。重复测量资料来源于同一受试对象的某一观测值的多次重复测量，常见的重复测量数据的基本格式：N个观测个体，g个处理组，X为观测指标，p为重复测量次数。</p>
<p>在对重复测量资料进行方差分析时，除了要求样本是随机的，在处理的同一水平上观测是独立的，及每一水平的测定值都来自正态总体外，特别强调协方差的复合对称性或球形性。因此，在进行重复测量资料的方差分析前，应先对资料的协方差阵进行球形性检验。若满足球形性要求，则直接进行方差分析；若不满足球形性要求，则需对与时间有关的F统计量分子、分母的自由度进行校正，以减少犯I类错误的概率，或直接进行多变量方差分析。</p>
<p>对重复测量试验数据的方差分析，需考虑两个因素的影响：一个因素是处理分组，可通过施加干预和随机分组来实现；另一个因素是测量时间，由研究者根据专业知识和要求确定。因此重复测量资料的变异可分解为处理因素、时间因素、处理和时间的交互作用、受试对象间的随机误差和重复测量的随机误差等5部分。</p>
<p>重复测量设计的优点：每一个体作为自身的对照，克服了个体间的变异，分析时可更好地集中于处理效应，且被试者自身差异的问题不再存在，即减少了一个差异来源；重复测量设计的每一个体作为自身的对照，研究所需的个体相对较少，因此更加经济。</p>
<p>重复测量设计的缺点：滞留效应，前面的处理效应有可能滞留到下一次的处理；潜隐效应，前面的处理效应有可能激活原本以前不活跃的效应；学习效应，由于是逐步熟悉试验，因此研究对象的反应能力有可能逐步得到提高。</p>
<p>对于重复测量资料的分析处理，我们应用较多的是单变量方差分析的一般线性模型方法。在R数据格式中，重复测量资料同一观察单位在各测量点的测量值用一组变量来表示，计算时将这一组变量当作一个整体作为反应变量来处理。</p>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>
</section>

 ]]></description>
  <category>biostatistics</category>
  <category>anova</category>
  <guid>https://leslie-lu.github.io/blog/2020/02/22/index.html</guid>
  <pubDate>Sat, 22 Feb 2020 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408291336046.webp" medium="image" type="image/webp"/>
</item>
<item>
  <title>试验设计与方差分析（3）</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2020/02/20/index.html</link>
  <description><![CDATA[ 




<section id="正交设计" class="level3">
<h3 class="anchored" data-anchor-id="正交设计">正交设计</h3>
<p>析因设计的缺点是当因素个数较多时（3个因素以上），所需试验单位数、处理组数、试验次数和方差分析的计算量会剧增。减少多因素试验次数的有效方法是采用正交试验设计。</p>
<p>当析因设计要求的试验次数太多时，一个非常自然的想法就是从析因设计的全部水平组合中选择一部分有代表性的水平组合进行试验，因此就出现了分式析因设计。但是对于试验设计知识较少的实际工作者而言，选择适当的分式析因设计还是比较困难的，而正交试验设计是研究多因素多水平的又一种试验设计方法。</p>
<p>它是根据正交性从全部的试验组合中挑选出部分有代表性的水平组合进行试验，这些有代表性的水平组合具备均匀分散、齐整可比的特点。正交试验设计是分式析因设计的主要方法，高效、快速、经济。日本著名统计学家田口玄一将正交试验选择的水平组合列成表格，称为正交表。</p>
<p>例如做一个3因素3水平的试验，按全面试验要求，需进行3<em>3</em>3=27种水平组合的试验，且尚未考虑每一组合的重复数，而正交试验设计可以大大减少工作量。</p>
<p>正交设计在医学研究中的用途相当广泛，在具体的操作上，也比析因设计简单，可寻找疗效好的药物配方、医疗仪器多个参数的优化组合、医疗产品的生成工艺、生物体的培养条件等。</p>
<p>假定在一个农业试验中要考察3个小麦品种、3种不同的肥料和3种播种方式对小麦产量的影响，并假定有9个地力基本相同的试验小区。在这个问题中，有3个可能影响小麦产量的因子：品种、肥料和播种方式，每个因子有3个水平，如果要做完全试验，就需要3<em>3</em>3=27个小区，而实际上总共只有9个小区，显然，完全试验在当前的情况下行不通。</p>
<p>因此我们可退一步考虑，按照上述正交设计的想法，设计要求品种、肥料和播种方式中的任意两个的不同水平的搭配都出现一次，满足这种性质的试验设计就是正交试验。</p>
<p>下面给出正交设计的一般性陈述：考虑设计一个试验，安排m个因子，做n次试验，若它满足以下两个条件，则其为正交试验：</p>
<ol type="1">
<li><p>每一因子的不同水平在试验中出现相同的次数（均衡性）；</p></li>
<li><p>任意两因子的不同水平组合在试验中出现相同的次数（正交性）。</p></li>
</ol>
<p>就定义来说，等重复的完全试验显然满足上述两个条件，因此当然也是正交试验设计。但由于其要求的试验次数太多，所以实际上很难实施。我们通常所说的正交试验设计，是指既满足上述两条件，同时试验次数n又远远小于N的设计。</p>
<p>正交试验设计的方案可以用一张表来表示，这张表就被称为正交设计表。一般来说，正交设计表的第1行为表头，标明每列所代表的因子，最左一列标明试验的序号，由1到n。注意：试验的序号并不表示试验的时间先后顺序，先后顺序要按照随机化原则来安排。表中每列的数字代表相应因子的水平序号，每行的数字代表在相应试验中各因子的水平序号，有：</p>
<ol type="1">
<li><p>每列中不同数字出现的次数相同（试验的均衡性）；</p></li>
<li><p>每两列中不同的数字组合出现的次数相同（试验的正交性）。</p></li>
</ol>
<p>假定因子对响应变量的影响无交互效应（许多实际情况正是这样），正交试验的优点是在很少的试验次数（与全面试验相比）中，所得数据可以简便而有效地对因子效应进行参数估计和方差分析。</p>
<p>其方法可一般地归纳如下：</p>
<ul>
<li><p>总均值的估计=试验数据的总平均值</p></li>
<li><p>某因子的某个主效应的估计=该因子的该主效应所出现的试验数据的平均值-总平均值</p></li>
<li><p>总平方和=（试验数据-总平均值）的平方和，自由度=n-1</p></li>
<li><p>某因子的主效应平方和=重复数*参数估计的平方和，自由度=水平数-1</p></li>
<li><p>残差平方和=总平方和-因子效应平方和的和，自由度=总平方和-因子效应自由度的和</p></li>
</ul>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>
</section>

 ]]></description>
  <category>biostatistics</category>
  <category>anova</category>
  <guid>https://leslie-lu.github.io/blog/2020/02/20/index.html</guid>
  <pubDate>Thu, 20 Feb 2020 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408291336046.webp" medium="image" type="image/webp"/>
</item>
<item>
  <title>试验设计与方差分析（2）</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2020/02/18/index.html</link>
  <description><![CDATA[ 




<section id="拉丁方设计" class="level3">
<h3 class="anchored" data-anchor-id="拉丁方设计">拉丁方设计</h3>
<p>完全随机设计只涉及一个处理因素，随机区组设计涉及一个处理因素、一个区组因素/配伍因素。若实验研究涉及一个处理因素和两个控制因素，每个因素的类别数或水平数相等，此时可采用拉丁方设计来安排试验，将两个控制因素分别安排在拉丁方设计的行和列上。</p>
<p>将k个不同符号排成k行k列，使得每一个符号在每一行、每一列都只出现一次的方阵，叫做k*k拉丁方。</p>
<p>拉丁方设计就是将处理从纵横两个方向排列为区组/重复，使每个处理在每一行和每一列中出现的次数相等（通常为1次），即在行和列两个方向都进行局部控制，所以它是比随机区组多一个方向局部控制的随机排列设计，因而具有较高精确性。</p>
<p>拉丁方设计的特点是处理数、重复数、行数、列数都相等，即处理数=行区组数=列区组数=重复次数，它的每一行和每一列都是一个区组或一次重复，而每一个处理在每一行或每一列都只出现1次</p>
<p>拉丁方试验设计的步骤：</p>
<ol type="1">
<li><p>选择标准方：标准方是指代表处理因素水平的字母。在进行拉丁方设计时，首先要根据试验处理水平数k从标准方表中选定一个k*k的标准方，随后要对选定的标准方的行、列和处理进行随机化排列；</p></li>
<li><p>列随机</p></li>
<li><p>行随机</p></li>
<li><p>处理随机</p></li>
</ol>
<p>拉丁方设计的特点是纵横两个方向都设了区组，从而可在两个方向上对土壤等差异（指田间试验时）进行局部控制。试验有k个处理，便有k*k个观测值。进行方差分析时，从总变异方差中除了分解出处理间方差和误差项方差外，还可以分解出纵横两个区组的方差，这样可使误差项方差进一步减小，所以拉丁方试验的精确度比随机区组试验更高。</p>
<p>拉丁方设计的优点是：精确度高；缺点是：由于重复数与处理数必须相等，使得两者之间相互制约，缺乏伸缩性。因此采用拉丁方设计时试验的处理数不能太多，一般以4～10个为宜。</p>
</section>
<section id="析因设计" class="level3">
<h3 class="anchored" data-anchor-id="析因设计">析因设计</h3>
<p>单因素方差分析只涉及一个处理因素，该因素至少有两个水平，只是根据试验对象的属性和控制试验误差的需要，采用的试验设计方法有所不同。如比较注射4种不同剂量雌激素对大白鼠子宫重量的影响，处理因素是注射不同剂量的雌激素，有4个水平。完全随机设计是将n只白鼠随机分4组，随机区组设计是将n只白鼠按出生体重相近的原则，4只一组配成区组后，每个区组内随机分配4个处理水平，拉丁方设计则是在随机区组设计的基础上增加了一个列区组，如白鼠有4个种系（行区组），每个种系的4只白鼠按体重分成4个级别（列区组）。可以看出，完全随机设计、随机区组设计和拉丁方设计的处理因素没有变化，都是比较注射4种不同剂量雌激素带来的差别，只是改变了设计的方法，在同样的试验条件下，通过改进试验设计方法可以大大提高试验的效率，如上述试验，白鼠按体重配成区组后再施加处理（随机区组设计），试验的误差均方通常小于完全随机设计。</p>
<p>而上述介绍的各种试验设计方法，严格地说，它们仅适用于只有1个处理因素的试验问题之中，其他因素都属于区组因素，即与处理因素无交互作用。若试验所涉及的处理因素的个数为2或以上，当各因素在试验中所处的地位基本平等，且因素之间存在1级（即2因素之间）、2级（即3因素之间）乃至更复杂的交互作用时，则需选用析因设计。</p>
<p>在评价药物疗效时，除需知道A药和B药各剂量的疗效外（主效应），还需知道两种药同时使用的协同疗效，析因设计及其相应的方差分析用于分析药物的单独效应、主效应和交互效应。</p>
<p>主效应：某因素各水平的平均效应；单独效应：在每个B水平，A的效应；或在每个A水平，B的效应；交互效应：某因素各水平的单独效应随另一因素水平变化而变化，则称两因素之间存在交互效应，包括协同、拮抗作用。</p>
<p>析因设计有交互作用的二因子方差分析将总偏差平方和做如下分解：</p>
<ul>
<li><p>误差偏差平方和：反映随机误差对试验结果的影响；</p></li>
<li><p>因子A引起的偏差平方和：除含有误差波动外，反映因子A对试验结果的影响；</p></li>
<li><p>因子B引起的偏差平方和：除含有误差波动外，反映因子B对试验结果的影响；</p></li>
<li><p>因子A与B的交互作用的偏差平方和：反映因子A与B的交互作用对试验结果的影响。</p></li>
</ul>
<p>如果不存在交互效应，则只需考虑各因素的主效应；在方差分析中，如果存在交互效应，解释结果时，要逐一分析各因素的单独效应，找出最优搭配。在两因素析因设计时，只需考虑一阶交互效应；3个因素及以上时，除一阶交互效应外，还需考虑二阶、三阶等高阶交互效应，解释将更复杂。</p>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>
</section>

 ]]></description>
  <category>biostatistics</category>
  <category>anova</category>
  <guid>https://leslie-lu.github.io/blog/2020/02/18/index.html</guid>
  <pubDate>Tue, 18 Feb 2020 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408291336046.webp" medium="image" type="image/webp"/>
</item>
<item>
  <title>试验设计与方差分析（1）</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2020/02/17/index.html</link>
  <description><![CDATA[ 




<section id="完全随机设计" class="level3">
<h3 class="anchored" data-anchor-id="完全随机设计">完全随机设计</h3>
<p>完全随机设计采用完全随机化的分组方法，将全部试验对象分配到k个处理组，各组分别接受不同的处理，试验结束后比较各组均数之间的差别有无统计学意义，推断处理因素的效应。</p>
<p>在方差分析中，常称上述的处理因素为因子，用A、B、C等表示因子在试验中所处的不同情况或状态称为水平。</p>
<p>方差分析解决问题的思路是：从所有观测值的总变异（总方差）中分析出系统误差和随机误差，并用数量表示，在一定意义下比较系统误差和随机误差，若两者的差别不大，说明试验条件的变化（因素水平的不同）对试验结果影响不大；若两者相差较大，且系统误差大得多，说明系统条件变化引出的误差不可忽视。</p>
</section>
<section id="随机区组设计" class="level3">
<h3 class="anchored" data-anchor-id="随机区组设计">随机区组设计</h3>
<p>随机区组设计是根据局部控制和随机排列的原理进行的：将研究的对象按照不同的性质划分为等于重复次数的区组，例如将试验土地按土壤肥力程度等不同的性质划分为等于重复次数的区组，使区组内环境差异最小，而区组间环境允许存在差异，每个区组即为一次完整的重复，区组内的各处理都独立地随机排列，这是随机排列设计中最常用最基本的设计。</p>
<p>随机区组设计的优点：富于伸缩性，单因素、复因素以及综合试验等都可应用；能提供无偏的误差估计，在大区域试验中能有效地降低非处理因素等试验条件的单向差异，降低误差；对试验地的地形要求不严，只对每个区组内的非处理因素等试验条件要求尽量一致，因此不同区组可分散设置在不同地段上。</p>
<p>随机区组设计的缺点：这种设计方法不允许处理数太多，处理数过多，区组必然增大，局部控制的效率会降低，所以处理数一般不超过20个，最好在10个左右。</p>
<p>随机区组设计考虑了个体差异的影响，可分析处理因素和个体差异对试验效应的影响，所以又称为两因素实验设计，比完全随机设计的检验效率高。</p>
<p>该设计是将受试对象先按配比条件配成配伍组（如动物试验时，可按同窝别、同性别、体重相近等进行配伍），每个配伍组有3个或以上的受试对象，再按随机化原则分别将各配伍组中的受试对象分配到各个处理组。</p>
<p>在进行单因素随机区组试验结果的统计分析时，可将处理看作A因素，区组看作B因素，剩余部分则为试验误差。总平方和=区组间平方和+处理间平方和+试验误差平方和，总自由度=区组自由度+处理自由度+误差自由度。</p>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>
</section>

 ]]></description>
  <category>biostatistics</category>
  <category>anova</category>
  <guid>https://leslie-lu.github.io/blog/2020/02/17/index.html</guid>
  <pubDate>Mon, 17 Feb 2020 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408291336046.webp" medium="image" type="image/webp"/>
</item>
<item>
  <title>方差分析</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2020/02/15/index.html</link>
  <description><![CDATA[ 




<section id="方差分析" class="level3">
<h3 class="anchored" data-anchor-id="方差分析">方差分析</h3>
<p>t检验和u检验不适用于多个样本均数的比较，而用方差分析比较多个样本均数，可以有效地控制I类错误。</p>
<p>方差分析（analysis of variance，ANOVA）由英国统计学家R.A.Fisher首先提出，以F命名其统计量，故方差分析又称F检验。</p>
<p>方差分析的基本思想是根据研究的目的和设计类型，将总变异的离均差平方和SS及其自由度v分别分解成相应的若干部分，然后求各相应部分的变异（数理统计证明，总的离均差平方和等于各部分离均差平方和之和）；再用各部分的变异与组内（或误差）变异进行比较，得出统计量F值；最后根据F值的大小确定p值，作出统计推断。</p>
<p>方差分析的用途很广，包括两个或多个样本均数间的比较，分析两个或多个因素间的交互作用，回归方程的线性假设检验，多元线性回归分析中偏回归系数的假设检验，两样本的方差齐性检验等。</p>
<p>方差分析的应用条件为：各样本需是相互独立的随机样本；各样本来自正态分布总体；各总体方差相等，即方差齐性。</p>
</section>
<section id="方差分析基本术语" class="level3">
<h3 class="anchored" data-anchor-id="方差分析基本术语">方差分析基本术语</h3>
<p>实验设计和方差分析都有自己相应的语言。</p>
<p>以研究某药物对某癌细胞株增殖影响的研究为例，现有两种药物：新研究药物（Treatdrug）和对照组药物（Controldrug）。</p>
<p>我们提取培养10个某癌细胞株作为研究对象，随机分配一半癌细胞株接受为期96h的Treatdrug治疗，另一半接受为期96h的Controldrug治疗。研究结束时，对两组细胞株的细胞抑制率进行评估。</p>
<p>在这个实验设计中，治疗方案是两水平（Treatdrug和Controldrug）的组间因子，之所以称作组间因子是因为每个患者都仅被分配到一个组别中，没有患者同时接受Treatdrug和Controldrug。</p>
<p>细胞抑制率是因变量，治疗方案是自变量。由于在每种治疗方案下观测数相等，因此这种设计也称为均衡设计；若观测数不同，则称为非均衡设计。</p>
<p>因为仅有一个类别型变量，这种设计又称为单因子方差分析或进一步称为单因子组间方差分析。</p>
<p>方差分析主要是通过F检验来进行效果评测，若治疗方案的F检验显著，则说明96h后两种药物的细胞抑制率均值不同。</p>
<p>假设只对Treatdrug的效果感兴趣，则需要将10个癌细胞株都放在Treatdrug组中，然后在治疗24h和96h后分别评估疗效。此时，时间是两水平（24h和96h）的组内因子，因为每个癌细胞株在时间的所有水平下都进行了测量，因此这种设计称为单因子组内方差分析；又由于每个癌细胞株都不止一次被测量，也称作重复测量方差分析。若时间的F检验显著，则说明细胞抑制率在24h和96h间发生了改变。</p>
<p>现假设对治疗方案差异和它随时间的改变都感兴趣，则可以将两个设计结合起来：随机分配一半癌细胞株到Treatdrug组，另一半到Controldrug组，在24h和96h分别评估它们的细胞抑制率。治疗方案和时间都作为因子时，既可以分析治疗方案的影响和时间的影响，也可以分析治疗方案和时间的交互作用。前两个为主效应，交互部分为交互效应。在这种情况下，需要进行3次F检验，治疗方案因素1次，时间因素1次，两者的交互因素1次。若治疗方案显著，说明Treatdrug和Controldrug对癌细胞的抑制效果不同；若时间显著，表明细胞抑制率在24h和96h间发生了改变；若两种因素交互效应显著，说明两种药物随着时间变化对癌细胞的一直效果不同（即细胞抑制率从24h到96h的改变程度在Treatdrug和Controldrug之间是不同的）。</p>
<p>当设计中包含两个甚至更多因子时，便是多因子方差分析设计。两个因子时称为双因子方差分析，三因子时称为三因子方差分析。若因子设计包括组内因子和组间因子，又称为混合模型方差分析。</p>
<p>这里，即使不同的癌细胞株被随机分配到不同的治疗方案中，但在研究开始时两组癌细胞株的增殖速度可能不同，治疗后的差异可能是最初的增殖速度不同导致的，而不是实验方案的影响。增殖速度也可以解释因变量的组间差异，因此它常被称为混杂因素。如果我们在评测治疗方案类型的影响前，对组建的统计学差异进行统计性调整，将初始增殖速度作为协变量，这样的设计称为协方差分析。</p>
<p>当因变量不止一个时，该设计被称为多元方差分析，若还存在协变量，则称为多元协方差分析。</p>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>
</section>

 ]]></description>
  <category>biostatistics</category>
  <category>anova</category>
  <guid>https://leslie-lu.github.io/blog/2020/02/15/index.html</guid>
  <pubDate>Sat, 15 Feb 2020 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408291336046.webp" medium="image" type="image/webp"/>
</item>
<item>
  <title>R语言数据处理分析实例</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2020/02/06/index.html</link>
  <description><![CDATA[ 




<section id="前言" class="level3">
<h3 class="anchored" data-anchor-id="前言">前言</h3>
<p>R是一种块状结构程序语言，“块”由大括号划分，当“块”只包含一条语句时大括号可以省略。程序语句由换行符或分号分隔。和许多脚本语言一样，R语言不需要“声明”变量。</p>
<p>接下来我们一起来处理分析一个简单的数据任务。</p>
</section>
<section id="实例" class="level3">
<h3 class="anchored" data-anchor-id="实例">实例</h3>
<p>一组学生参加了数学、科学和英语三科考试。为了给所有学生确定一个综合的成绩衡量指标，需要将这些科目的成绩组合起来，将排名在前20%的学生评定为A，接下来20%的学生评定为B，依此类推，最后，按字母顺序对学生进行排序。请试处理分析。</p>
<p>如下，我们首先创建原始数据框：</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-1_8455315f80cbbf433a0a3aa2fbfb1dec">
<div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1">studentname<span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">=</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">c</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"John Davis"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Angela Williams"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Bullwinkle Moose"</span>, </span>
<span id="cb1-2">               <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"David Jones"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Janice Markhammer"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Cheryl Cushing"</span>, </span>
<span id="cb1-3">               <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Reuven Ytzrhak"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Greg Knox"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Joel England"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Mary Rayburn"</span>)</span>
<span id="cb1-4">math<span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">=</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">c</span>(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">502</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">600</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">412</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">358</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">495</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">512</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">410</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">625</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">573</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">522</span>)</span>
<span id="cb1-5">science<span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">=</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">c</span>(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">95</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">99</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">80</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">82</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">75</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">85</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">80</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">95</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">89</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">86</span>)</span>
<span id="cb1-6">English<span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">=</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">c</span>(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">25</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">22</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">18</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">15</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">20</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">28</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">15</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">30</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">27</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">18</span>)</span>
<span id="cb1-7">scoredata<span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">=</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">data.frame</span>(studentname, math, science, English, <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">stringsAsFactors=</span><span class="cn" style="color: #8f5902;
background-color: null;
font-style: inherit;">FALSE</span>)</span>
<span id="cb1-8">scoredata</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>         studentname math science English
1         John Davis  502      95      25
2    Angela Williams  600      99      22
3   Bullwinkle Moose  412      80      18
4        David Jones  358      82      15
5  Janice Markhammer  495      75      20
6     Cheryl Cushing  512      85      28
7     Reuven Ytzrhak  410      80      15
8          Greg Knox  625      95      30
9       Joel England  573      89      27
10      Mary Rayburn  522      86      18</code></pre>
</div>
</div>
<p>观察此数据集，马上可以发现一些明显的挑战：首先，三科考试成绩是无法比较的。由于它们的均值和标准差相差很大，对它们求三科的平均成绩是没有意义的。因此，在组合这些考试成绩之前，必须将其转换为可比较的成绩。</p>
<p>因而，我们做如下处理，将三科成绩进行标准化，这样每科考试成绩都是用单位标准差来表示，而非原始的分值尺度表示：</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-2_ae29a5658cb802de17dfbbf2c1b7e24f">
<div class="sourceCode cell-code" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1">z<span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">=</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">scale</span>(scoredata[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">:</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">4</span>])</span>
<span id="cb3-2">z</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>             math     science     English
 [1,]  0.01269128  1.07806562  0.58685145
 [2,]  1.14336936  1.59143020  0.03667822
 [3,] -1.02568654 -0.84705156 -0.69688609
 [4,] -1.64871324 -0.59036927 -1.24705932
 [5,] -0.06807144 -1.48875728 -0.33010394
 [6,]  0.12806660 -0.20534583  1.13702468
 [7,] -1.04876160 -0.84705156 -1.24705932
 [8,]  1.43180765  1.07806562  1.50380683
 [9,]  0.83185601  0.30801875  0.95363360
[10,]  0.24344191 -0.07700469 -0.69688609
attr(,"scaled:center")
   math science English 
  500.9    86.6    21.8 
attr(,"scaled:scale")
     math   science   English 
86.673654  7.791734  5.452828 </code></pre>
</div>
</div>
<p>scale函数为数据对象按列进行中心化（center=TRUE）或标准化（center=TRUE, scale=TRUE），默认情况下，函数scale对矩阵或数据框的指定列进行均值为0、标准差为1的标准化，给出各科成绩标准化后的结果以及各科成绩的均值和标准差。</p>
<p>然后，我们通过mean函数来计算各行的均值以获得三科成绩的综合评价得分，并使用cbind函数将其添加到学生成绩的原始数据框中：</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-3_8d32f6078d17efc5bfb6ce2adc76be0c">
<div class="sourceCode cell-code" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1">Score<span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">=</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">apply</span>(z, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, mean)</span>
<span id="cb5-2">Score</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1]  0.5592028  0.9238259 -0.8565414 -1.1620473 -0.6289776  0.3532485
 [7] -1.0476242  1.3378934  0.6978361 -0.1768163</code></pre>
</div>
<div class="sourceCode cell-code" id="cb7" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1">scoredata2<span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">=</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">cbind</span>(scoredata, Score)</span>
<span id="cb7-2">scoredata2</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>         studentname math science English      Score
1         John Davis  502      95      25  0.5592028
2    Angela Williams  600      99      22  0.9238259
3   Bullwinkle Moose  412      80      18 -0.8565414
4        David Jones  358      82      15 -1.1620473
5  Janice Markhammer  495      75      20 -0.6289776
6     Cheryl Cushing  512      85      28  0.3532485
7     Reuven Ytzrhak  410      80      15 -1.0476242
8          Greg Knox  625      95      30  1.3378934
9       Joel England  573      89      27  0.6978361
10      Mary Rayburn  522      86      18 -0.1768163</code></pre>
</div>
</div>
<p>apply函数可将一个任意函数应用到矩阵、数组、数据框的任何维度上，在矩阵或数据框中，1表示行，2表示列。cbind函数进行列合并，增加列。</p>
<p>接下来，我们通过函数quantile给出三科成绩综合评价得分的百分位数，将学生的百分位数排名重编码为一个新的类别型成绩变量grade，如下：</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-4_6c0f2d74da3ade1adcb73be9d1483faa">
<div class="sourceCode cell-code" id="cb9" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1">y<span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">=</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">quantile</span>(Score, <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">c</span>(<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.8</span>,<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.6</span>,<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.4</span>,<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>))</span>
<span id="cb9-2">y</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>       80%        60%        40%        20% 
 0.7430341  0.4356302 -0.3576808 -0.8947579 </code></pre>
</div>
<div class="sourceCode cell-code" id="cb11" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1">scoredata2<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">$</span>grade[Score <span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;=</span>y[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>]]<span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"A"</span></span>
<span id="cb11-2">scoredata2<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">$</span>grade[Score <span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span> y[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>] <span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&amp;</span> Score <span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;=</span>y[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>]]<span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"B"</span></span>
<span id="cb11-3">scoredata2<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">$</span>grade[Score <span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span> y[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>] <span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&amp;</span> Score <span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;=</span>y[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>]]<span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"C"</span></span>
<span id="cb11-4">scoredata2<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">$</span>grade[Score <span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span> y[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>] <span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&amp;</span> Score <span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;=</span>y[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">4</span>]]<span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"D"</span></span>
<span id="cb11-5">scoredata2<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">$</span>grade[Score <span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span> y[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">4</span>]]<span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"E"</span></span>
<span id="cb11-6">scoredata2</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>         studentname math science English      Score grade
1         John Davis  502      95      25  0.5592028     B
2    Angela Williams  600      99      22  0.9238259     A
3   Bullwinkle Moose  412      80      18 -0.8565414     D
4        David Jones  358      82      15 -1.1620473     E
5  Janice Markhammer  495      75      20 -0.6289776     D
6     Cheryl Cushing  512      85      28  0.3532485     C
7     Reuven Ytzrhak  410      80      15 -1.0476242     E
8          Greg Knox  625      95      30  1.3378934     A
9       Joel England  573      89      27  0.6978361     B
10      Mary Rayburn  522      86      18 -0.1768163     C</code></pre>
</div>
</div>
<p>quantile函数求分位数，这里求Score数值型向量的20%、40%、60%和80%分位点。</p>
<p>接下来，我们使用strsplit函数以空格把学生姓名拆分为姓氏和名字：</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-5_accfb3a3618bdd484bac7630df246cd0">
<div class="sourceCode cell-code" id="cb13" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1">name<span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">=</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">strsplit</span>(scoredata2<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">$</span>studentname, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">" "</span>)</span>
<span id="cb13-2">name</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[1]]
[1] "John"  "Davis"

[[2]]
[1] "Angela"   "Williams"

[[3]]
[1] "Bullwinkle" "Moose"     

[[4]]
[1] "David" "Jones"

[[5]]
[1] "Janice"     "Markhammer"

[[6]]
[1] "Cheryl"  "Cushing"

[[7]]
[1] "Reuven"  "Ytzrhak"

[[8]]
[1] "Greg" "Knox"

[[9]]
[1] "Joel"    "England"

[[10]]
[1] "Mary"    "Rayburn"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb15" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1">lastname<span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">=</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">sapply</span>(name, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"["</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>)</span>
<span id="cb15-2">firstname<span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">=</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">sapply</span>(name, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"["</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>)</span>
<span id="cb15-3">scoredata3<span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">=</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">cbind</span>(firstname, lastname, scoredata2[<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>])</span>
<span id="cb15-4">scoredata3</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    firstname   lastname math science English      Score grade
1        John      Davis  502      95      25  0.5592028     B
2      Angela   Williams  600      99      22  0.9238259     A
3  Bullwinkle      Moose  412      80      18 -0.8565414     D
4       David      Jones  358      82      15 -1.1620473     E
5      Janice Markhammer  495      75      20 -0.6289776     D
6      Cheryl    Cushing  512      85      28  0.3532485     C
7      Reuven    Ytzrhak  410      80      15 -1.0476242     E
8        Greg       Knox  625      95      30  1.3378934     A
9        Joel    England  573      89      27  0.6978361     B
10       Mary    Rayburn  522      86      18 -0.1768163     C</code></pre>
</div>
</div>
<p>strsplit函数应用到一个字符串向量上会返回一个列表，使用sapply函数分别提取列表中每个成分的第一个元素和第二个元素，<code>[</code>是一个可以提取某个对象的一部分的函数，再使用cbind函数将它们添加到学生成绩的原始数据中。</p>
<p>最后，我们使用order函数依姓氏和名字对数据集进行排序，完成这个数据任务。</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-6_f5d4809378d27bdaf98f65c11a8c66b6">
<div class="sourceCode cell-code" id="cb17" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1">scoredata4<span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">=</span> scoredata3[<span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">order</span>(lastname, firstname),]</span>
<span id="cb17-2">scoredata4</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    firstname   lastname math science English      Score grade
6      Cheryl    Cushing  512      85      28  0.3532485     C
1        John      Davis  502      95      25  0.5592028     B
9        Joel    England  573      89      27  0.6978361     B
4       David      Jones  358      82      15 -1.1620473     E
8        Greg       Knox  625      95      30  1.3378934     A
5      Janice Markhammer  495      75      20 -0.6289776     D
3  Bullwinkle      Moose  412      80      18 -0.8565414     D
10       Mary    Rayburn  522      86      18 -0.1768163     C
2      Angela   Williams  600      99      22  0.9238259     A
7      Reuven    Ytzrhak  410      80      15 -1.0476242     E</code></pre>
</div>
</div>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>
</section>

 ]]></description>
  <category>r</category>
  <guid>https://leslie-lu.github.io/blog/2020/02/06/index.html</guid>
  <pubDate>Thu, 06 Feb 2020 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408231513804.webp" medium="image" type="image/webp"/>
</item>
<item>
  <title>计算机概论7–操作系统</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2020/02/05/index.html</link>
  <description><![CDATA[ 




<p>我们前面提到，在早期想要让计算机执行程序就得要参考一堆硬件功能函数，并且学习机器语言才能够编写程序，同时由于硬件与软件功能不一定一致，每次编写程序时都必须要重新改写，非常的麻烦。</p>
<p>如果能够将所有的硬件都驱动，并且提供一个软件的参考接口来给工程师开发软件，开发软件无疑会变得简单得多，而这就是操作系统（Operating System，OS）。</p>
<section id="操作系统内核kernel" class="level3">
<h3 class="anchored" data-anchor-id="操作系统内核kernel">操作系统内核（Kernel）</h3>
<p>操作系统其实也是一组程序，这组程序的重点在于管理计算机的所有活动以及驱动系统中的所有硬件。硬件的所有操作都必须要通过操作系统来实现，而这一功能的实现就是靠操作系统的内核完成。你的计算机能不能完成一些任务，都与内核有关。只有内核提供的功能，你的计算机系统才能帮你完成。举例来说，如果你的内核并不支持TCP/IP的网络协议，那么无论你配置什么样的网卡，这个内核都无法提供网络功能。</p>
<p>内核主要在管理硬件与提供相关的功能（读写硬盘、网络功能、CPU资源分配等），这些管理的操作都非常重要。如果用户能够直接使用到内核的话，一旦不小心将内核程序停止或破坏，将会导致整个系统的崩溃。因此内核程序放置到内存当中的区块是受保护的，并且启动后就一直常驻在内存之中。</p>
</section>
<section id="系统调用" class="level3">
<h3 class="anchored" data-anchor-id="系统调用">系统调用</h3>
<p>既然硬件都是由内核管理的，那么如果开发人员想要开发软件的话，自然就得要参考这个内核的相关功能。这样一来，还是从原本的参考硬件函数变成参考内核功能，还是一样的麻烦。</p>
<p>为了解决这个问题，操作系统通常会提供一套应用程序编程接口（Application Programming Interface，API）即系统调用层给程序员来开发软件，开发人员只要遵守该API公认的系统调用参数就可以比较容易地开发软件了。举例来说，我们学习C语言只要参考C语言的函数即可，不需要再去考虑其他内核的相关功能，因为内核的系统调用接口会主动地将C语言的相关语法转成内核可以了解的任务函数，内核自然就能够顺利地运行该程序。</p>
<p>内核只会进行计算机系统的资源分配，所以系统还需要有应用程序的提供，才能够供用户使用。应用程序与内核有比较大的关系，与硬件关系则不大；硬件也与内核有比较大的关系，至于与用户直接有关的则是应用程序。</p>
<p>有几点需要注意：</p>
<ul>
<li><p>操作系统的内核层直接参考硬件规格写成，所以同一个操作系统程序不能够在不一样的硬件架构上运行；</p></li>
<li><p>操作系统只是管理整个硬件资源，包括CPU、内存、输入输出设备及文件系统等，如果没有其他的应用程序辅助，操作系统只能让计算机处于准备妥当的状态之中，无法完成用户所想要的功能；</p></li>
<li><p>应用程序的开发都是参考操作系统的API，所以该程序只能在该操作系统当中运行，不能在其他操作系统上运行。所以有些游戏不能够在Linux上安装运行。</p></li>
</ul>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>
</section>

 ]]></description>
  <category>linux</category>
  <guid>https://leslie-lu.github.io/blog/2020/02/05/index.html</guid>
  <pubDate>Wed, 05 Feb 2020 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408231510243.webp" medium="image" type="image/webp"/>
</item>
<item>
  <title>样本量和检验效能的估计问题</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2020/02/04/index.html</link>
  <description><![CDATA[ 




<p>统计分析人员经常会被问到这样一个问题：我这个研究到底需要多少个研究对象呢？</p>
<p>这个问题可以通过检验效能分析或样本量估算来解决，它在实验设计中占有重要地位。检验效能分析可以帮助在给定置信度的情况下，判断检测到给定效应值时所需的样本量；反过来，它也能够在给定置信度水平情况下，计算在某样本量内能检测到给定效应值的概率，如果该概率过低，可以考虑修改或放弃该实验。</p>
<p>由于检验效能分析针对的是假设检验，我们回顾下假设检验的过程。</p>
<p>在统计假设检验中，首先要对总体分布参数作出一个假设（无效假设），然后从总体分布中抽样，通过样本计算所得的统计量来对总体参数进行推断。假定无效假设为真，若计算获得观测样本的统计量或更大统计量的概率（p值）非常小，小于预先设定的阈值（检验的显著性水平），便可以拒绝无效假设，接受备择假设。</p>
<p>科学研究中，越来越强调样本量的估算。确定适当的样本含量可以节约资源，并可防止因为样本含量过少引起的检验效能偏低，出现假阴性错误，这是当前医学研究中值得注意的问题。</p>
<p>样本量的估算方法很多，不同的统计检验方法使用的计算公式也不一样。一般影响样本量的因素有以下7种：</p>
<ol type="1">
<li><p>研究事件的发生率：研究事件预期的发生率越高，所需的样本量越小，反之则越大；</p></li>
<li><p>研究因素的有效率：有效率越高，即实验组和对照组比较数值差异越大，样本量就可以越小，使用小样本就能够达到统计学上的显著性，反之则越大；</p></li>
<li><p>设定假设检验的I类错误概率α，即检验水准或显著性，为假阳性错误出现的概率。α越小，所需的样本量越大，反之则越小。α水平由研究者根据具体情况决定，通常α取0.05或0.01；</p></li>
<li><p>设定假设检验的II类错误概率β，或检验效能1-β。II类错误为假阴性错误，即在特定的α水准下，若总体参数之间确实存在着差别，此时该次实验能发现此差别的概率。检验效能又称把握度，即避免假阴性错误的能力，β越小，检验效能越高，所需的样本量越大，反之就越小。β水平由研究者根据情况决定，通常取β为0.2、0.1或0.05，即1-β=0.8、0.9或0.95，也就是说把握度为80%、90%或95%；</p></li>
<li><p>了解由样本推断总体的一些信息。总体标准差一般未知，可用样本标准差代替；</p></li>
<li><p>处理组间差别的估计，即确定容许误差。容许误差越小，需要的样本量越大；</p></li>
<li><p>采用统计学检验时，当研究结果高于和低于效应指标的界限均有意义时，应该选择双侧检验，所需的样本量就大。当研究结果仅高于或低于效应指标的界限有意义时，则应该选择单侧检验，所需的样本量就小。</p></li>
</ol>
<p>在这些影响因素中，确定样本含量最重要的4个因素为I类错误概率、II类错误概率、推断总体的一些信息和容许误差。</p>
<p>研究者放宽显著性水平时（换句话说，使得拒绝无效假设更容易时），检验功效增加。类似地，样本量增加，检验功效增加。</p>
<p>通常来说，研究目标是维持一个可接受的显著性水平，尽量使用较少的样本，然后最大化统计检验的功效，也就是说，最大化发现真实效应的概率，并最小化发现错误效应的概率，同时把研究成本控制在合理的范围内。</p>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>

 ]]></description>
  <category>biostatistics</category>
  <category>sample size</category>
  <category>power</category>
  <guid>https://leslie-lu.github.io/blog/2020/02/04/index.html</guid>
  <pubDate>Tue, 04 Feb 2020 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408281607494.webp" medium="image" type="image/webp"/>
</item>
<item>
  <title>计算机概论6</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2020/02/02/index.html</link>
  <description><![CDATA[ 




<section id="机器语言程序与编译型程序" class="level3">
<h3 class="anchored" data-anchor-id="机器语言程序与编译型程序">机器语言程序与编译型程序</h3>
<p>我们在需要CPU工作时，就得要参考其内部指令集的内容，然后编写让CPU能够读得懂的脚本让其去执行，这样CPU才能执行我们所给的任务。</p>
<p>这就带来了几个问题：</p>
<ul>
<li><p>程序开发者必须要了解机器语言：机器只认识0和1，因此开发者必须要学习写机器能直接看懂的语言，而这个毫无疑问，难度很大</p></li>
<li><p>必须要了解所有硬件的相关功能函数：开发者当然需要参考机器本身的功能去编写相应的程序代码，而如果每个开发者都去了解系统的所有硬件，这个工作量实在太大</p></li>
<li><p>程序具有不可移植性：每个CPU都有其独特的指令集，每个硬件都有其功能函数，因此不同平台之间程序代码当然无法直接通用</p></li>
</ul>
<p>为了解决这些问题，计算机科学家设计出一种人类能看得懂的程序语言，然后创造一种编译器将这些人类写的程序语言转译成为机器能看得懂的机器语言，如此一来，我们修改与编写程序就容易多了。目前常见的编译器有C、C++、Java、Fortran等。</p>
<p>高级程序语言的程序代码是较容易查看的，这样我们就将程序的编写修改问题处理完毕。问题是，在这样的环境下面我们还是得要考虑整体的硬件系统，从而来设计编写程序。举个例子，当你需要将运行的数据写入内存中，你就要自行分配一个内存区块出来让这些数据能够填充上去，所以你必须要去了解内存的地址是如何定位的原理，这样一来，程序的编写又会变得麻烦。</p>
<p>为了要解决硬件方面老师需要重复编写一些程序的问题，所以有了操作系统的出现。</p>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>
</section>

 ]]></description>
  <category>linux</category>
  <guid>https://leslie-lu.github.io/blog/2020/02/02/index.html</guid>
  <pubDate>Sun, 02 Feb 2020 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408231510243.webp" medium="image" type="image/webp"/>
</item>
<item>
  <title>R语言基础–数据的输入</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2020/02/01/index.html</link>
  <description><![CDATA[ 




<section id="前言" class="level3">
<h3 class="anchored" data-anchor-id="前言">前言</h3>
<p>R可从键盘、文本文件、Excel、流行的统计软件、特殊格式的文件，以及多种关系型数据库中导入数据。</p>
</section>
<section id="键盘输入数据" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="键盘输入数据">键盘输入数据</h3>
<p>R中的函数edit()会自动调用一个允许手动输入数据的文本编辑器，步骤如下：</p>
<ol type="1">
<li><p>创建一个空数据框(或矩阵)，其中变量名和变量的模式需与预期的最终数据集一致；</p></li>
<li><p>针对这个数据对象调用文本编辑器，输入数据，并将结果保存回此数据对象中。</p></li>
</ol>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2020/02/01/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408281548152.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">example</figcaption>
</figure>
</div>
<p>类似于<code>age=numeric(0)</code>的赋值语句创建一个指定模式但不含实际数据的变量。编辑的结果需要赋值回对象本身，函数edit()事实上是在对象的一个副本上进行操作的，如果不将其赋值到一个目标，所有修改会全部丢失。单击列的标题，可以用编辑器修改变量名和变量类型（数值型、字符型），可通过单击未使用列的标题来添加新的变量。<code>mydata= edit(mydata)</code>的更简洁的等价写法是<code>fix(mydata)</code>。</p>
</section>
<section id="从带分隔符的文本文件导入数据" class="level3">
<h3 class="anchored" data-anchor-id="从带分隔符的文本文件导入数据">从带分隔符的文本文件导入数据</h3>
<p>可以使用read.table()函数，此函数可读入一个表格格式的文件并将其保存为一个数据框，语法如下：</p>
<p><code>data= read.table(file,header = TRUE,sep= "delimiter",row.names='name')</code></p>
<p>其中，file是一个带分隔符的ASCII文本文件，header表示文件是否在首行包含变量名，sep指定分隔行内数据的分隔符，row.names指定一个或多个行标记符（指定某变量为行名，该列即不再有标签，导致数据会少一列）。</p>
<p>默认情况下，字符型变量将转换为因子。设置选项stringsAsFactors=FALSE，将停止对所有字符型变量的转换，或者使用选项colClasses指定每一列的类，如logical（逻辑型）、numeric（数值型）、characer（字符型）、factor（因子）。</p>
</section>
<section id="导入excel数据" class="level3">
<h3 class="anchored" data-anchor-id="导入excel数据">导入Excel数据</h3>
<p>读取一个Excel文件可以在Excel中将其导出为一个逗号分隔文件csv，再使用前文描述的方式将其导入R中。或者可以使用xlsx包，函数read.xlsx()导入一个工作表到一个数据框中：</p>
<p><code>read.xlsx(file, sheetIndex, sheetName, rowIndex)</code></p>
<p>read.xlsx()允许指定工作表中特定的行（rowIndex）和列（colIndex），配合上对应每一列的类（colClasses）。对于大型的工作簿，可以使用函数read.xlsx2()，该函数用Java来运行更加多的处理过程，可获得可观的质量提升。</p>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>
</section>

 ]]></description>
  <category>r</category>
  <guid>https://leslie-lu.github.io/blog/2020/02/01/index.html</guid>
  <pubDate>Sat, 01 Feb 2020 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408231513804.webp" medium="image" type="image/webp"/>
</item>
<item>
  <title>计算机概论5</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2020/01/31/index.html</link>
  <description><![CDATA[ 




<section id="cmos与bios" class="level3">
<h3 class="anchored" data-anchor-id="cmos与bios">CMOS与BIOS</h3>
<p>前面我们提过CMOS与BIOS的功能：CMOS主要记录主板上面的重要参数，包括系统时间、CPU电压与频率、各项设备的I/O地址与IRQ等。BIOS是写入到主板上某一块flash的程序，它可以在计算机启动的时候执行，以加载CMOS当中的参数，并尝试调用存储设备中的引导程序，进一步进入操作系统当中。BIOS程序可以修改CMOS中的数据，每种主板进入BIOS设置程序的按键都不同，一般桌面电脑常见的是使用[Del]按键进入BIOS设置界面。</p>
</section>
<section id="设备io地址与irq中断请求" class="level3">
<h3 class="anchored" data-anchor-id="设备io地址与irq中断请求">设备I/O地址与IRQ中断请求</h3>
<p>主板是负责各个电脑组件之间的通信，但是电脑组件实在太多，有输出/输入不同的存储设备等，这个时候主板芯片组就需要用到I/O地址与IRQ进行设备间的通信。I/O地址有点类似于每个设备专属的门牌号码，一般来说，不能有两个设备使用同一个I/O地址，否则系统会不知道该运行哪个设备。IRQ可以想成是各个设备门牌连接到邮件中心（CPU）的专门路径，各设备可以通过IRQ中断请求来告知CPU该设备的工作情况，以方便CPU进行工作分配的任务。</p>
</section>
<section id="数据表示方法" class="level3">
<h3 class="anchored" data-anchor-id="数据表示方法">数据表示方法</h3>
<p>事实上我们的电脑只认识0与1，记录的数据也是只能记录0与1而已。早期的电脑使用的是利用通电与否的特性制造的电子管，如果通电就是1，没有通电就是0，后来沿用至今，也就是我们说的二进制（binary）。电脑在表示利用数字时，利用二进制的转换进行对数字的处理。</p>
<p>而对于文字的记录，事实上文本文件也是被记录为0与1，而这个文件的内容在被读取查看时，必须要经过一个编码系统的处理才行。所谓的编码系统可以看成是一个字码对照表。当我们要写入文件的字符数据时，该文字数据会由编码对照表将该字符转成数字后，再存入文件当中。同样，当我们要将文件内容的数据读出时，也会经过编码对照表将该数字转成对应的字符后，再显示到屏幕中。如果编码对照表写错，导致对照的字符产生误差，就会出现乱码。</p>
<p>常用的英文编码表为ASCII系统，这个编码系统中，每个符号（英文、数字或符号等）都会占用1字节的记录，因此总共会有2的8次方即256种变化。国际组织ISO/IEC制定了所谓的Unicode编码系统，即我们常常说的UTF-8。这个编码打破了所有国家不同的编码之间的限制，因此目前互联网网站大多以此编码系统为主。</p>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>
</section>

 ]]></description>
  <category>linux</category>
  <guid>https://leslie-lu.github.io/blog/2020/01/31/index.html</guid>
  <pubDate>Fri, 31 Jan 2020 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408231510243.webp" medium="image" type="image/webp"/>
</item>
<item>
  <title>R语言基础–函数</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2020/01/30/index.html</link>
  <description><![CDATA[ 




<section id="前言" class="level3">
<h3 class="anchored" data-anchor-id="前言">前言</h3>
<p>R中作为数据处理基石的函数，可分为数值（数学、统计、概率）函数和字符处理函数。</p>
</section>
<section id="数值函数" class="level3">
<h3 class="anchored" data-anchor-id="数值函数">数值函数</h3>
<p>对数据做变换是数学函数的一个主要用途。数学函数也被用作公式中的一部分，用于绘图函数和在输出结果之前对数值做格式化。</p>
<p>统计函数我们在进行统计学方法分析时一定会用到。</p>
<p>概率函数通常用来生成特征已知的模拟数据，以及在用户编写的统计函数中计算概率值。</p>
</section>
<section id="字符处理函数" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="字符处理函数">字符处理函数</h3>
<p>数学和统计函数是用来处理数值型数据的，而字符处理函数可以从文本型数据中抽取信息，或者为打印输出和生成报告重设文本的格式。</p>
<p>这里我们不举例子，大家可以下载下图所示的一份文档，可以打印出来，随时查阅。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2020/01/30/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408231528510.jpeg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">cheat sheet</figcaption>
</figure>
</div>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>
</section>

 ]]></description>
  <category>r</category>
  <category>programming</category>
  <guid>https://leslie-lu.github.io/blog/2020/01/30/index.html</guid>
  <pubDate>Thu, 30 Jan 2020 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408231513804.webp" medium="image" type="image/webp"/>
</item>
<item>
  <title>R语言基础–运算符</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2020/01/29/index.html</link>
  <description><![CDATA[ 




<section id="前言" class="level3">
<h3 class="anchored" data-anchor-id="前言">前言</h3>
<p>运算符是一些符号，进行算术运算、比较运算或逻辑运算等。</p>
</section>
<section id="算术运算符" class="level3">
<h3 class="anchored" data-anchor-id="算术运算符">算术运算符</h3>
<p>指数学运算中常用的5种运算符号，有：</p>
<ul>
<li><p>^ 幂</p></li>
<li><p><code>*</code> 乘</p></li>
<li><p><code>/</code> 除</p></li>
<li><p><code>+</code> 加</p></li>
<li><p><code>-</code> 减</p></li>
<li><p><code>%%</code> 模运算</p></li>
<li><p><code>%/%</code> 整数除法</p></li>
</ul>
</section>
<section id="比较算符" class="level3">
<h3 class="anchored" data-anchor-id="比较算符">比较算符</h3>
<p>建立两个量之间的一种关系，并要求R确定这种关系是否成立。若成立，输出的运算结果为1（TRUE），若不成立，运算结果为0（FALSE）。</p>
<ul>
<li><p><code>==</code> 等于</p></li>
<li><p><code>!=</code> 不等于</p></li>
<li><p><code>&gt;</code> 大于</p></li>
<li><p><code>&lt;</code> 小于</p></li>
<li><p><code>&gt;=</code> 大于等于</p></li>
<li><p><code>&lt;=</code> 小于等于</p></li>
</ul>
</section>
<section id="逻辑算符" class="level3">
<h3 class="anchored" data-anchor-id="逻辑算符">逻辑算符</h3>
<p>通常用来连接一系列比较式，有：</p>
<ul>
<li><p><code>&amp;&amp;</code> 标量的逻辑“与”运算</p></li>
<li><p><code>||</code> 标量的逻辑“或”运算</p></li>
<li><p><code>&amp;</code> 向量的逻辑“与”运算</p></li>
<li><p><code>|</code> 向量的逻辑“或”运算</p></li>
<li><p><code>!</code> 逻辑“非”</p></li>
</ul>
<p>R语言表面上没有标量的类型，标量可以看作是含有一个元素的向量，但逻辑运算符对标量和向量有着不同的形式。</p>
</section>
<section id="运算次序" class="level3">
<h3 class="anchored" data-anchor-id="运算次序">运算次序</h3>
<p>复杂表达式运算次序的准则：</p>
<ol type="1">
<li><p>括号里的表达式先计算；</p></li>
<li><p>较高优先级的运算先执行，具体的优先级的顺序为：</p></li>
</ol>
<ul>
<li><p>第一级（最高级）：^（幂）；!（非）</p></li>
<li><p>第二级：*（乘）；/（除）</p></li>
<li><p>第三级：+（加）；-（减）</p></li>
<li><p>第四级：&lt;；&lt;=；&gt;；&gt;=；==；!=</p></li>
<li><p>第五级：&amp;；&amp;&amp;；|；||</p></li>
</ul>
<ol start="3" type="1">
<li>对于相同优先级的算符，先做左边的运算。</li>
</ol>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>
</section>

 ]]></description>
  <category>r</category>
  <category>programming</category>
  <guid>https://leslie-lu.github.io/blog/2020/01/29/index.html</guid>
  <pubDate>Wed, 29 Jan 2020 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408231513804.webp" medium="image" type="image/webp"/>
</item>
<item>
  <title>R语言基础–因子</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2020/01/28/index.html</link>
  <description><![CDATA[ 




<section id="因子" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="因子">因子</h3>
<p>因子在R中非常重要，因为它决定了数据的分析方式以及如何进行结果展示。因子也在R中具有许多强大运算的基础，包括许多针对表格数据的运算。因子的设计思想来源于统计学中的名义变量或分类变量，这些变量本质上不是数字，而是对应分类。例如血型，尽管可以用数字对它们进行编码。</p>
<p>变量可分为名义型(无序分类变量)、有序型(表示顺序而非数量关系)和连续型变量。连续型变量可以呈现某个范围内的任意值，同时表示顺序和数量，如年龄是一个连续型变量。R中名义型变量和有序型变量称为因子。</p>
<p>函数factor()以一个整数向量的形式存储类别值，同时一个由字符串（原始值）组成的内部向量将映射到这些整数上，如：</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2020/01/28/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408231514840.webp" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">factor</figcaption>
</figure>
</div>
<p>将此向量存储为(1, 2, 1, 1)，并在内部将其关联为1=Type1和2=Type2（具体赋值根据字母顺序决定）。针对向量diabetes进行的任何分析都会将其视为名义型变量并自动选择合适的统计方法。</p>
<p>在R中，因子可以简单地看作一个附加更多信息的向量（尽管它们内部机理是不同的）。这额外的信息包括向量中不同值的记录，我们称之为“水平”。</p>
<p>要表示有序型变量，需要为函数factor()指定参数ordered=TRUE，如：</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2020/01/28/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408231515774.webp" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">ordered-factor</figcaption>
</figure>
</div>
<p>此时顺序为’Excellent’‘Improved’‘Poor’（对于字符型向量，因子的水平默认依字母顺序创建），这里恰好与逻辑顺序一致。若不一致，可以通过指定levels选项覆盖默认排序：</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2020/01/28/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408231515992.jpeg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">ordered-factor-levels</figcaption>
</figure>
</div>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>
</section>

 ]]></description>
  <category>r</category>
  <category>programming</category>
  <guid>https://leslie-lu.github.io/blog/2020/01/28/index.html</guid>
  <pubDate>Tue, 28 Jan 2020 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408231513804.webp" medium="image" type="image/webp"/>
</item>
<item>
  <title>计算机概论4</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2020/01/27/index.html</link>
  <description><![CDATA[ 




<section id="显卡" class="level3">
<h3 class="anchored" data-anchor-id="显卡">显卡</h3>
<p>显卡又称为VGA（Video Graphics Array），它对于图形影像的显示扮演着相当关键的角色。一般对于图形影像的显示重点在于分辨率与颜色深度，因为每个图像显示的颜色会占用内存，因此显卡上面会有集成内存并被称为显存，这个显存容量将会影响到你的屏幕分辨率与颜色深度。</p>
<p>假设你的显示器使用1024*768分辨率，且使用全彩（每个像素占用3B的容量），至少需要多少内存才能使用这样的饱和度？</p>
<p>因为1024*768分辨率中会有786432个像素，每个像素占用3B，所以总共需要2.25MB以上才行。但如果考虑屏幕的刷新率（每秒钟屏幕的刷新次数），显卡的内存还是越大越好。</p>
<p>除了显存之外，现在显卡的运算能力也越来越重要，所以显卡厂商直接在显卡上面嵌入一个3D加速的芯片，这就是所谓的GPU称谓的由来。</p>
<p>显卡主要也是通过GPU的控制芯片来与CPU、内存等通信，也是需要高速运算的一个组件，所以数据的传输也是越快越好。</p>
<p>显卡与电脑屏幕（或电视）连接的主要接口有：</p>
<ul>
<li><p>D-Sub（VGA接口）：较早之前的连接接口，当初设计是针对传统的CRT显示器而来；</p></li>
<li><p>DVI：常见于液晶屏幕的连接；</p></li>
<li><p>HDMI：可同时传输影像与声音，被广泛地使用于电视屏幕中，电脑屏幕目前也经常都会支持HDMI格式；</p></li>
<li><p>DisplayPort：与HDMI相似，可同时传输影像与声音。</p></li>
</ul>
</section>
<section id="硬盘" class="level3">
<h3 class="anchored" data-anchor-id="硬盘">硬盘</h3>
<p>硬盘是由许多的圆形碟片、机械手臂、磁头与主轴马达所组成的。实际的数据都是写在具有磁性物质的碟片上面，而读写主要是通过在机械手臂上的磁头来完成的。实际运行时，主轴马达让碟片转动，然后机械手臂可伸展让磁头在碟片上面进行读写的操作。另外，由于单一碟片的容量有限，因此有的硬盘内部会有两个以上的碟片。</p>
<p>由于碟片是圆的，且通过机械手臂去读写数据，碟片要转动起来才能够让机器手臂读写，因而通常数据就是以圆圈转圈的方式读写。当初设计在类似碟片同心圆上面切出一个一个的小区块，让磁头去读写，这个小区块就是磁盘的最小物理存储单位，称之为扇区（sector），同一个同心圆的扇区组合成的圆就是所谓的磁道（track）。由于磁盘里可能会有多个碟片，因此在所有碟片上面的同一个磁道可以组合成所谓的柱面（cylinder）。</p>
<p>我们知道同心圆外圈的圆比较大，占用的面积比内圈多，所以外圈的圆有更多的扇区，通常数据的读写也是默认从外圈开始往内写。原本硬盘的扇区都是设计成512B的大小，目前绝大部分的高容量硬盘已经使用了4KB大小的扇区设计。也因为这个扇区设计，在磁盘分区方面，目前有旧式的MBR模式（MS-DOS兼容模式），以及较新的GPT模式。在较新的GPT模式下，磁盘的分区通常使用扇区号码来划分，和过去旧的MS-DOS是通过柱面号码来划分的方式不同。</p>
<p>注意：由于硬盘内部机械手臂上的磁头与碟片的接触是很细微的空间，如果有抖动或是污物附着在磁头与碟片之间就会造成数据的损坏或是物理磁盘整个损坏，因而，在电脑通电之后避免震动硬盘。另外，因为机械手臂必须要回归原位，不要随便将电脑电源插头拔掉就以为是顺利关机。</p>
</section>
<section id="固态硬盘" class="level3">
<h3 class="anchored" data-anchor-id="固态硬盘">固态硬盘</h3>
<p>传统硬盘有个很致命的问题，就是需要驱动马达来转动碟片，这会造成很严重的磁盘读取延迟。因此有厂商拿闪存去制作高容量的设备，而且外形还做的和传统磁盘一样。所以，这类设备已经和传统的机械磁盘（Hard Disk Drive，HDD）不同，我们称之为固态硬盘（Solid State Disk或Solid State Driver，SSD）。</p>
<p>固态硬盘的最大好处是：它没有马达要去转动，而是通过闪存直接读写的特性，因此除了没数据延迟且快速之外，还很省电。测试磁盘的性能时，有个很特殊的度量单位，称为每秒读写操作次数（Input/Output Operations Per Second，IOPS），这个数值越大，代表可操作次数较高，当然性能也越好。</p>
<p>目前大家对于HDD和SSD的使用方式大多是：使用SSD作为系统盘，将数据存储放在HDD上，这样系统运行快速，而数据存储量也大。</p>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>
</section>

 ]]></description>
  <category>linux</category>
  <guid>https://leslie-lu.github.io/blog/2020/01/27/index.html</guid>
  <pubDate>Mon, 27 Jan 2020 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408231510243.webp" medium="image" type="image/webp"/>
</item>
<item>
  <title>R语言编程入门</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2020/01/22/index.html</link>
  <description><![CDATA[ 




<section id="前言" class="level3">
<h3 class="anchored" data-anchor-id="前言">前言</h3>
<p>类似其他计算机高级语言，R用户只需要熟悉其命令、语句及简单的语法规则，就可以做数据管理和分析处理工作。R把大部分常用的复杂数据计算的算法作为标准函数调用，用户仅需要指出函数名及其必要的参数即可，这一特点使得R编程十分简单。</p>
<p>R是面向对象的、区分大小写的解释型数组编程语言，输入后可直接给出结果。R中功能靠函数实现。R的函数分为“高级”和“低级”函数，高级函数可调用低级函数，这里的高级函数习惯上称为泛型函数。plot()就是泛型函数，可以根据数据的类型调用底层的函数，应用相应的方法绘制相应的图形。这就是面向对象编程的思想。</p>
</section>
<section id="数据集" class="level3">
<h3 class="anchored" data-anchor-id="数据集">数据集</h3>
<p>创建含有研究信息的数据集，这是任何数据分析的第一步。数据集通常是由数据构成的一个矩形数组，行表示观测，列表是变量。</p>
<p>R可以处理的数据类型包括数值型（如100）、字符型（如“流光相约”）、逻辑型（TRUE/FALSE）、复数型（如2+3i）和因子型（表示不同类别）。R中有许多用于存储数据的结构，包括标量、向量、矩阵、数组、数据框和列表。多样化数据结构赋予了R极其灵活的数据处理能力。</p>
</section>
<section id="标量与向量" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="标量与向量">标量与向量</h3>
<p>标量可以看成是只含一个元素的向量，用于保存常量，如f=3、g=’US’和h=TRUE。</p>
<p>向量是一系列元素的组合，用于存储数值型、字符型或逻辑型数据的一维数组。执行组合功能的函数c()可用来创建向量：</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2020/01/22/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408231458101.webp" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">vector</figcaption>
</figure>
</div>
<p>提示：单个向量中的数据必须是相同的类型或模式（数值型、字符型或逻辑型），同一向量中不可混杂不同类型数据。</p>
<p>通过在方括号中给定元素所处位置的数值访问向量中的元素，如a[c(2, 4)]用于访问向量a中第2个和第4个元素。</p>
</section>
<section id="矩阵" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="矩阵">矩阵</h3>
<p>矩阵是一个二维数组，和向量类似，其中元素必须类型相同，即一个矩阵中只能包含一种数据类型（数值型、字符型或逻辑型），可通过函数matrix()创建矩阵：</p>
<p><code>mymatrix= matrix(vector,nrow = ,ncol = ,byrow = ,dimnames = list())</code></p>
<p>其中，vector包含了矩阵的元素，nrow和ncol用于制定行和列的维数，dimnames包含了可选的、以字符型向量表示的行名和列名，byrow表明矩阵应当按行填充（byrow=T）还是按列填充（byrow=F），默认按列填充。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2020/01/22/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408231459393.webp" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">matrix</figcaption>
</figure>
</div>
<p>我们可以使用下标和方括号来选择矩阵中的行、列或元素。X[i,]表示矩阵X中的第i行，X[,j]表示第j列，X[i, j]表示第i行第j个元素。</p>
</section>
<section id="数组" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="数组">数组</h3>
<p>矩阵都是二维的，仅能包含一种数据类型，当维度超过2时，需要使用数组，可通过函数array()创建：</p>
<p><code>myarray= array(vector,dimensions,dimnames)</code></p>
<p>其中，vector包含了数组中的数据，dimensions是一个数值型向量，给出了各个维度下标的最大值，dimnames是可选的、各维度名称标签的列表。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2020/01/22/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408231500194.webp" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">array</figcaption>
</figure>
</div>
<p>数组是矩阵的一个自然推广，从数组中选取元素的方式与矩阵相同。</p>
</section>
<section id="数据框" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="数据框">数据框</h3>
<p>与通常在SAS、SPSS和STATA中看到的数据集类似，不同的列可以包含不同类型的数据。数据框是R中最常处理的数据结构，可使用函数data.frame()创建：</p>
<p><code>mydata=data.frame(col1,col2,col3,...)</code></p>
<p>其中，列向量col1，col2，col3等可谓任何类型（如字符型、数值型或逻辑型）。</p>
<p>选取数据框中元素的方式比较多，既可以使用下标记号，也可以直接指定列名，如patientdata<img src="https://latex.codecogs.com/png.latex?age%EF%BC%8C%E5%85%B6%E4%B8%AD">被用来选取一个给定数据框中的某个特定变量。</p>
<p>在每个变量名前都输入一次数据框名可能十分麻烦，我们可以联合使用函数attach()和detach()，或单独使用函数with()来简化代码。函数attach()将数据框添加到R的搜索路径中，R在遇到一个变量名后，将检查搜索路径中的数据框，以定位到这个变量，如</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2020/01/22/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408231501809.webp" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">dataframe</figcaption>
</figure>
</div>
<p>函数detach()将数据框从搜索路径中移除，不会影响数据框本身。注意：函数attach()和detach()最好是分析一个单独的数据框，并且不太可能有多个同名对象。当同名时，原始对象将进行优先运算。另一种方式是使用函数with()，如</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2020/01/22/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408231501015.webp" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">with function</figcaption>
</figure>
</div>
<p>花括号{}之间的语句都针对该数据框执行，无需担心名称冲突；若仅有一条语句，花括号可以省略。函数with()的局限性在于赋值仅在此函数的括号内有效。若需要创建在with()结构外依然存在的对象，使用特殊赋值符号 -&gt;&gt; ，即可保存对象到全局环境中。</p>
</section>
<section id="列表" class="level3">
<h3 class="anchored" data-anchor-id="列表">列表</h3>
<p>列表是一些对象（成分）的有序集合，允许整合若干对象到单个对象名下，其中的对象可以是任何数据结构，如某个列表可以是若干向量、矩阵、数据框甚至其他列表的组合，使用函数list()创建列表：</p>
<p><code>mylist=list(object1,object2,...)</code></p>
<p>可以通过在双重方括号中指明代表某个成分的数字或名称来访问列表中的元素，如mylist[[4]]。由于列表允许以一种简单的方式组织和重新调用可能不相干的信息，且许多R函数的运行结果都是以列表的形式返回的，由分析人员决定需要取出其中哪些成分，列表是R中的重要数据结构。</p>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>
</section>

 ]]></description>
  <category>r</category>
  <category>programming</category>
  <guid>https://leslie-lu.github.io/blog/2020/01/22/index.html</guid>
  <pubDate>Wed, 22 Jan 2020 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408231456030.webp" medium="image" type="image/webp"/>
</item>
<item>
  <title>上手vim编辑器</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2020/01/21/index.html</link>
  <description><![CDATA[ 




<p>我们平时已经接触了不少的程序编辑器，今天我们要上手一种命令行模式下的文本编辑器——vim编辑器。说它是文本编辑器有点小瞧它的功能，实际上，它也可以作为程序编辑器使用，且功能十分强大。</p>
<p>在所有的Linux发行版上面都会有一个文本编辑器，那就是vi，vim是高级版的vi。vim不仅可以用不同的颜色显示文字内容，还能够进行诸如shell脚本、C语言等程序编辑，搭配Python也是十分的香，甚至不少人用它来作为写作的专用编辑器。由此可知它的功能有多么的强大。</p>
<p>如果你在学习Linux，身边的人都会建议你：学习使用命令行模式来处理Linux系统的设置问题，而尽量少去使用图形窗口模式。在配置Linux参数文件时，我们就需要一款强大稳定的文本编辑器。而Linux在命令行模式下的文本编辑器有哪些呢？我们常听到emacs、nano、vim等，而在其中，其实vim并非是对用户最友善的文本编辑器。但是为什么这么多人推荐使用呢？原因有几点：</p>
<ul>
<li><p>所有的UNIX-like系统都会内置vi文本编辑器，其他的文本编辑器不一定会存在；</p></li>
<li><p>很多软件的编辑接口都会主动调用vi；</p></li>
<li><p>vim具有程序编辑的能力，可以主动地以字体颜色辨别语法的正确性，方便程序设计；</p></li>
<li><p>编辑速度相当快速。</p></li>
</ul>
<p>可以说，如果不上手vim，Linux中很多命令根本无法操作。</p>
<p>我们提到，vim是高级版本的vi，它可以用颜色或下划线的方式来显示一些特殊的信息，可以依据文件的扩展名或是文件内的开头信息，判断该文件的内容而自动调用该程序的语法判断样式，再以颜色来显示程序代码与一般信息，vim是程序开发者的一项非常好用的工具，就连vim的官方网站（http://www.vim.org）都认为自己是一款程序开发工具而非仅仅是文本处理软件。</p>
<p>由于是命令行模式下的编辑器，当我们在编辑程序或者制作网页的时候，vim不能做到一般编辑器那样所见即所得，这是它的一个特色。vim同样也有一些非常好用的功能，如支持正则表达式的查找方式、多文件编辑、区块复制等，非常的棒。我们会在日后持续更新vim的使用分享。</p>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>

 ]]></description>
  <category>vim</category>
  <category>linux</category>
  <guid>https://leslie-lu.github.io/blog/2020/01/21/index.html</guid>
  <pubDate>Tue, 21 Jan 2020 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408231449328.webp" medium="image" type="image/webp"/>
</item>
<item>
  <title>计算机概论3</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2020/01/20/index.html</link>
  <description><![CDATA[ 




<section id="内存" class="level3">
<h3 class="anchored" data-anchor-id="内存">内存</h3>
<p>前面提到CPU所使用的数据都是来自内存（Main Memory），不论是软件程序还是文件数据，都必须要读入内存后CPU才能利用。个人电脑的内存主要组件为动态随机存取内存（Dynamic Random Access Memory，DRAM），随机存取内存只有在通电时才能记录与使用，断电之后数据就消失，因此我们也称这种RAM为挥发性内存。</p>
<p>DRAM根据技术的更新又分好几代，而使用上较广泛的有所谓的SDRAM与DDR SDRAM两种。新一代的PC大多使用DDR内存。</p>
<p>在某种意义上，内存的容量有时比CPU的速度还要重要。如果内存容量不够大的话将会导致某些大容量数据无法被完整地加载，此时已存在内存当中但暂时没有被使用到的数据就必须要先被释放，使得可用内存容量大于该数据，那份新数据才能够被加载。所以。通常越大的内存代表越快速的系统，这是因为系统不用常常释放一些内存中的数据。</p>
</section>
<section id="cpu的二级高速缓存" class="level3">
<h3 class="anchored" data-anchor-id="cpu的二级高速缓存">CPU的二级高速缓存</h3>
<p>除了内存外，个人电脑中还有许多类似内存的存储结构存在，最为我们所熟知的还有CPU内的二级高速缓存。我们现在知道CPU的数据都由内存提供，但CPU到内存之间还是得要通过内存控制器。如果某些很常用的程序或数据可以放置到CPU内存的话，那么CPU数据的读取就不需要跑到内存重新读取，这对于性能来说是一个很大的提升，这就是二级缓存的设计理念。新一代的CPU都有内置容量不等的L2缓存在CPU内部，以加快CPU的运行性能。</p>
</section>
<section id="只读存储器" class="level3">
<h3 class="anchored" data-anchor-id="只读存储器">只读存储器</h3>
<p>还记得你的电脑在开机的时候可以按下[Del]按键来进入一个名为BIOS（Basic Input Output System）的界面吧？BIOS是一个程序，这个程序是写死到主板上面的一个存储芯片中的，这个存储芯片在没有通电时也能够记录数据，这就是只读存储器（Read Only Memory，ROM）。ROM是一种非易失性的存储。</p>
<p>BIOS对于个人电脑来说是非常重要的，它是系统在启动的时候首先会去读取的一个小程序。另外，固件（firmware）很多也是使用ROM来进行软件的写入（固件：固定在硬件上面的控制软件）。BIOS就是个固件，控制着启动时各项硬件参数的获取与启动设备的选择。</p>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>
</section>

 ]]></description>
  <category>linux</category>
  <guid>https://leslie-lu.github.io/blog/2020/01/20/index.html</guid>
  <pubDate>Mon, 20 Jan 2020 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408231447001.webp" medium="image" type="image/webp"/>
</item>
<item>
  <title>谈谈电脑的CPU</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2020/01/19/index.html</link>
  <description><![CDATA[ 




<section id="前言" class="level3">
<h3 class="anchored" data-anchor-id="前言">前言</h3>
<p>前面我们已经初步了解了计算机–<a href="https://mp.weixin.qq.com/s/Zu811hypKzQwmD_AwkyQnw">你真的了解自己的电脑吗？</a>接下来我们继续深入计算机的CPU单元。</p>
</section>
<section id="cpu" class="level3">
<h3 class="anchored" data-anchor-id="cpu">CPU</h3>
<p>前面我们提过，一般我们常说的电脑指的是x86的个人电脑架构。Linux操作系统最早在发展的时候，就是依据个人电脑的架构来设计的。而在个人电脑架构中，充当“大脑”的无疑是CPU。</p>
<p>由于CPU负责大量运算，因而它是电脑中具有相当高发热量的组件。现在的所谓多内核CPU，是在一块CPU封装内嵌入两个以上的运算内核，即含有两个以上的CPU单元。</p>
<p>我们已经知道，CPU内部指令集的不同会导致其工作效率的高低，那么CPU性能的比较还有什么呢？答案是频率。CPU的频率就是CPU每秒钟可以进行的工作次数，频率越高表示这块CPU在单位时间内可以做更多的事情。举例来说，Intel的i7-4790CPU频率为3.6GHz，即表示这块CPU在一秒内可以进行3.6*10的九次方次工作。但是需要注意的是：只能在同款CPU间比较频率的快慢，不同CPU由于指令集、架构、使用的二级缓存及其运算机制的可能不同，单纯看频率没有可比性。</p>
<p>我们可能听过“超频”这个词，它是什么意思呢？CPU在出厂时，厂商已经设置了这款CPU正常稳定工作的频率，一些电脑硬件玩家要发挥出CPU最大的性能，往往会手动将CPU的外频通过主板提供的设置功能更改成较高频率。现在Intel的CPU会主动帮你超频，以合理利用CPU以及节能。</p>
<p>最常听见的还有32位与64位电脑，我们可能也一头雾水。其实这个也与CPU相关。我们将CPU每次能够处理的数据量称为字长（word size），字长依据CPU的设计而有32位与64位，而32位与64位电脑主要就是依据这个CPU所能解析的字长而来的。早期的32位CPU中，由于CPU每次解析的数据量有限，因此从内存传来的数据量就有所限制，这也导致32位的CPU最多只能支持最大到4GB的内存。目前的64位CPU统称为x86-64。</p>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>
</section>

 ]]></description>
  <category>linux</category>
  <guid>https://leslie-lu.github.io/blog/2020/01/19/index.html</guid>
  <pubDate>Sun, 19 Jan 2020 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408231443028.webp" medium="image" type="image/webp"/>
</item>
<item>
  <title>Python正则表达式与模式匹配</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2020/01/18/index.html</link>
  <description><![CDATA[ 




<p>很多商业分析都依赖模式匹配，也称为正则表达式（regular expression）。举例来说，我们可能需要分析一下来自深圳的所有订单。此时，你需要识别的模式就是“深圳”这个词。同样，你可能需要分析来自某个供应商的商品质量，此时你要识别的模式就是供应商的名字。</p>
<p>Python包含了re模块，它提供了在文本中搜索特定模式/正则表达式的强大功能。要在脚本中使用re模块提供的功能，我们需要在脚本上方加入代码import re。</p>
<p>导入re模块后，可以使用一大波函数和元字符来创建和搜索任意复杂的模式。元字符（metacharacter）是正则表达式中具有特殊意义的字符，使正则表达式能够匹配特定的字符串。</p>
<p>常用的元字符包括 |、()、[]、.、*、+、?、^、$和<code>(?P&lt;name&gt;)</code>。如果你在正则表达式中见到这些字符，要知道程序不是要搜索这些字符本身，而是要搜索它们要描述的东西。</p>
<p>re模块包含了很多有用的函数，用于创建和搜索特定的模式。一起来看一个示例代码：</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2020/01/18/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408231421391.webp" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">sample code</figcaption>
</figure>
</div>
<p>第一行赋值字符串变量string，下一行将字符串拆分为列表，列表中的每个元素都是一个单词。使用re.compile和re.I函数以及用r表示的原始字符串，创建一个名为pattern的正则表达式。re.compile函数将文本形式的模式编译成为正则表达式（正则表达式不是必须编译的，但编译是个好习惯，因为这样可以显著地提高程序运行速度），re.I函数确保模式是不区分大小写的，即能同时在字符串中匹配“The”和“the”，原始字符串标志r可确保Python不处理字符串中的转义字符（如、），这样在进行模式匹配是，字符串中的转义字符和正则表达式中的元字符就不会有意外的冲突。利用for循环在列表变量sring_list的各个元素之间进行迭代，取出列表中所有的单词，使用re.search函数将每个单词与正则表达式进行比较，如果相匹配，那么count的值就加1。print语句打印出正则表达式在字符串汇总找到模式“The”（不区分大小写）的次数。</p>
<p>再看另一个示例：</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2020/01/18/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408231422976.webp" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">sample code 2</figcaption>
</figure>
</div>
<p>这个示例想要打印出相匹配的字符串，而不是相匹配的次数，这里使用到了<code>(?P&lt;name&gt;)</code>元字符和group函数。<code>(?P&lt;name&gt;)</code>元字符使匹配的字符串可以在后面的程序中通过组名符号name来引用，这里称为match_word。后面if语句中使用了group函数获取分段截获的字符串，如果相匹配，那么就在search函数返回的数据结构中找出match_word组合中的值，并打印出来。</p>
<p>最后一个示例：</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2020/01/18/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408231422618.webp" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">sample code 3</figcaption>
</figure>
</div>
<p>我们演示了使用re.sub函数在文本中用一种模式替换另一种模式。将正则表达式赋给变量string_to_find不是必需的，但若正则表达式特别长或复杂的话，将它赋给一个变量，然后传入re.compile函数有助于理解。最后使用re.sub函数以不区分大小写的方式在变量string中寻找模式，将发现的每个模式替换成a。</p>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>

 ]]></description>
  <category>python</category>
  <category>regular expression</category>
  <category>pattern matching</category>
  <guid>https://leslie-lu.github.io/blog/2020/01/18/index.html</guid>
  <pubDate>Sat, 18 Jan 2020 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408231410900.webp" medium="image" type="image/webp"/>
</item>
<item>
  <title>你真的了解自己的电脑吗？</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2020/01/17/index.html</link>
  <description><![CDATA[ 




<section id="前言" class="level3">
<h3 class="anchored" data-anchor-id="前言">前言</h3>
<p>我们现在基本上人手一台电脑，无论你是Mac、Windows还是Linux，你真的了解你手头上的电脑么？当你在选购新电脑或者购买部件的时候，是否了解该怎么挑选呢？接下来我们一起了解下最常见也是容易搞不懂的电脑/计算机。</p>
</section>
<section id="什么是计算机" class="level3">
<h3 class="anchored" data-anchor-id="什么是计算机">什么是计算机</h3>
<p>一般地，接受用户输入命令与数据，经由中央处理器的数学与逻辑单元运算处理后，以产生或存储成有用的信息的机器，我们就称之为计算机。从这个意义上讲，我们日常用的计算器、手机、GPS卫星定位系统、ATM取款机、台式电脑、笔记本电脑、iPad、Apple Watch等都是计算机。我们常说的计算机是其中的台式或笔记本电脑。</p>
</section>
<section id="电脑硬件" class="level3">
<h3 class="anchored" data-anchor-id="电脑硬件">电脑硬件</h3>
<p>电脑的三大部分（以台式电脑为例）包括：</p>
<ul>
<li><p>输入单元：包括键鼠、读卡器、扫描仪、手写板、触控屏幕等</p></li>
<li><p>主机部分：即系统单元，在主机机箱内，里面含有一堆板子、CPU与内存等</p></li>
<li><p>输出单元：屏幕、打印机等</p></li>
</ul>
<p>主机里面最重要的就是一块主板，上面安装了中央处理器（Central Processing Unit, CPU）以及内存、硬盘（或存储卡）还有一些适配卡设备。大部分智能手机是将这些组件直接焊接在主板上面而不是插卡。</p>
</section>
<section id="cpu" class="level3">
<h3 class="anchored" data-anchor-id="cpu">CPU</h3>
<p>整台主机的重点在于CPU，CPU为一个具有特定功能的芯片，里面含有指令集，如果你想要让主机进行什么操作，就得要参考这块CPU是否有相关内置的指令集才可以。由于CPU的工作主要在于管理和运算，因此在CPU内又可分为两个主要的单元，分别是算术逻辑单元和控制单元。其中算术逻辑单元主要负责程序运算与逻辑判断，控制单元则主要协调各周边组件与各单元间的工作。CPU是整个电脑系统的最重要部分。</p>
<p>CPU依设计理念不同，主要分为：</p>
<ul>
<li><p>精简指令集（RISC）系统：ARM公司的ARM CPU系列等。我们常使用的各品牌手机、导航系统、路由器等，几乎都是使用ARM架构的CPU。</p></li>
<li><p>复杂指令集（CISC）系统：AMD、Intel等x86架构的CPU。由于x86架构CPU被大量用于个人电脑，因此个人电脑常被称为x86架构电脑。64位的个人电脑CPU又被统称为x86-64架构。x86架构的称呼来源于Intel最早研发出来的CPU代号。所谓的位（bit），指的是CPU一次读取数据的最大量。64位CPU表示CPU一次可以读写64位的数据，一般32位CPU所能读写的最大数据量大概是4GB。</p></li>
</ul>
</section>
<section id="电脑上面常用的计算单位容量速度等" class="level3">
<h3 class="anchored" data-anchor-id="电脑上面常用的计算单位容量速度等">电脑上面常用的计算单位（容量、速度等）</h3>
<ul>
<li><p>容量单位：电脑对数据的判断主要依据有没有通电来记录信息，所以理论上对于每一个记录单位而言，电脑只认识0与1而已。0/1这个二进制的单位我们称之为位（bit，比特）。但位实在太小，因而每份数据都使用8个位来记录，8位为一字节（Byte）。同样的，字节依然太小，因而有K代表1024B，M代表1024K，G代表1024M，T代表1024G，P代表1024T，E代表1024P。一般来说，数据容量使用二进制，所以1GB的文件大小为1024<em>1024</em>1204B。</p></li>
<li><p>速度单位：CPU的命令周期常使用MHz或GHz之类的单位，这个Hz是“次数/秒”的意思。而在网络传输方面，由于网络使用的是位为单位，因此网络常使用的单位为Mbit/s（每秒多少Mbit）。大家常听到的“20M/5M”光纤传输速度，如果转成数据容量的字节时，其实理论最大传输值为：每秒2.5MB/每秒625KB的下载或上传速度。</p></li>
</ul>
<p>假设你今天购买了一块500GB的硬盘，但是格式化完毕后只剩下460GB左右的容量，这是为什么呢？一般硬盘制造商使用十进制的单位，所以500GB代表500<em>1000</em>1000*1000B，转成数据的容量单位时使用二进制（1024为基数），所以就成为466GB左右的容量了。并非厂商骗人，只是因为硬盘的最小物理量为512B，最小的组成单位为扇区（sector），通常硬盘容量的计算采用多少个扇区，所以才会使用十进制来处理。</p>
</section>
<section id="内存" class="level3">
<h3 class="anchored" data-anchor-id="内存">内存</h3>
<p>CPU读取的数据完全从内存中来（无论是程序还是一般文件数据），如果要读取硬盘中的数据，也要将数据挪到内存当中，再交由CPU来读取。内存中的数据则是从输入单元所传输进来的，而CPU处理完毕的数据也必须要先写回内存，最后数据才从内存传输到输出单元。</p>
<p>这就是我们常说的，要加快系统性能，通常将内存容量加大就可以获得相当好的效果。因为所有的数据都是要经过内存的传输，所以内存的容量如果太小，数据读写性能就不足，对性能的影响相当大，尤其在Linux作为服务器操作系统的环境下。这也是为什么在买手机时，人们对可用内存（运行内存）的要求都很高的原因。</p>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>
</section>

 ]]></description>
  <category>linux</category>
  <guid>https://leslie-lu.github.io/blog/2020/01/17/index.html</guid>
  <pubDate>Fri, 17 Jan 2020 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408211533740.webp" medium="image" type="image/webp"/>
</item>
<item>
  <title>R语言的初体验</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2020/01/16/index.html</link>
  <description><![CDATA[ 




<p>R语言是从起源于贝尔实验室的S统计绘图语言演变而来的。与S语言类似，R也是一种为统计计算和绘图而生的语言和环境，它是一套开源的数据分析解决方案，由一个庞大且活跃的全球性研究型社区维护。</p>
<section id="r的特点总结" class="level3">
<h3 class="anchored" data-anchor-id="r的特点总结">R的特点总结</h3>
<ol type="1">
<li><p>软件本身及程序包的源代码公开；</p></li>
<li><p>涵盖了多种行业数据分析中几乎所有的方法；</p></li>
<li><p>任意一个分析步骤的结果均可被轻松保存、操作，并作为进一步分析的输入；</p></li>
<li><p>R拥有顶尖水准的制图功能；</p></li>
<li><p>R可运行于多种平台上，包括Windows、UNIX和Mac OS X；</p></li>
<li><p>可轻松地从各种类型的数据源读写数据，包括文本文件、数据库管理系统、统计软件，乃至专门的数据仓库；</p></li>
<li><p>每个函数都有统一格式的帮助和运行实例。</p></li>
</ol>
</section>
<section id="r的帮助系统" class="level3">
<h3 class="anchored" data-anchor-id="r的帮助系统">R的帮助系统</h3>
<p>R提供了大量的帮助功能，学会如何使用这些帮助文档有助于编程。R的内置帮助系统提供了当前已安装包中所有函数的细节、参考文献以及使用示例。帮助文档可以通过以下函数进行查看。</p>
<ul>
<li><p>help.start()：打开帮助文档首页</p></li>
<li><p>help(foo)或?foo：查看函数foo的描述说明等帮助信息(如返回值)</p></li>
<li><p>help.search(‘foo’)或??foo：以foo为关键词搜索本地帮助文档</p></li>
<li><p>RSiteSearch(‘foo’)：以foo为关键词搜索在线文档和邮件列表存档</p></li>
<li><p>apropos(‘foo’, mode=‘function’)：列出名称中含有foo的所有可用函数，在只知道函数的部分名称时搜索可用</p></li>
<li><p>example(foo)：查看函数foo的使用范例</p></li>
<li><p>data() 列出当前已加载包中所含的所有可用示例数据集</p></li>
<li><p>vignette() 列出当前已安装包中所有可用的vignette文档</p></li>
<li><p>vignette(‘foo’) 为主题foo显示指定的vignette文档</p></li>
</ul>
</section>
<section id="工作空间和目录" class="level3">
<h3 class="anchored" data-anchor-id="工作空间和目录">工作空间和目录</h3>
<p>工作空间（workspace）是当前R的工作环境，存储着所有你定义的对象（向量、矩阵、函数、数据框和列表）。在一个R会话结束时，你可以将当前工作空间保存到一个镜像中，以便在下次启动R时自动载入它。当前的工作目录（working directory）是R用来读取文件和保存结果的默认目录。</p>
<p>用于管理工作空间和目录的部分标准命令如下：</p>
<ul>
<li><p>getwd()：查看当前工作目录</p></li>
<li><p>setwd()：重新设定当前工作目录。如果需要读入一个不在当前工作目录下的文件，需要在调用语句中写明文件的完整路径。setwd()命令的路径中使用正斜杠/。R将反斜杠。即使在Windows平台上运行R，在路径中也要使用正斜杠。</p></li>
<li><p>ls()：列出当前工作空间中的对象</p></li>
<li><p>rm(objectlist)：删除一个或多个对象</p></li>
<li><p>options()：显示或设置当前选项</p></li>
<li><p>history(#)：显示最近使用的#个命令(默认值为25)</p></li>
<li><p>savehistory(‘myfile’) 保存命令历史到文件myfile.Rhistory中</p></li>
<li><p>loadhistory(‘myfile’) 载入命令历史文件myfile.Rhistory</p></li>
<li><p>save.image(‘myfile’) 保存工作空间到文件myfile.RData中</p></li>
<li><p>load(‘myfile’) 读取工作空间myfile.RData到当前会话中</p></li>
<li><p>save(objectlist, file=‘myfile’) 保存指定对象到一个文件中</p></li>
<li><p>q()：结束对话退出R，并询问是否保存工作空间</p></li>
</ul>
</section>
<section id="r包" class="level3">
<h3 class="anchored" data-anchor-id="r包">R包</h3>
<p>R提供了大量备用功能，通过可选模块的下载和安装来实现。目前有15364个称为包的用户贡献模块可从https://cran.r-project.org/web/packages下载。这些包提供了横跨各种领域、数量庞大的功能，包括分析地理数据、处理蛋白质质谱，甚至是心理测验分析的功能。</p>
<p>R包是R函数、数据、预编译代码以一种定义完善的格式组成的集合，具有详细的说明和示例。计算机上存储包的目录称为库（library）。.libPaths()显示库所在位置，library()则可以显示库中包。</p>
<p>第一次安装一个包，使用命令install.packages()即可，在括号中输入要安装的包名称，一个包仅需安装一次。update.packages()更新已安装的包。installed.packages()列出已安装的包的相关信息(如版本号、依赖关系等)。Windows下的R包是经过编译的zip文件，安装时不要解压缩。安装路径为“Pacakges&gt;install packages from local files”，选择本地磁盘上存储zip包的文件夹。</p>
<p>包的安装是指从某个CRAN镜像站点下载它并将其放入库中的过程。安装好以后，必须被载入到会话中才能使用包，需要使用library()函数载入该包。在一次应用中，包只需载入一次，如果需要，我们可以自定义启动环境以自动载入会频繁使用的包。search()显示已加载并可使用的包。help(‘package_name’)输出某个包的简短描述以及包中可用的函数名称和数据集名称的列表，help()查看包中任意函数或数据集的描述，R的帮助系统包含了每个函数的一个描述（同时带有示例），每个数据集的信息也被包括其中。</p>
</section>
<section id="r的使用" class="level3">
<h3 class="anchored" data-anchor-id="r的使用">R的使用</h3>
<p>R是面向对象的，区分大小写的解释型数组编程语言。R中多数功能是由程序内置函数、用户自编函数和对对象的创建和操作所实现的。一次交互式会话期间的所有数据对象都被保存在内存中。R语句由函数和赋值构成，R使用 -&gt; 而非 = 作为赋值符号。R也允许使用 = 为对象赋值，但是它不是标准语法，某些情况下会出现问题。R具有完备的数据存取、管理、分析和显示等功能，将数据处理和统计分析融为一体。以后我们继续学习R语言。</p>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>
</section>

 ]]></description>
  <category>r</category>
  <guid>https://leslie-lu.github.io/blog/2020/01/16/index.html</guid>
  <pubDate>Thu, 16 Jan 2020 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408211528692.webp" medium="image" type="image/webp"/>
</item>
<item>
  <title>kNN改进约会网站的配对效果</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2020/01/11/index.html</link>
  <description><![CDATA[ 




<section id="前言" class="level3">
<h3 class="anchored" data-anchor-id="前言">前言</h3>
<p>前面我们已经初步了解了kNN——<a href="https://mp.weixin.qq.com/s/Qfa_fEcsTA990hPNH-Rtkw">如何用Python自编k-近邻算法</a>？今天我们试着进行一个实例上kNN的应用。</p>
<p>海伦一直使用在线约会网站寻找自己心仪的约会对象。经过一番总结，她发现曾交往过三种类型的人：不喜欢的人、魅力一般的人和极具魅力的人。她发现自己无法直接将约会网站推荐的匹配对象归入恰当的上述类别之中，希望我们的分类软件能够更好地帮助她进行确切的分类。此外，她还收集了一些约会网站未曾记录的数据信息，提供给了我们。</p>
</section>
<section id="准备数据从文本文件中解析数据" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="准备数据从文本文件中解析数据">准备数据：从文本文件中解析数据</h3>
<p>海伦将准备的数据存放在文本文件datingTestSet2.txt中，每个样本数据占据一行，总共有1000行。每个样本主要收集了3种特征：每年飞行里程数、玩视频游戏所耗时间百分比和每周消费的冰淇淋公升数。如下：</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2020/01/11/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408211513823.webp" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">datingTestSet2</figcaption>
</figure>
</div>
<p>而在我们将上述特征数据输入到分类器之前，必须将待处理数据的格式转换为分类器可以接受的格式。我们之前在kNN.py中已经创建了kNN分类器函数，接下来我们创建用于处理输入数据格式的file2matrix函数，此函数的输入为文件名字符串，输出为训练样本矩阵和类标签向量，将文本记录转换为NumPy。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2020/01/11/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408211514852.webp" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">file2matrix</figcaption>
</figure>
</div>
<p>首先我们以r模式（只读模式）打开要处理的文本文件，readlines函数读取整个文件所有行，保存在一个列表变量中，每行作为一个元素，我们计数文件的行数。然后创建以零填充的矩阵，我们将该矩阵的另一维度设置为固定值3。循环处理文件的每一行数据：使用strip函数截取掉所有的回车字符，使用tab字符（将上一步得到的整行数据分割成一个元素列表，选取前3个元素存储到特征矩阵中，使用索引值-1将文件的最后一列存储到向量classLabelVector中，这里，我们必须明确地通知解释器存储的的元素值为整型，否则Python会将这些元素当作字符串进行处理。</p>
<p>使用函数file2matrix读取文件数据，必须确保文件存储在我们的工作目录中。重新加载kNN.py模块，以确保更新的内容可以生效，否则Python将继续使用上次加载的kNN模块。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2020/01/11/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408211515827.webp" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">load data</figcaption>
</figure>
</div>
<p>现在我们已经从文本文件导入了数据并将其格式化为想要的格式，接下来我们以图形化的方式直观地展示数据内容，以便辨识出一些数据模式。</p>
</section>
<section id="分析数据使用matplotlib创建散点图" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="分析数据使用matplotlib创建散点图">分析数据：使用Matplotlib创建散点图</h3>
<p>首先我们使用Matplotlib制作原始数据的散点图：</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2020/01/11/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408211515883.webp" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">scatter</figcaption>
</figure>
</div>
<p>输出效果如下图，散点图使用特征矩阵的第二、三列数据，分别为玩视频游戏所耗时间百分比和每周消费的冰淇淋公升数。由于没有使用样本类别标签，我们很难看出有用的数据模式信息。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2020/01/11/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408211516465.webp" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">plot</figcaption>
</figure>
</div>
<p>为了更好地理解数据，我们以不同的方式来标记不同的样本类别。Matplotlib库提供的scatter函数支持个性化标记散点图上的点。重新输入上面的代码，调用scatter函数时使用下列参数，利用变量datingLabels存储的类别标签属性，在散点图上绘制色彩不等、尺寸不同的点：</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2020/01/11/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408211517150.webp" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">scatter function</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2020/01/11/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408211517661.webp" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">colored plot</figcaption>
</figure>
</div>
<p>我们基本上能够看到数据点所属三个类别的区域轮廓，但还不是十分明显，接下来我们使用特征矩阵的第一、二列属性作图：</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2020/01/11/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408211518009.webp" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">clusters</figcaption>
</figure>
</div>
<p>此时我们可以看到图中清晰地标示了三个不同的样本类别区域，通过这两个特征更容易区分数据点。</p>
</section>
<section id="准备数据归一化数值" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="准备数据归一化数值">准备数据：归一化数值</h3>
<p>观察原始数据我们发现：每年飞行里程数的数量级远大于其余两个特征。在利用kNN计算样本之间的距离时，数值大的该特征会极大地影响最终的结果，也就是说，数量值大小会影响特征对结果影响的权重，而我们这里认为三个特征是同等重要的。</p>
<p>因而在处理这种情况时，我们通常采用的方法是将数值归一化，如将取值范围处理为0到1或者-1到1之间。下面的公式可将特征值转化为0到1区间内的值：<img src="https://latex.codecogs.com/png.latex?newValue%20=%20%5Cfrac%7BoldValue%20-%20min%7D%7Bmax%20-%20min%7D">，其中 <img src="https://latex.codecogs.com/png.latex?min"> 和 <img src="https://latex.codecogs.com/png.latex?max"> 分别是数据集中的最小特征值和最大特征值。我们需要在脚本 <code>kNN.py</code> 中增加一个函数 <code>autoNorm</code>，自动将数字特征值转化为0到1区间内的值。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2020/01/11/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408211520932.webp" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">autoNorm</figcaption>
</figure>
</div>
<p>我们将每列的最小值放在变量minVals中，每列最大值放在变量maxVals中，其中的参数0使得函数可以从列中选取最小值和最大值。然后函数计算可能的取值范围，并创建新的返回矩阵。</p>
<p>正如前面给出的公式，为了归一化特征，我们使用当前值减去最小值，然后除以取值范围。而需要注意的是，特征值矩阵有1000*3个值，而minVals和maxVals的值都为1*3。为了解决这个问题，我们使用NumPy库中函数tile将变量内容复制成输入矩阵同等大小的矩阵，然后再利用具体特征值相除得到归一化后的特征矩阵。需要注意的是：对于某些数值处理软件包，/可能意味着矩阵除法，但在NumPy库中，矩阵除法需要使用函数linalg.solve(matA,matB)。</p>
<p>我们重新加载kNN.py模块，执行函数autoNorm：</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2020/01/11/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408211522446.webp" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">reload autoNorm</figcaption>
</figure>
</div>
<p>这里我们也可以只返回normMat矩阵，但是后面我们需要取值范围和最小值来归一化需要测试的新数据。</p>
</section>
<section id="测试算法作为完整程序验证分类器" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="测试算法作为完整程序验证分类器">测试算法：作为完整程序验证分类器</h3>
<p>我们已经对数据按照需求进行了处理，下面我们来测试分类器的效果。我们将已有数据的90%作为训练集来训练分类器，使用余下的10%作为测试集，检测分类器的错误率。这里由于海伦提供的数据并没有按照特定目的来排序，因而我们可随意选择10%数据而不影响测试集选择的随机性。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2020/01/11/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408211523725.webp" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">datingClassTest</figcaption>
</figure>
</div>
<p>转换数据格式并归一化后，我们决定哪些数据用于测试，然后将训练集和测试集输入到kNN分类器classify函数中，计算错误率并输出分类结果。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2020/01/11/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408211524313.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">test result</figcaption>
</figure>
</div>
<p>kNN分类器在测试集上的错误率为5%。我们可以改变函数datingClassTest内变量hoRatio和变量k的值，看看错误率是否会发生一些变化。</p>
<p>现在，海伦可以输入未知对象的特征信息，由的分类器来帮助她判定某一对象的可交往程度：讨厌、一般喜欢、非常喜欢。</p>
</section>
<section id="使用算法构建完整可用系统" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="使用算法构建完整可用系统">使用算法：构建完整可用系统</h3>
<p>我们会给海伦一小段程序，通过该程序海伦会在约会网站上找到某个人并输入他的信息，程序会给出她对对方喜欢程度的预测值。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2020/01/11/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408211524612.webp" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">classifyPerson</figcaption>
</figure>
</div>
<p>这里使用input函数获取用户控制台的输入。我们让海伦给出她在约会网站上新找的一个人信息。由于NumPy库提供的数组操作并不支持Python自带的数组类型，因此在编写代码时要注意不要使用错误的数组类型。另外在输入新样本时注意将其归一化处理。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://leslie-lu.github.io/blog/2020/01/11/https:/cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408211525211.webp" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">classify result</figcaption>
</figure>
</div>
<p>这样，我们就完成了kNN对约会网站的配对效果的改进了。</p>
<section id="did-you-find-this-page-helpful-consider-sharing-it" class="level5">
<h5 class="anchored" data-anchor-id="did-you-find-this-page-helpful-consider-sharing-it">Did you find this page helpful? Consider sharing it 🙌</h5>


<!-- -->

</section>
</section>

 ]]></description>
  <category>python</category>
  <category>kNN</category>
  <guid>https://leslie-lu.github.io/blog/2020/01/11/index.html</guid>
  <pubDate>Sat, 11 Jan 2020 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202408211511348.webp" medium="image" type="image/webp"/>
</item>
</channel>
</rss>
