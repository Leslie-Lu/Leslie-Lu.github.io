<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>Zhen Lu&#39;s blog</title>
<link>https://leslie-lu.github.io/atom.html</link>
<atom:link href="https://leslie-lu.github.io/atom.xml" rel="self" type="application/rss+xml"/>
<description>Zhen Lu&#39;s blog</description>
<language>en</language>
<generator>quarto-1.6.42</generator>
<lastBuildDate>Sat, 08 Mar 2025 00:00:00 GMT</lastBuildDate>
<item>
  <title>证明随机化和盲法消除向均值回归偏倚</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2025/03/08/randomizationandBlindness/</link>
  <description><![CDATA[ 





<section id="引言" class="level3">
<h3 class="anchored" data-anchor-id="引言">引言</h3>
<p>讨论治疗分配时采用随机化和评估处理效应时采用盲法将如何帮助消除向均值回归所导致的偏倚。</p>
</section>
<section id="背景" class="level3">
<h3 class="anchored" data-anchor-id="背景">背景</h3>
<p>我们假设 <img src="https://latex.codecogs.com/png.latex?X_1"> 是处理组的基线测量值，<img src="https://latex.codecogs.com/png.latex?X_2"> 是同一组的随访测量值，且配对测量值 <img src="https://latex.codecogs.com/png.latex?(X_1,%20X_2)"> 服从二元正态分布。向均值回归（regression to the mean）是一种统计现象，是仅对那些具有 <strong>极端</strong> 初始测量值的个体进行第二次测量时发生的现象，指基线测量值 <img src="https://latex.codecogs.com/png.latex?X_1"> 较高（低）的个体在随访测量中 <img src="https://latex.codecogs.com/png.latex?X_2"> 回归到总体均值 <img src="https://latex.codecogs.com/png.latex?%5Cmu"> 的现象。</p>
<p>在临床试验中，这种现象可能被误认为是治疗效果。这里我们试着使用线性回归模型证明，随机化和盲法可以消除这种向均值回归的偏倚。</p>
</section>
<section id="线性回归模型" class="level3">
<h3 class="anchored" data-anchor-id="线性回归模型">线性回归模型</h3>
<p>设处理组的 <img src="https://latex.codecogs.com/png.latex?X_1"> 和 <img src="https://latex.codecogs.com/png.latex?X_2"> 二元正态分布的均值向量和协方差矩阵为：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Bpmatrix%7D%20X_1%20%5C%5C%20X_2%20%5Cend%7Bpmatrix%7D%20%5Csim%20%5Ctext%7BN%7D%20%5Cleft(%20%5Cbegin%7Bpmatrix%7D%20%5Cmu_1%20%5C%5C%20%5Cmu_2%20%5Cend%7Bpmatrix%7D,%20%5Cbegin%7Bpmatrix%7D%20%5Csigma_1%5E2%20&amp;%20%5Crho%5Csigma_1%5Csigma_2%20%5C%5C%20%5Crho%5Csigma_1%5Csigma_2%20&amp;%20%5Csigma_2%5E2%20%5Cend%7Bpmatrix%7D%20%5Cright)%0A"></p>
<p>其中，</p>
<p><img src="https://latex.codecogs.com/png.latex?%5Crho%20=%20%5Cfrac%7B%5Ctext%7BCov%7D(X_1,%20X_2)%7D%7B%5Csigma_1%20%5Csigma_2%7D"> 是 <img src="https://latex.codecogs.com/png.latex?X_1"> 和 <img src="https://latex.codecogs.com/png.latex?X_2"> 之间的相关系数。</p>
<p>我们使用简单的线性回归模型来描述 <img src="https://latex.codecogs.com/png.latex?X_1"> 和 <img src="https://latex.codecogs.com/png.latex?X_2"> 之间的关系：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AE(X_2%7CX_1)%20=%20%5Calpha%20+%20%5Cbeta%20X_1=%20%5Cmu_2%20+%20%5Crho%20%5Cfrac%7B%5Csigma_2%7D%7B%5Csigma_1%7D%20(X_1%20-%20%5Cmu_1)%0A"></p>
<p>其中：</p>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?%5Calpha%20=%20%5Cmu_2-%20%5Cbeta%20%5Cmu_1"> ，</li>
<li><img src="https://latex.codecogs.com/png.latex?%5Cbeta=%20%5Crho%20%5Cfrac%7B%5Csigma_2%7D%7B%5Csigma_1%7D"> 。</li>
</ul>
</section>
<section id="向均值回归的影响" class="level3">
<h3 class="anchored" data-anchor-id="向均值回归的影响">向均值回归的影响</h3>
<p>我们假设该处理组无治疗效果，即 <img src="https://latex.codecogs.com/png.latex?%5Cmu_1=%5Cmu_2=%5Cmu"> 且 <img src="https://latex.codecogs.com/png.latex?%5Csigma_1=%5Csigma_2=%5Csigma"> ，则对于特定值 <img src="https://latex.codecogs.com/png.latex?X_1=x_1">，有：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AE(X_2%7CX_1=x_1)%20=%20%5Cmu%20+%20%5Crho%20(x_1-%5Cmu)%0A"></p>
<p>在等号两侧各减去 <img src="https://latex.codecogs.com/png.latex?%5Cmu"> 并取绝对值后，有以下不等式成立：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%7CE(X_2%7CX_1=x_1)%20-%20%5Cmu%7C%20=%20%7C%5Crho%7C%20%7C(x_1-%5Cmu)%7C%20%5Cleq%20%7C(x_1-%5Cmu)%7C%0A"></p>
<p>如此一来，我们可以看到，当 <img src="https://latex.codecogs.com/png.latex?x_1"> 取极端值时，<img src="https://latex.codecogs.com/png.latex?X_2"> 与 <img src="https://latex.codecogs.com/png.latex?%5Cmu"> 之间的差异大体上始终会减小，<img src="https://latex.codecogs.com/png.latex?X_2"> 的期望值会向 <img src="https://latex.codecogs.com/png.latex?%5Cmu"> 靠拢，这也就是著名的向均值回归现象。而在临床试验中，这种自然变化可能被误认为是治疗效果（因为在无处理效应时却看似产生了效果），从而带来偏倚。</p>
<p>上面式子也可以表示为:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%7CE(X_2%7CX_1=x_1)-x_1%7C%20=%20%7C(%5Crho-1)(x_1-%5Cmu)%7C%0A"></p>
<p>可以更加清楚地看到，对于特定的 <img src="https://latex.codecogs.com/png.latex?X_1=x_1">，公式左侧向均值回归所产生的影响通常不为零。只有当 <img src="https://latex.codecogs.com/png.latex?%5Crho=1"> 或者 <img src="https://latex.codecogs.com/png.latex?x_1"> 是一个等于总体均值 <img src="https://latex.codecogs.com/png.latex?%5Cmu"> 的完美样本时，向均值回归的影响消失为零。</p>
</section>
<section id="随机化的作用" class="level3">
<h3 class="anchored" data-anchor-id="随机化的作用">随机化的作用</h3>
<p>接下来，我们开始讨论随机化如何帮助消除向均值回归的偏倚。</p>
<p>由于随机化，使得处理组和对照组的基线测量值的分布相同，即均值均为 <img src="https://latex.codecogs.com/png.latex?%5Cmu">，方差相同。对照组模型为：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%7CE(Y_2%7CY_1=y_1)-y_1%7C%20=%20%7C(%5Crho-1)(y_1-%5Cmu)%7C%0A"></p>
<p>处理组和对照组均会发生向均值回归，治疗效果则通常通过组间差异来评估：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5CDelta%20=%20%7CE(X_2%7CX_1=x_1)-x_1%7C%20-%20%7CE(Y_2%7CY_1=y_1)-y_1%7C%0A"></p>
<p>因为随机化使得 <img src="https://latex.codecogs.com/png.latex?%7CE(X_2%7CX_1=x_1)-x_1%7C%20%5Capprox%20%7CE(Y_2%7CY_1=y_1)-y_1%7C">，向均值回归的影响在 <img src="https://latex.codecogs.com/png.latex?%5CDelta"> 中抵消。若存在处理效应，则经过随机化之后得到的 <img src="https://latex.codecogs.com/png.latex?%5CDelta"> 会更接近于真实的治疗效果，而排除了向均值回归得偏倚。</p>
</section>
<section id="盲法的作用" class="level3">
<h3 class="anchored" data-anchor-id="盲法的作用">盲法的作用</h3>
<p>而对于盲法帮助消除向均值回归的偏倚，主要在于盲法确保在不知道治疗分配情况下的 <img src="https://latex.codecogs.com/png.latex?x_2"> 和 <img src="https://latex.codecogs.com/png.latex?y_2"> 测量的客观性，避免人为放大或掩盖向均值回归的自然变化，从而进一步防止向均值回归被误解为治疗效应。</p>
</section>
<section id="结论" class="level3">
<h3 class="anchored" data-anchor-id="结论">结论</h3>
<p>随机化通过均衡基线消除向均值回归的组间差异，盲法通过客观测量避免主观偏倚，两者共同确保治疗效果估计无偏。</p>


<!-- -->

</section>

 ]]></description>
  <category>RCT</category>
  <category>Statistics</category>
  <category>Methodology</category>
  <category>randomization</category>
  <category>blindness</category>
  <category>regression to the mean</category>
  <guid>https://leslie-lu.github.io/blog/2025/03/08/randomizationandBlindness/</guid>
  <pubDate>Sat, 08 Mar 2025 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img_2025/20250307224129.png" medium="image" type="image/png"/>
</item>
<item>
  <title>全基因组测序GWAS vs. 传统GWAS</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2025/03/11/WGS_GWAS/</link>
  <description><![CDATA[ 





<section id="引言" class="level3">
<h3 class="anchored" data-anchor-id="引言">引言</h3>
<p>全基因组关联分析（Genome-Wide Association Study, GWAS）是遗传学领域研究复杂性状和疾病遗传基础的强大工具。传统GWAS主要依赖SNP芯片技术，而随着测序技术的飞速发展，全基因组测序（Whole-Genome Sequencing, WGS）逐渐成为GWAS研究的新选择。</p>
<p>WGS-GWAS相比传统GWAS到底有哪些优势呢？</p>
</section>
<section id="传统gwas的局限性" class="level3">
<h3 class="anchored" data-anchor-id="传统gwas的局限性">传统GWAS的局限性</h3>
<p>传统GWAS使用SNP芯片技术，虽然在过去取得了巨大成功，但也存在一些明显的局限性：</p>
<ul>
<li><p><strong>变异覆盖有限</strong>：SNP芯片只能检测预先设计的常见变异位点（SNP），无法发现新的或罕见的遗传变异。</p></li>
<li><p><strong>分辨率低</strong>：由于芯片探针数量有限，难以精确定位与疾病相关的具体变异。</p></li>
<li><p><strong>罕见变异检测能力弱</strong>：主要针对常见变异（MAF &gt; 0.05），对罕见变异（MAF &lt; 0.01）的捕捉能力不足。</p></li>
<li><p><strong>因果变异难识别</strong>：通常只能找到与疾病相关的标记SNP，而非真正的致病变异。</p></li>
<li><p><strong>结构变异检测受限</strong>：SNP芯片专注于单核苷酸变异，对插入、删除等结构变异的检测能力较差。</p></li>
<li><p><strong>群体特异性问题</strong>：芯片设计基于特定人群数据，可能不适用于其他群体。</p></li>
<li><p><strong>数据质量依赖技术</strong>：依赖杂交技术，易受杂交误差影响。</p></li>
<li><p><strong>灵活性低</strong>：分析局限于芯片预设的变异类型和范围。</p></li>
</ul>
<p>这些局限性使得传统GWAS在研究复杂疾病的遗传机制时受到一定制约。</p>
</section>
<section id="wgs-gwas的优势" class="level3">
<h3 class="anchored" data-anchor-id="wgs-gwas的优势">WGS-GWAS的优势</h3>
<p>相比之下，使用全基因组测序数据进行GWAS（WGS-GWAS）带来了革命性的改进，以下是其主要优势：</p>
<section id="全面的遗传变异覆盖" class="level4">
<h4 class="anchored" data-anchor-id="全面的遗传变异覆盖">1. <strong>全面的遗传变异覆盖</strong></h4>
<p>WGS能够测定整个基因组的DNA序列，覆盖所有类型的遗传变异，包括SNP、罕见变异以及插入、删除等结构变异。</p>
</section>
<section id="更高的分辨率" class="level4">
<h4 class="anchored" data-anchor-id="更高的分辨率">2. <strong>更高的分辨率</strong></h4>
<p>WGS的分辨率可以精确到单个碱基对级别，帮助研究者更准确地定位与性状或疾病相关的遗传变异，避免传统GWAS中模糊定位的问题。</p>
</section>
<section id="罕见变异的检测能力" class="level4">
<h4 class="anchored" data-anchor-id="罕见变异的检测能力">3. <strong>罕见变异的检测能力</strong></h4>
<p>罕见变异（MAF &lt; 0.01）在复杂疾病中可能扮演重要角色。WGS能够全面捕捉这些低频变异，为研究提供新的突破口。</p>
</section>
<section id="直接识别因果变异" class="level4">
<h4 class="anchored" data-anchor-id="直接识别因果变异">4. <strong>直接识别因果变异</strong></h4>
<p>传统GWAS通常找到的是与疾病关联的标记位点，而WGS可以直接检测潜在的因果变异，提升对疾病机制的理解。</p>
</section>
<section id="结构变异的捕捉" class="level4">
<h4 class="anchored" data-anchor-id="结构变异的捕捉">5. <strong>结构变异的捕捉</strong></h4>
<p>WGS不仅限于SNP，还能检测插入、删除、倒位等结构变异，这些变异可能对性状和疾病有重要影响。</p>
</section>
<section id="群体特异性变异的研究" class="level4">
<h4 class="anchored" data-anchor-id="群体特异性变异的研究">6. <strong>群体特异性变异的研究</strong></h4>
<p>WGS不受芯片设计的群体偏见限制，能发现特定人群特有的变异，为跨人群遗传研究提供支持。</p>
</section>
<section id="更高的数据质量" class="level4">
<h4 class="anchored" data-anchor-id="更高的数据质量">7. <strong>更高的数据质量</strong></h4>
<p>WGS通过直接测序DNA生成数据，相比SNP芯片的杂交技术，减少了技术误差，结果更可靠。</p>
</section>
<section id="分析灵活性" class="level4">
<h4 class="anchored" data-anchor-id="分析灵活性">8. <strong>分析灵活性</strong></h4>
<p>WGS数据包含整个基因组信息，研究者可以根据需要选择不同的变异类型和分析策略，灵活性远超传统GWAS。</p>
</section>
</section>
<section id="take-home-message" class="level3">
<h3 class="anchored" data-anchor-id="take-home-message">Take-Home Message</h3>
<p>总的来说，使用全基因组测序数据进行GWAS在变异覆盖、分辨率、罕见变异检测、因果变异识别、结构变异分析、群体特异性、数据质量和灵活性等方面都显著优于传统GWAS。这些优势使得WGS-GWAS在探索复杂性状和疾病遗传基础时展现出更大的潜力，为精准医学和遗传学研究开辟了新的可能性。</p>


<!-- -->

</section>

 ]]></description>
  <category>GWAS</category>
  <category>bioinformatics</category>
  <category>genetics</category>
  <category>WGS</category>
  <guid>https://leslie-lu.github.io/blog/2025/03/11/WGS_GWAS/</guid>
  <pubDate>Sat, 08 Mar 2025 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img_2025/20250307224129.png" medium="image" type="image/png"/>
</item>
<item>
  <title>配对样本t检验的统计学效率</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2025/03/07/pairedttest/</link>
  <description><![CDATA[ 





<section id="引言" class="level3">
<h3 class="anchored" data-anchor-id="引言">引言</h3>
<p>复习独立样本 t 检验和配对样本 t 检验的统计量，并证明配对样本 t 检验的统计学效率高于独立样本 t 检验。</p>
<p>统计学效率通常指在相同的显著性水平和样本量下，检验检测真实差异（效应量）的能力（即检验功效 power）更高，或者在达到相同power时所需样本量更小。</p>
</section>
<section id="两种t检验的定义与适用场景" class="level3">
<h3 class="anchored" data-anchor-id="两种t检验的定义与适用场景">两种t检验的定义与适用场景</h3>
<ul>
<li><p><strong>配对样本t检验</strong>：适用于同一组个体在两个不同条件下的测量结果，或配对设计的实验。其核心思想是计算每对观测值的差异 <img src="https://latex.codecogs.com/png.latex?D_i%20=%20X_i%20-%20Y_i">，然后检验这些差异的均值是否为零。</p></li>
<li><p><strong>独立样本t检验</strong>：适用于两个独立组的均值比较，例如实验组和对照组的测量结果完全独立。</p></li>
</ul>
</section>
<section id="两种检验的基本公式" class="level3">
<h3 class="anchored" data-anchor-id="两种检验的基本公式">两种检验的基本公式</h3>
<section id="配对样本t检验" class="level4">
<h4 class="anchored" data-anchor-id="配对样本t检验">配对样本t检验</h4>
<p>假设有<img src="https://latex.codecogs.com/png.latex?n">对配对观测值<img src="https://latex.codecogs.com/png.latex?(X_1,%20Y_1),%20(X_2,%20Y_2),%20%5Cldots,%20(X_n,%20Y_n)">，定义差异<img src="https://latex.codecogs.com/png.latex?D_i%20=%20X_i%20-%20Y_i">。目标是检验原假设<img src="https://latex.codecogs.com/png.latex?H_0:%20%5Cmu_D%20=%200">对备择假设<img src="https://latex.codecogs.com/png.latex?H_1:%20%5Cmu_D%20%5Cneq%200">。统计量为：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0At%20=%20%5Cfrac%7B%5Cbar%7BD%7D%7D%7Bs_D%20/%20%5Csqrt%7Bn%7D%7D%0A"></p>
<p>其中：</p>
<ul>
<li><p><img src="https://latex.codecogs.com/png.latex?%5Cbar%7BD%7D%20=%20%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi=1%7D%5En%20D_i"> 是差异的样本均值，</p></li>
<li><p><img src="https://latex.codecogs.com/png.latex?s_D%20=%20%5Csqrt%7B%5Cfrac%7B1%7D%7Bn-1%7D%20%5Csum_%7Bi=1%7D%5En%20(D_i%20-%20%5Cbar%7BD%7D)%5E2%7D"> 是差异的样本标准差，</p></li>
<li><p>自由度为<img src="https://latex.codecogs.com/png.latex?n%20-%201">。</p></li>
</ul>
</section>
<section id="独立样本t检验" class="level4">
<h4 class="anchored" data-anchor-id="独立样本t检验">独立样本t检验</h4>
<p>假设有两个独立样本，样本1为<img src="https://latex.codecogs.com/png.latex?X_1,%20X_2,%20%5Cldots,%20X_%7Bn_1%7D">，样本2为<img src="https://latex.codecogs.com/png.latex?Y_1,%20Y_2,%20%5Cldots,%20Y_%7Bn_2%7D">，均值分别为<img src="https://latex.codecogs.com/png.latex?%5Cmu_X">和<img src="https://latex.codecogs.com/png.latex?%5Cmu_Y">。目标是检验<img src="https://latex.codecogs.com/png.latex?H_0:%20%5Cmu_X%20=%20%5Cmu_Y">对<img src="https://latex.codecogs.com/png.latex?H_1:%20%5Cmu_X%20%5Cneq%20%5Cmu_Y">。统计量为：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0At%20=%20%5Cfrac%7B%5Cbar%7BX%7D%20-%20%5Cbar%7BY%7D%7D%7Bs_p%20%5Csqrt%7B%5Cfrac%7B1%7D%7Bn_1%7D%20+%20%5Cfrac%7B1%7D%7Bn_2%7D%7D%7D%0A"></p>
<p>其中：</p>
<ul>
<li><p><img src="https://latex.codecogs.com/png.latex?%5Cbar%7BX%7D"> 和 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7BY%7D"> 分别是两个样本的均值，</p></li>
<li><p><img src="https://latex.codecogs.com/png.latex?s_p%5E2%20=%20%5Cfrac%7B(n_1%20-%201)s_X%5E2%20+%20(n_2%20-%201)s_Y%5E2%7D%7Bn_1%20+%20n_2%20-%202%7D"> 是合并方差（假设两组方差相等），</p></li>
<li><p>自由度为<img src="https://latex.codecogs.com/png.latex?n_1%20+%20n_2%20-%202">。</p></li>
</ul>
</section>
</section>
<section id="统计学效率的比较框架" class="level3">
<h3 class="anchored" data-anchor-id="统计学效率的比较框架">统计学效率的比较框架</h3>
<p>为公平比较两种检验的效率，我们假设：</p>
<ul>
<li><p>总观测次数相同。例如，配对样本t检验有<img src="https://latex.codecogs.com/png.latex?n">对（共<img src="https://latex.codecogs.com/png.latex?2n">个观测值），独立样本t检验有两个各有<img src="https://latex.codecogs.com/png.latex?n">个观测值的独立样本（共<img src="https://latex.codecogs.com/png.latex?2n">个观测值）。</p></li>
<li><p>配对样本中的<img src="https://latex.codecogs.com/png.latex?X_i">和<img src="https://latex.codecogs.com/png.latex?Y_i">之间存在相关性，相关系数为<img src="https://latex.codecogs.com/png.latex?%5Crho">（通常<img src="https://latex.codecogs.com/png.latex?%5Crho%20%3E%200">，即非负相关性，因为配对设计常用于控制个体差异）。</p></li>
<li><p>两组的总体方差均为<img src="https://latex.codecogs.com/png.latex?%5Csigma%5E2">，效应量（均值差异）为<img src="https://latex.codecogs.com/png.latex?%5Cdelta">。</p></li>
</ul>
<p>统计学效率的关键在于估计量的方差和检验效能的比较。我们通过计算估计量的方差和非中心参数来证明配对样本t检验的优势。</p>
</section>
<section id="估计量的方差比较" class="level3">
<h3 class="anchored" data-anchor-id="估计量的方差比较">估计量的方差比较</h3>
<section id="配对样本t检验-1" class="level4">
<h4 class="anchored" data-anchor-id="配对样本t检验-1">配对样本t检验</h4>
<p>配对差异<img src="https://latex.codecogs.com/png.latex?D_i%20=%20X_i%20-%20Y_i">的方差为：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Ctext%7BVar%7D(D_i)%20=%20%5Ctext%7BVar%7D(X_i)%20+%20%5Ctext%7BVar%7D(Y_i)%20-%202%20%5Ctext%7BCov%7D(X_i,%20Y_i)%0A"></p>
<p>假设<img src="https://latex.codecogs.com/png.latex?%5Ctext%7BVar%7D(X_i)%20=%20%5Ctext%7BVar%7D(Y_i)%20=%20%5Csigma%5E2">，且<img src="https://latex.codecogs.com/png.latex?%5Ctext%7BCov%7D(X_i,%20Y_i)%20=%20%5Crho%20%5Csigma%5E2">，则：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Ctext%7BVar%7D(D_i)%20=%202%20%5Csigma%5E2%20(1%20-%20%5Crho)%0A"></p>
<p>差异均值<img src="https://latex.codecogs.com/png.latex?%5Cbar%7BD%7D">的方差为：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Ctext%7BVar%7D(%5Cbar%7BD%7D)%20=%20%5Cfrac%7B%5Ctext%7BVar%7D(D_i)%7D%7Bn%7D%20=%20%5Cfrac%7B2%20%5Csigma%5E2%20(1%20-%20%5Crho)%7D%7Bn%7D%0A"></p>
<p>标准误为：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Ctext%7BSE%7D(%5Cbar%7BD%7D)%20=%20%5Csqrt%7B%5Cfrac%7B2%20%5Csigma%5E2%20(1%20-%20%5Crho)%7D%7Bn%7D%7D%0A"></p>
</section>
<section id="独立样本t检验-1" class="level4">
<h4 class="anchored" data-anchor-id="独立样本t检验-1">独立样本t检验</h4>
<p>对于两个各有<img src="https://latex.codecogs.com/png.latex?n">个观测值的独立样本，<img src="https://latex.codecogs.com/png.latex?%5Cbar%7BX%7D%20-%20%5Cbar%7BY%7D">的方差为：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Ctext%7BVar%7D(%5Cbar%7BX%7D%20-%20%5Cbar%7BY%7D)%20=%20%5Ctext%7BVar%7D(%5Cbar%7BX%7D)%20+%20%5Ctext%7BVar%7D(%5Cbar(Y))%20=%20%5Cfrac%7B2%20%5Csigma%5E2%7D%7Bn%7D%0A"></p>
<p>标准误为：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Ctext%7BSE%7D(%5Cbar%7BX%7D%20-%20%5Cbar%7BY%7D)%20=%20%5Csqrt%7B%5Cfrac%7B2%20%5Csigma%5E2%7D%7Bn%7D%7D%0A"></p>
</section>
<section id="方差比较" class="level4">
<h4 class="anchored" data-anchor-id="方差比较">方差比较</h4>
<ul>
<li><p>配对样本t检验的方差：<img src="https://latex.codecogs.com/png.latex?%5Cfrac%7B2%20%5Csigma%5E2%20(1%20-%20%5Crho)%7D%7Bn%7D"></p></li>
<li><p>独立样本t检验的方差：<img src="https://latex.codecogs.com/png.latex?%5Cfrac%7B2%20%5Csigma%5E2%7D%7Bn%7D"></p></li>
</ul>
<p>当<img src="https://latex.codecogs.com/png.latex?%5Crho%20%3E%200">时，<img src="https://latex.codecogs.com/png.latex?1%20-%20%5Crho%20%3C%201">，因此：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cfrac%7B2%20%5Csigma%5E2%20(1%20-%20%5Crho)%7D%7Bn%7D%20%3C%20%5Cfrac%7B2%20%5Csigma%5E2%7D%7Bn%7D%0A"></p>
<p>这表明配对样本t检验的估计量<img src="https://latex.codecogs.com/png.latex?%5Cbar%7BD%7D">比独立样本t检验的估计量<img src="https://latex.codecogs.com/png.latex?%5Cbar%7BX%7D%20-%20%5Cbar%7BY%7D">具有更小的方差。两者的检验统计量分子相同（即效应量），但配对样本t检验的分母（标准误）更小，估计越精确，检验越有可能检测到真实的差异，相应地更容易拒绝原假设，因此具有更高的power，统计学效率更高。</p>
</section>
</section>
<section id="power与非中心参数" class="level3">
<h3 class="anchored" data-anchor-id="power与非中心参数">power与非中心参数</h3>
<p>power 是检验在备择假设为真时拒绝原假设的概率，power 与统计量的非中心参数相关。非中心参数越大，power 越高。</p>
<section id="配对样本t检验-2" class="level4">
<h4 class="anchored" data-anchor-id="配对样本t检验-2">配对样本t检验</h4>
<p>在备择假设<img src="https://latex.codecogs.com/png.latex?%5Cmu_D%20=%20%5Cdelta">下，非中心参数为：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Clambda_p%20=%20%5Cfrac%7B%5Cdelta%7D%7B%5Ctext%7BSE%7D(%5Cbar%7BD%7D)%7D%20=%20%5Cfrac%7B%5Cdelta%7D%7B%5Csigma%7D%20%5Csqrt%7B%5Cfrac%7Bn%7D%7B2%20(1%20-%20%5Crho)%7D%7D%0A"></p>
</section>
<section id="独立样本t检验-2" class="level4">
<h4 class="anchored" data-anchor-id="独立样本t检验-2">独立样本t检验</h4>
<p>在备择假设<img src="https://latex.codecogs.com/png.latex?%5Cmu_X%20-%20%5Cmu_Y%20=%20%5Cdelta">下，非中心参数为：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Clambda_i%20=%20%5Cfrac%7B%5Cdelta%7D%7B%5Ctext%7BSE%7D(%5Cbar%7BX%7D%20-%20%5Cbar%7BY%7D)%7D%20=%20%5Cfrac%7B%5Cdelta%7D%7B%5Csigma%7D%20%5Csqrt%7B%5Cfrac%7Bn%7D%7B2%7D%7D%0A"></p>
</section>
<section id="非中心参数比较" class="level4">
<h4 class="anchored" data-anchor-id="非中心参数比较">非中心参数比较</h4>
<p>比较<img src="https://latex.codecogs.com/png.latex?%5Clambda_p">和<img src="https://latex.codecogs.com/png.latex?%5Clambda_i">：</p>
<ul>
<li><p><img src="https://latex.codecogs.com/png.latex?%5Clambda_p%20=%20%5Cfrac%7B%5Cdelta%7D%7B%5Csigma%7D%20%5Csqrt%7B%5Cfrac%7Bn%7D%7B2%20(1%20-%20%5Crho)%7D%7D"></p></li>
<li><p><img src="https://latex.codecogs.com/png.latex?%5Clambda_i%20=%20%5Cfrac%7B%5Cdelta%7D%7B%5Csigma%7D%20%5Csqrt%7B%5Cfrac%7Bn%7D%7B2%7D%7D"></p></li>
</ul>
<p>当<img src="https://latex.codecogs.com/png.latex?%5Crho%20%3E%200">时，<img src="https://latex.codecogs.com/png.latex?%5Clambda_p%20%3E%20%5Clambda_i">，表明配对样本t检验在相同条件下具有更高的 power。</p>
</section>
</section>
<section id="结论" class="level2">
<h2 class="anchored" data-anchor-id="结论">结论</h2>
<p>通过估计量方差和非中心参数的比较，证明了当配对观测值正相关时，配对样本t检验的统计学效率高于独立样本t检验。这也是为什么在实验设计中，当可以控制个体差异时，优先选择配对设计的原因。</p>


<!-- -->

</section>

 ]]></description>
  <category>RCT</category>
  <category>Statistics</category>
  <category>Hypothesis Testing</category>
  <category>t-test</category>
  <category>power analysis</category>
  <guid>https://leslie-lu.github.io/blog/2025/03/07/pairedttest/</guid>
  <pubDate>Fri, 07 Mar 2025 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img_2025/statistical-power-chart.png" medium="image" type="image/png"/>
</item>
<item>
  <title>临床试验中基线数据p值真的有意义吗？</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2025/03/03/Table1inRCT/</link>
  <description><![CDATA[ 





<p>在临床试验的结果表格中，你是否经常见到<strong>患者人口学与基线特征</strong>的统计表，附带一堆 <code>p</code> 值？这些 <code>p</code> 值到底在验证什么？是证明随机化的成功，还是暴露试验设计的漏洞？</p>
<p>这里，我们试图用一篇文章来讨论下这个问题。</p>
<section id="随机化的完美幻觉基线表格里的-p-值" class="level3">
<h3 class="anchored" data-anchor-id="随机化的完美幻觉基线表格里的-p-值">随机化的完美幻觉：基线表格里的 p 值</h3>
<p>临床试验的核心是随机化分配（Randomization），它试图通过<strong>不可预测</strong>的分组消除混杂因素。然而，许多论文在结果部分展示基线数据时，会针对性别、年龄等变量计算治疗组间的 p 值。这看似严谨的操作，实则暗藏争议。</p>
<p>我们争议的焦点在于：</p>
<section id="无意义论" class="level4">
<h4 class="anchored" data-anchor-id="无意义论">1. 无意义论</h4>
<p>如果试验已声明进行了<strong>随机化</strong>，则所有基线差异（无处理效应）的 p 值本质上反映的是随机误差，而非真实效应。任何由极小 p 值提示的统计显著性都是第一类错误，毫无意义。例如，在 100 次基线比较中，即使完全随机，按 5% 显著性水平也会出现 5 次<strong>假阳性</strong>。</p>
</section>
<section id="验真派" class="level4">
<h4 class="anchored" data-anchor-id="验真派">2. 验真派</h4>
<p>认为 p 值可用于验证随机化是否真实执行。比如，若基线变量显示系统性差异（如年龄显著不均衡），可能暗示分配过程存在人为干扰。</p>
</section>
</section>
<section id="当组间均衡性遭遇挑战何时该调整协变量" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="当组间均衡性遭遇挑战何时该调整协变量">当组间均衡性遭遇挑战：何时该调整协变量？</h3>
<p>随机化的理想情况是治疗组间基线完全均衡，但现实往往骨感。当某个预后因素（如疾病严重程度）不均衡时，该如何处理？这里，我们一般的逻辑是：</p>
<section id="不调整也能成立" class="level4">
<h4 class="anchored" data-anchor-id="不调整也能成立">1. 不调整也能成立</h4>
<p>即使基线不均衡，对于真正的随机化试验，我们仍然可以相信在没有纳入任何协变量的情况下，处理效应主分析的直接结果。无论观察到的处理与协变量之间的关联性如何，主效应分析的结果仍然是有效的。从这个角度看，基线表格里的 p 值是毫无必要的。</p>
</section>
<section id="调整会更高效" class="level4">
<h4 class="anchored" data-anchor-id="调整会更高效">2. 调整会更高效</h4>
<p>而另一方面，若某变量与结局强相关且组间不均衡，纳入协变量分析（如 <code>ANCOVA</code> 模型）可减少误差、提升统计效能。</p>
</section>
<section id="实战指南如何科学设计基线表格" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="实战指南如何科学设计基线表格">实战指南：如何科学设计基线表格？</h4>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img_2025/20250303165121.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">NEJM</figcaption>
</figure>
</div>
<p>这里，我们给研究者的具体建议是：</p>
<ul>
<li><p>简化p值展示：随机化试验中，基线p值无必要，直接呈现变量分布即可。</p></li>
<li><p>关注临床意义：若关键变量（如年龄、疾病分期）组间差异超过10%，需讨论是否调整分析模型。</p></li>
</ul>
</section>
</section>
<section id="结语回归医学研究的本质" class="level3">
<h3 class="anchored" data-anchor-id="结语回归医学研究的本质">结语：回归医学研究的本质</h3>
<p>临床试验的终极目标是评估治疗效应，而非追求表格的 <code>完美对齐</code>。基线可比性应靠科学设计保障，而非事后修补。当一篇论文用大量 p 值自证清白时，我们或许更该追问：它的随机化是否真正无懈可击？分配过程是否足够盲态？毕竟，在医学进步的征途上，随机化需要的是技术硬核，而非统计学 p 值。</p>


<!-- -->

</section>

 ]]></description>
  <category>RCT</category>
  <category>Table 1</category>
  <category>Baseline</category>
  <category>p value</category>
  <guid>https://leslie-lu.github.io/blog/2025/03/03/Table1inRCT/</guid>
  <pubDate>Mon, 03 Mar 2025 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img_2025/20250303165121.png" medium="image" type="image/png"/>
</item>
<item>
  <title>Zotero + OneDrive + DeepSeek：构建个人文献阅读管理系统</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2025/02/17/zotero_onedrive_deepseek/</link>
  <description><![CDATA[ 





<p>最近 DeepSeek 大火，看到有人分享用它来阅读管理文献，非常好用。我自己一直用的是 EndNote，但是似乎不支持接入 Deepseek，所以我决定暂时转投 Zotero 阵营，实现文献管理和阅读的一体化。</p>
<section id="zotero-onedrive" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="zotero-onedrive">Zotero + OneDrive</h3>
<p>Zotero 是一个开源的文献管理工具，但是它有一个缺点，只有 300MB 的免费存储空间。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://raw.githubusercontent.com/Leslie-Lu/WeChatOfficialAccount/main/img_2025/20250217003538.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">Storage</figcaption>
</figure>
</div>
<p>我之前的 EndNote 没有存储空间限制的焦虑，为了防止以后 Zotero 的存储空间不够用，我决定顺手把 Zotero 的文献库放到 OneDrive 云上，这样就可以在不同设备上同步，且不适用 Zotero 自带的存储空间。</p>
<p>对于 Zotero 放到云上的设置，可以参考：</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://raw.githubusercontent.com/Leslie-Lu/WeChatOfficialAccount/main/img_2025/20250217004027.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">Sync</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://raw.githubusercontent.com/Leslie-Lu/WeChatOfficialAccount/main/img_2025/20250217004125.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">Files and Folders</figcaption>
</figure>
</div>
<p>只需要将 Zotero 的 Storage 文件夹软链接到 OneDrive 云上，然后在 Zotero 的设置中设置数据文件夹的路径即可。</p>
<p>这样，对于有 Microsoft 365 家庭版订阅的用户，就可以免费使用 1TB 的 OneDrive 存储空间来存储 Zotero 的文献库了。</p>
</section>
<section id="zotero-deepseek" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="zotero-deepseek">Zotero + DeepSeek</h3>
<p>DeepSeek 最近已经火到不需要我再多做介绍了。Deepseek 之前是给每位用户送了 10元 的 API：</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://raw.githubusercontent.com/Leslie-Lu/WeChatOfficialAccount/main/img_2025/20250217004626.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">DeepSeek</figcaption>
</figure>
</div>
<p>但是是一个月的有效期，且目前 DeepSeek 的 API 已经无法购买了。我们转向使用硅基流动提供的 API，它也赠送了 14元：</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://raw.githubusercontent.com/Leslie-Lu/WeChatOfficialAccount/main/img_2025/20250217005346.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">SiliconCloud</figcaption>
</figure>
</div>
<p>那接下来就是在 Zotero 中设置硅基流动中模型的 API 了，这里我们选择的是模型 deepseek-ai/DeepSeek-R1-Distill-Qwen-32B：</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://raw.githubusercontent.com/Leslie-Lu/WeChatOfficialAccount/main/img_2025/20250217005652.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">DeepSeek-R1-Distill-Qwen-32B</figcaption>
</figure>
</div>
<p>浏览下它的 API 文档，我们在 Zotero 的 Awesome GPT 插件中设置好 API 即可，这个插件可以通过 GitHub 下载：</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://raw.githubusercontent.com/Leslie-Lu/WeChatOfficialAccount/main/img_2025/20250217005852.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">API</figcaption>
</figure>
</div>
<p>通过了 test 之后（我这里图片上的 error 可以忽略），我们就可以使用 DeepSeek 来阅读文献了。</p>
<p>首先必须读一篇经典文献：Attention is All You Need。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://raw.githubusercontent.com/Leslie-Lu/WeChatOfficialAccount/main/img_2025/88c471b106c67bcb6bca973e2a5803a.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">Transformer</figcaption>
</figure>
</div>
<p>感兴趣的同学可以参考我们的教程开始使用 DeepSeek 助力自己的科研了。</p>


<!-- -->

</section>

 ]]></description>
  <category>zotero</category>
  <category>onedrive</category>
  <category>deepseek</category>
  <category>tools</category>
  <guid>https://leslie-lu.github.io/blog/2025/02/17/zotero_onedrive_deepseek/</guid>
  <pubDate>Mon, 17 Feb 2025 00:00:00 GMT</pubDate>
  <media:content url="https://raw.githubusercontent.com/Leslie-Lu/WeChatOfficialAccount/main/img_2025/88c471b106c67bcb6bca973e2a5803a.png" medium="image" type="image/png"/>
</item>
<item>
  <title>SAS 生存分析模拟</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2025/02/13/simulating_survival_models/</link>
  <description><![CDATA[ 





<p>生存分析（Survival Analysis）是统计学中用于分析事件发生时间的研究方法。在生存分析中，常常使用比例风险模型（Proportional Hazards Models），例如 Cox 回归模型，来探索影响生存时间的因素。</p>
<p>这里，我们将深入解析如何使用 SAS 进行生存分析模拟，特别是如何生成符合特定假设的生存数据，并使用 Cox 回归模型进行分析。</p>
<section id="生存数据模拟" class="level3">
<h3 class="anchored" data-anchor-id="生存数据模拟">1. 生存数据模拟</h3>
<p>在生存分析中，数据的模拟是研究者进行仿真实验、理解模型行为以及验证方法的重要步骤。以下代码展示了如何使用 SAS 模拟符合指数分布（Exponential Distribution）和 Weibull 分布的生存数据。</p>
<section id="指数分布与-cox-回归模型" class="level4">
<h4 class="anchored" data-anchor-id="指数分布与-cox-回归模型">指数分布与 Cox 回归模型</h4>
<p>指数分布是生存数据中常见的一种分布模型，尤其适用于模拟没有明显时间变化的基线风险（constant baseline hazard），其形式为：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Clambda(t)%20=%20%5Clambda_0%0A"></p>
<p>其中，<img src="https://latex.codecogs.com/png.latex?%5Clambda_0"> 是基线风险，它在整个时间范围内保持不变。对于 Cox 回归模型来说，基线风险函数并未指定，而是通过比例风险的假设，估计与协变量相关的风险比（hazard ratio）。</p>
<pre class="{SAS}"><code>%macro RandExp(sigma);
    ((&amp;sigma) * rand("Exponential"))
%mend;</code></pre>
<p>在这段代码中，我们定义了一个宏 RandExp，它用于生成指数分布的随机数。<code>rand("Exponential")</code> 生成一个符合指数分布的随机数，而 &amp;sigma 为分布的尺度参数。这里我们通过宏将其封装，方便后续的调用。</p>
<p>接下来，我们创建一个包含100个观测值的数据集 PHData，该数据集模拟了一个包含固定效应（例如协变量 x1 和 x2）和随机事件时间（t）的数据集。</p>
<pre class="{SAS}"><code>do i = 1 to &amp;N;
        xx1{i} = rand("Normal"); xx2{i} = rand("Normal");
    end;
    baseHazardRate = 0.002; /* 事件发生的基线风险 */
    censorRate = 0.001; /* 被删失（censoring）的风险 */
    do i = 1 to &amp;N;
        x1 = xx1{i}; x2 = xx2{i};
        eta = -2*x1 + 1*x2; /* 线性预测变量 */
        tEvent = %RandExp( 1/(baseHazardRate * exp(eta)) ); /* 根据线性预测模拟事件时间 */
        c = %RandExp( 1/censorRate ); /* 被删失时间 */
        t = min(tEvent, c); /* 事件时间或删失时间 */
        censored = (c &lt; tEvent); /* 是否删失的指示变量 */
        output;
    end;</code></pre>
<p>在这部分代码中，我们首先通过 rand(“Normal”) 生成了两个标准正态分布的随机变量 x1 和 x2 作为协变量。然后，我们使用这些协变量和基线风险来计算事件的时间（tEvent）和删失时间（c）。每个观察值的事件时间 t 是事件时间和删失时间中的较小值，而 censored 变量则指示该观测是否为删失。</p>
</section>
</section>
<section id="使用cox回归模型进行分析" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="使用cox回归模型进行分析">2. 使用Cox回归模型进行分析</h3>
<p>生成生存数据后，我们可以使用 SAS中的 PHREG 拟合比例风险模型。在我们的例子中，我们将使用 Cox 回归模型来估计协变量 x1 和 x2 对生存时间的影响。</p>
<pre class="{SAS}"><code>ods graphics on;
proc phreg data=PHData plots(overlay CL)= (survival);
    model t*censored(1)= x1-x2;
    ods select CensoredSummary ParameterEstimates
        ReferenceSet SurvivalPlot;
run;</code></pre>
<p>这里运行结果将提供Cox回归模型的参数估计，包括协变量的风险比（Hazard Ratios），以及不同协变量条件下的生存函数图。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://raw.githubusercontent.com/Leslie-Lu/WeChatOfficialAccount/main/img_2025/20250213224227.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">参数估计</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://raw.githubusercontent.com/Leslie-Lu/WeChatOfficialAccount/main/img_2025/20250213224310.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">生存曲线</figcaption>
</figure>
</div>
<p>完整代码已经上传至<a href="https://mp.weixin.qq.com/s/4IR-KMAZ-q2VbI0Fz4fYRg">星球</a>，感兴趣的同学可以自行查看。</p>


<!-- -->

</section>

 ]]></description>
  <category>sas</category>
  <category>cox</category>
  <category>ph</category>
  <category>survival</category>
  <category>simulation</category>
  <guid>https://leslie-lu.github.io/blog/2025/02/13/simulating_survival_models/</guid>
  <pubDate>Thu, 13 Feb 2025 00:00:00 GMT</pubDate>
  <media:content url="https://raw.githubusercontent.com/Leslie-Lu/WeChatOfficialAccount/main/img_2025/20250213224310.png" medium="image" type="image/png"/>
</item>
<item>
  <title>一文读懂 Dosage 文件</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2025/02/11/dosage/</link>
  <description><![CDATA[ 





<p>在基因组关联分析（GWAS）中，基因型数据的准确性和高效处理是核心挑战，准确的基因型数据是发现遗传变异与性状关联的关键。传统方法使用硬判型（Hard Call）数据（如 0/1/2 编码），但随着测序技术的发展，Dosage 文件因其对基因型不确定性的量化能力，逐渐成为 GWAS 分析的新标准。而 <a href="https://mp.weixin.qq.com/s/pCfu0tJxvvRIHqtbK9eSug">SAIGE</a> 作为混合模型 GWAS 的明星工具，对 Dosage 文件的支持更是备受关注。</p>
<section id="dosage文件基因型数据的概率化革命" class="level3">
<h3 class="anchored" data-anchor-id="dosage文件基因型数据的概率化革命">Dosage文件：基因型数据的概率化革命</h3>
<section id="什么是-dosage-文件" class="level4">
<h4 class="anchored" data-anchor-id="什么是-dosage-文件">1.1 什么是 Dosage 文件？</h4>
<p>Dosage 文件记录的是每个样本在某个位点的<strong>剂量</strong>（Dosage），即基因型为杂合（如 0/1）或风险等位基因（如 1/1）的期望值（Expected Value）。其取值范围通常为 0.0~2.0，表示从<em>无风险等位基因</em>到<em>两个风险等位基因</em>的概率分布。</p>
<p>数学定义：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0ADosage%20=%20P(0/0)%20%5Ctimes%200%20+%20P(0/1)%20%5Ctimes%201%20+%20P(1/1)%20%5Ctimes%202%0A"></p>
<p>其中 <img src="https://latex.codecogs.com/png.latex?P"> 表示基因型的概率。基于这些概率，可以计算出 dosage 值，也就是参考等位基因的期望拷贝数。</p>
</section>
<section id="dosage-vs-hard-call为什么更科学" class="level4">
<h4 class="anchored" data-anchor-id="dosage-vs-hard-call为什么更科学">1.2 Dosage vs Hard Call：为什么更科学？</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>对比维度</th>
<th>Hard Call</th>
<th>Dosage</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>数据本质</td>
<td>离散（0/1/2）</td>
<td>连续（0.0~2.0）</td>
</tr>
<tr class="even">
<td>低深度测序处理</td>
<td>易丢失信息（强制二分类）</td>
<td>保留不确定性（概率加权）</td>
</tr>
<tr class="odd">
<td>统计功效</td>
<td>可能低估关联信号</td>
<td>提高检测灵敏度</td>
</tr>
</tbody>
</table>
<p>举个例子，若某位点的测序深度低，Hard Call 可能强制判为 0/0，而 Dosage 可记录为 0.2（更接近真实生物学状态）。</p>
</section>
</section>
<section id="saige为何偏爱-dosage-文件" class="level3">
<h3 class="anchored" data-anchor-id="saige为何偏爱-dosage-文件">SAIGE为何偏爱 Dosage 文件？</h3>
<p>SAIGE采用基于混合线性模型（Mixed Linear Model, MLM）的算法，通过引入<a href="https://mp.weixin.qq.com/s/QF-0DEPZkD3MeHn3vkqWMg">遗传关系矩阵（GRM）</a>控制群体结构。而 Dosage 文件的优势在于，其连续型变量可直接作为协变量输入，避免离散化导致的信息损失，提高模型对微弱信号的捕捉能力。相比于简单的 hard call，dosage 数据充分利用了 imputation 的概率信息，使得关联分析更敏感、更准确。不过需要注意的是，dosage 文件在使用前必须经过严格的质量控制，确保 imputation 的准确性，以避免低质量数据对分析结果的干扰。</p>
</section>
<section id="dosage-文件的生成与使用" class="level3">
<h3 class="anchored" data-anchor-id="dosage-文件的生成与使用">Dosage 文件的生成与使用</h3>
<p>生成 Dosage 文件的常用工具有 PLINK、BEAGLE、IMPUTE2 等。以 PLINK 为例，通过以下命令将 VCF 文件转换为 Dosage 文件：</p>
<pre class="{bash}"><code># 从VCF转换为Dosage格式
plink --vcf input.vcf --dosage DS --write-snplist --out output</code></pre>
<p>生成的 output.dosage 文件格式如下：</p>
<pre class="{bash}"><code>CHR SNP POS A1 A2 DOSAGE_1 DOSAGE_2 ... DOSAGE_N
1 rs123 1000 A T 0.98 1.76 ... 0.02</code></pre>
</section>
<section id="take-home-message" class="level3">
<h3 class="anchored" data-anchor-id="take-home-message">Take-Home Message</h3>
<p>dosage 文件作为基因型 imputation 的产物，在 GWAS 分析中发挥着至关重要的作用。通过充分利用 dosage 数据中的概率信息，SAIGE 等工具能够更准确地捕捉到基因型与性状之间的微妙关联，为我们揭示遗传机制提供了有力支持。在数据质量和格式得到充分保障的前提下，正确使用 dosage 文件将大大提升 GWAS 分析的精度和效率。</p>


<!-- -->

</section>

 ]]></description>
  <category>genetics</category>
  <category>bioinformatics</category>
  <category>dosage</category>
  <category>saige</category>
  <guid>https://leslie-lu.github.io/blog/2025/02/11/dosage/</guid>
  <pubDate>Tue, 11 Feb 2025 00:00:00 GMT</pubDate>
  <media:content url="https://raw.githubusercontent.com/Leslie-Lu/WeChatOfficialAccount/main/img_2025/20250211205010.png" medium="image" type="image/png"/>
</item>
<item>
  <title>祝大家新年快乐！</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2025/01/28/red_packet/</link>
  <description><![CDATA[ 





<p>大家除夕快乐，感谢大家一直以来对我们公众号的关注和支持！</p>
<p>新的一年，希望我们继续一起加油进步，共同深度求索更多有价值的内容！</p>


<!-- -->


 ]]></description>
  <category>r</category>
  <category>tools</category>
  <category>red packet</category>
  <category>happy new year</category>
  <guid>https://leslie-lu.github.io/blog/2025/01/28/red_packet/</guid>
  <pubDate>Tue, 28 Jan 2025 00:00:00 GMT</pubDate>
  <media:content url="https://raw.githubusercontent.com/Leslie-Lu/WeChatOfficialAccount/main/2025_happy_newyear.png" medium="image" type="image/png"/>
</item>
<item>
  <title>公众号智能回复功能终于上线</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2025/01/21/intelligent_reply/</link>
  <description><![CDATA[ 





<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://raw.githubusercontent.com/Leslie-Lu/WeChatOfficialAccount/main/img_2025/20250120204739.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">公众号智能回复</figcaption>
</figure>
</div>
<p>腾讯终于在公众号后台上线了智能回复功能。</p>
<p>公众号以往发表的文章成为 AI 学习的知识库，用于自动回复用户在后台提出的问题，这也是鹅厂的腾讯元器做的事情。不过，我自己试了一下，鹅厂大模型效果一般，有时候回答的问题不是很准确，还是需要人工干预。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://raw.githubusercontent.com/Leslie-Lu/WeChatOfficialAccount/main/img_2025/155cfc03b2e6f4eea482f500c46d3f9.jpg" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">test</figcaption>
</figure>
</div>
<p>欢迎大家后台体验。</p>


<!-- -->


 ]]></description>
  <category>r</category>
  <category>tools</category>
  <category>red packet</category>
  <guid>https://leslie-lu.github.io/blog/2025/01/21/intelligent_reply/</guid>
  <pubDate>Tue, 21 Jan 2025 00:00:00 GMT</pubDate>
  <media:content url="https://raw.githubusercontent.com/Leslie-Lu/WeChatOfficialAccount/main/img_2025/20250120204739.png" medium="image" type="image/png"/>
</item>
<item>
  <title>新年红包封面来了</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2025/01/20/red_packet/</link>
  <description><![CDATA[ 





<p><a href="https://mp.weixin.qq.com/s/uTjQbwg2AVU4ZwhiGHboOQ">一年一度的事情</a>，用 R 几行代码简单画个微信红包封面，一共发放 6000 个，感谢大家一直以来对我们公众号的关注和支持！</p>
<p><a href="https://mp.weixin.qq.com/s/tsVJsqrzOJXZhmv_PhraGA">请进入公众号文章领取</a>。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://raw.githubusercontent.com/Leslie-Lu/WeChatOfficialAccount/main/2025_happy_newyear.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">2025_happy_newyear</figcaption>
</figure>
</div>
<p>用了 magick，ggplot2，showtext 几个包，代码直接已经放进了<a href="https://mp.weixin.qq.com/s/4IR-KMAZ-q2VbI0Fz4fYRg">星球</a>里，感兴趣的同学可以去看看。</p>


<!-- -->


 ]]></description>
  <category>r</category>
  <category>tools</category>
  <category>red packet</category>
  <guid>https://leslie-lu.github.io/blog/2025/01/20/red_packet/</guid>
  <pubDate>Mon, 20 Jan 2025 00:00:00 GMT</pubDate>
  <media:content url="https://raw.githubusercontent.com/Leslie-Lu/WeChatOfficialAccount/main/2025_happy_newyear.png" medium="image" type="image/png"/>
</item>
<item>
  <title>R 中项目环境管理</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2025/01/19/renv_in_r/</link>
  <description><![CDATA[ 





<p>在 R 语言的项目开发和数据分析过程中，管理包的依赖关系一直是一个挑战。每个项目可能依赖不同版本的R包，而不同项目间的包依赖往往互相冲突。为了避免这些问题，renv 包应运而生，其相当于 python 中的 virtualenv，帮助 R 用户高效地管理和隔离项目的依赖环境。</p>
<p>这里，我们将介绍 renv 包的基本功能及使用方法，帮助大家更好地管理 R 项目的包依赖。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://rstudio.github.io/renv/articles/renv.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">renv</figcaption>
</figure>
</div>
<section id="什么是-renv-包" class="level3">
<h3 class="anchored" data-anchor-id="什么是-renv-包">什么是 renv 包</h3>
<p>renv（R Environment）是一个用于管理 R 项目环境的工具。它允许为每个 R 项目创建一个独立的虚拟环境，从而确保每个项目拥有独立且隔离的 R 包依赖。通过使用 renv，我们可以避免包版本冲突，并且可以轻松地复制和共享项目环境，确保项目在不同的机器或不同的时间点上能够重现。</p>
</section>
<section id="renv-的核心优势" class="level3">
<h3 class="anchored" data-anchor-id="renv-的核心优势">renv 的核心优势</h3>
<ul>
<li>隔离环境：每个项目有独立的库，包的版本不会相互干扰。即使我们在一个项目中更新了某个包的版本，其他项目依然可以使用旧版本。</li>
<li>项目可重现性：通过保存和共享项目的依赖信息（如包的版本），其他开发者可以使用相同的环境重新创建项目，确保研究的可重现性。</li>
<li>便捷的依赖管理：renv 会自动创建和维护 renv.lock 文件，记录项目依赖的包及其版本。这个文件是重现项目环境的关键，确保在不同机器或时间点运行时，依赖的版本完全一致。</li>
</ul>
</section>
<section id="如何在-r-中使用-renv-包" class="level3">
<h3 class="anchored" data-anchor-id="如何在-r-中使用-renv-包">如何在 R 中使用 renv 包</h3>
<section id="初始化项目" class="level4">
<h4 class="anchored" data-anchor-id="初始化项目">1. 初始化项目</h4>
<p>首先，我们需要安装并加载 renv 包。在一个新的 R 项目中，我们可以使用 <code>renv::init()</code> 来初始化 renv 环境。这将会创建一个新的 renv 文件夹并生成 renv.lock 文件。初始化后，项目中会有一个专门的库（renv/library）存放该项目所需的所有 R 包，同时生成 renv.lock 文件，这个文件记录了所有依赖包的具体版本。</p>
</section>
<section id="安装依赖包" class="level4">
<h4 class="anchored" data-anchor-id="安装依赖包">2. 安装依赖包</h4>
<p>当我们开始开发项目时，可以通过 <code>install.packages()</code> 安装所需的 R 包，renv 会将这些包安装到项目的独立环境中。</p>
<p>例如，安装 ggplot2` 包后，renv 会自动更新 renv.lock 文件，记录包的安装信息及其版本。</p>
</section>
<section id="恢复项目环境" class="level4">
<h4 class="anchored" data-anchor-id="恢复项目环境">3. 恢复项目环境</h4>
<p>如果我们或者其他人需要在另一个环境中重新运行该项目，renv 允许我们通过 <code>renv::restore()</code> 命令恢复项目的所有依赖包。这个命令会根据 renv.lock 文件自动安装所有所需的包及其指定版本，从而确保每次运行时的包版本一致，避免了环境问题。</p>
</section>
<section id="查看并更新项目依赖" class="level4">
<h4 class="anchored" data-anchor-id="查看并更新项目依赖">4. 查看并更新项目依赖</h4>
<p>如果我们需要查看项目当前依赖的所有包，可以使用 <code>renv::status()</code> 命令，它会列出所有包及其状态。而当我们需要更新项目中的某个包时，可以使用 <code>renv::update()</code> 命令，它会根据当前最新的包版本进行更新，并更新 renv.lock 文件。</p>
</section>
<section id="分享项目" class="level4">
<h4 class="anchored" data-anchor-id="分享项目">5. 分享项目</h4>
<p>当我们完成项目后，可以将 renv.lock 文件和源代码一起通过 github 分享给其他人，其他人只需要使用 <code>renv::restore()</code> 来恢复项目环境，无需担心包依赖的问题。</p>
</section>
</section>
<section id="renv-与-packrat-的对比" class="level3">
<h3 class="anchored" data-anchor-id="renv-与-packrat-的对比">renv 与 packrat 的对比</h3>
<p>在 renv 之前，R 中有一个较为类似的包叫做 packrat，它也提供环境管理的功能。然而，renv 相比于 packrat 有几个优势：</p>
<ul>
<li>更简洁：renv 比 packrat 更轻量，易于使用和理解。</li>
<li>更强的兼容性：renv 与 R 版本的兼容性更好，适应性更强，能够更好地处理依赖关系。</li>
<li>性能更高：renv 在项目初始化、恢复和更新时速度更快。</li>
</ul>
<p>因此，renv 在目前 R 项目环境管理中得到了更广泛的使用。</p>


<!-- -->

</section>

 ]]></description>
  <category>r</category>
  <category>tools</category>
  <category>version control</category>
  <guid>https://leslie-lu.github.io/blog/2025/01/19/renv_in_r/</guid>
  <pubDate>Sun, 19 Jan 2025 00:00:00 GMT</pubDate>
  <media:content url="https://rstudio.github.io/renv/articles/renv.png" medium="image" type="image/png"/>
</item>
<item>
  <title>Tracy-Widom Statistics</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2025/01/07/tracy_widom_test/</link>
  <description><![CDATA[ 





<p>在现代基因组学和统计学中，Tracy-Widom 统计量（Tracy-Widom statistics）是一个广泛应用于分析主成分分析（PCA）结果的重要工具。尤其在遗传学、群体学和数据科学等领域，Tracy-Widom 统计量可以帮助研究者评估主成分的统计显著性，为后续的研究分析提供强有力的支持。</p>
<p>这里，我们将带大家深入了解 Tracy-Widom 统计量的概念、应用以及如何通过 twstats 程序进行计算。</p>
<section id="什么是-tracy-widom-统计量" class="level3">
<h3 class="anchored" data-anchor-id="什么是-tracy-widom-统计量">什么是 Tracy-Widom 统计量</h3>
<p>Tracy-Widom 统计量来源于随机矩阵理论，它用于描述随机矩阵的特征值分布，尤其是最大特征值的行为。在大规模数据分析中，Tracy-Widom 分布成为评估主成分显著性的标准工具。</p>
<p>具体来说，Tracy-Widom统计量用于检验 PCA 中主成分的显著性。我们前面讲过<a href="https://mp.weixin.qq.com/s/C_41H2pcDHlYMODcb3S9ew">使用 Eigensoft 中的 smartPCA 进行 PCA 分析</a>。PCA 通常会计算各主成分的方差，并根据这些方差来筛选重要的主成分。然而，如何判断哪些主成分是由于数据的真实结构而非随机噪声引起的呢？这正是Tracy-Widom统计量能够发挥作用的地方，Tracy-Widom 统计量可以帮助我们判断哪些主成分是统计显著的。</p>
<p>Tracy-Widom分布的核心思想是：如果我们从一个高维随机矩阵中提取主成分，那么最大主成分的值将服从特定的统计分布。通过计算 Tracy-Widom统计量，研究者可以对 PCA 中的每个主成分进行显著性检验，评估其是否真的反映了数据的结构，而非偶然性噪声。</p>
</section>
<section id="twstats-程序与-tracy-widom-统计量" class="level3">
<h3 class="anchored" data-anchor-id="twstats-程序与-tracy-widom-统计量">twstats 程序与 Tracy-Widom 统计量</h3>
<p>Eigensoft 中的 twstats 程序可以用来计算 Tracy-Widom 统计量。twstats 程序通过计算给定数据集的特征值分布，具体来说，twstats 程序会根据 Tracy-Widom 分布为每个主成分计算一个 p 值，从而帮助研究者判断哪些主成分是值得关注的。</p>
<p>twstats 适用于随机标记数据，但不适用于含有祖先信息标记（ancestry-informative markers）的数据。它假设数据集是由随机标记构成，这意味着在分析过程中不应该包含任何可能揭示祖先信息的标记（如遗传标记）。因为在包含祖先信息的标记数据中，可能会出现基因组混合 LD（连锁不平衡），这会违背Tracy-Widom统计量的基本假设。如果数据集含有祖先信息标记，Tracy-Widom 统计量的结果可能会不准确。</p>
<p>Eigensoft 中的 twstats 程序示例如下：</p>
<pre class="{perl}"><code>#!/usr/bin/perl

$command = "../bin/twstats";
$command .= " -t twtable ";
$command .= " -i twexample.eval ";
$command .= " -o twexample.out";
print("$command\n");
system("$command");</code></pre>


<!-- -->

</section>

 ]]></description>
  <category>bioinformatics</category>
  <category>biostatistics</category>
  <category>pca</category>
  <guid>https://leslie-lu.github.io/blog/2025/01/07/tracy_widom_test/</guid>
  <pubDate>Tue, 07 Jan 2025 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202412262344320.png" medium="image" type="image/png"/>
</item>
<item>
  <title>10 个常用终端命令</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2025/01/06/terminal_commands/</link>
  <description><![CDATA[ 





<p>终端是开发者与操作系统之间的重要桥梁，通过它，我们可以快速进行各种操作。无论是查找文件、修改权限，还是处理文本文件，熟练掌握一些基础的终端命令可以显著提高工作效率。</p>
<p>这里，我们来介绍 10 个每个开发者都应该知道的终端命令，它们能帮助我们在日常开发工作中更加高效地使用终端。</p>
<section id="grep---查找内容" class="level3">
<h3 class="anchored" data-anchor-id="grep---查找内容">1. grep - 查找内容</h3>
<p>grep 是一个强大的搜索命令，用于在文件中查找指定的文本内容。它常用于查找特定的关键词，支持正则表达式，功能非常强大。</p>
<p>常见用法：</p>
<pre class="{bash}"><code>grep "let's find something" file.[txt,json,js,md,etc]</code></pre>
<p>在 file.txt 文件中查找匹配 pattern 的行。</p>
<pre class="{bash}"><code># case-insensitive search
grep -i "pattern" file.txt
# count occurrences
grep -c "pattern" file.txt
# search for multiple patterns
grep -e "pattern1" -e "pattern2" file.txt
# recursive search in directories
grep -o -r "pattern" /path/to/directory | wc -l</code></pre>
</section>
<section id="man---查看命令帮助" class="level3">
<h3 class="anchored" data-anchor-id="man---查看命令帮助">2. man - 查看命令帮助</h3>
<p>man 是 <code>manual</code> 的缩写，用于查看命令的帮助文档。当我们对某个命令不熟悉时，可以通过 man 命令查看其用法、选项和参数等详细信息。</p>
<pre class="{bash}"><code>man grep</code></pre>
<p>查看 grep 命令的帮助文档。</p>
</section>
<section id="cat---查看文件内容" class="level3">
<h3 class="anchored" data-anchor-id="cat---查看文件内容">3. cat - 查看文件内容</h3>
<p>cat 是一个用于查看文件内容的命令，它可以一次性显示整个文件的内容。如果文件较大，可以结合其他命令来分页显示内容。</p>
<pre class="{bash}"><code>cat file.txt</code></pre>
<p>显示 file.txt 文件的所有内容。</p>
<pre class="{bash}"><code># combine multiple files
cat file1.txt file2.txt &gt; combined.txt
# create a new file
cat &gt; newfile.txt</code></pre>
</section>
<section id="head---查看文件开头" class="level3">
<h3 class="anchored" data-anchor-id="head---查看文件开头">4. head - 查看文件开头</h3>
<p>head 命令用于显示文件的前几行内容。默认情况下，它会显示文件的前10行，但可以通过参数指定显示行数。</p>
<pre class="{bash}"><code>head -n 20 file.txt</code></pre>
<p>显示文件 file.txt 的前20行。</p>
</section>
<section id="awk---文本处理工具" class="level3">
<h3 class="anchored" data-anchor-id="awk---文本处理工具">5. awk - 文本处理工具</h3>
<p>我们在这篇文章<a href="https://mp.weixin.qq.com/s/K8yxoqzLcOE45LImJqC98A">探索 AWK</a>已经有过介绍。</p>
</section>
<section id="sed---流编辑器" class="level3">
<h3 class="anchored" data-anchor-id="sed---流编辑器">6. sed - 流编辑器</h3>
<p>sed 是一个流编辑器，用于处理和修改文件内容。它通过匹配模式和替换操作，可以高效地修改文本文件。</p>
<pre class="{bash}"><code># replace a word or pattern in a file
sed -i '' 's/old/new/g' file.md</code></pre>
<p>-i 选项表示<code>就地编辑</code>（in-place editing），即直接修改文件内容。如果不使用 -i，sed 会将结果输出到标准输出，而不会修改原文件。-i 选项后面通常需要一个备份文件的扩展名。如果提供一个空字符串 ’’，表示不创建备份文件。如果不提供这个参数，sed 会默认创建一个备份文件。s 表示替换操作，g 表示全局替换（global），即替换每一行中所有匹配的 old，而不仅仅是第一个匹配项。</p>
<pre class="{bash}"><code># print specific lines
sed -n '10,20p' file.json</code></pre>
<p>-n 选项表示<code>静默模式</code>（silent mode），只有通过 p 命令显式打印的行才会输出。<code>10,20p</code> 表示打印第 10 到第 20 行。</p>
<pre class="{bash}"><code># regular expression
sed 's/[0-9]*/X/g' file.csv</code></pre>
<p>将文件中的数字替换为 X。</p>
<pre class="{bash}"><code># rename files in bulk
for file in *.txt; do 
  mv "$file" "$(echo "$file" | sed 's/.txt$/.md/')"
done</code></pre>
<p>echo “$file” 是为了将文件名传递给 sed 命令，然后将 .txt 后缀替换为 .md。</p>
</section>
<section id="tail---查看文件末尾" class="level3">
<h3 class="anchored" data-anchor-id="tail---查看文件末尾">7. tail - 查看文件末尾</h3>
<p>tail 命令用于查看文件的最后几行内容，特别适合查看日志文件的最新信息。与 head 命令相反，tail 显示的是文件的结尾部分。</p>
<pre class="{bash}"><code>tail -f logfile.log</code></pre>
<p>实时查看日志，-f 选项表示<code>跟踪</code>（follow），即实时显示文件的更新内容。</p>
</section>
<section id="chmod---修改文件权限" class="level3">
<h3 class="anchored" data-anchor-id="chmod---修改文件权限">8. chmod - 修改文件权限</h3>
<p>每个文件和目录都有权限属性，用于控制用户对文件的访问权限。权限属性包括读、写、执行权限，分别对应 r、w、x。用户组包括所有者、所属组和其他用户，分别对应 owner、group、others。chmod 命令用于修改文件或目录的访问权限，可以通过符号模式或数字模式来设置权限。</p>
<p>符号模式包括 u（所有者）、g（所属组）、o（其他用户）、a（所有用户），加号 + 表示添加权限，减号 - 表示删除权限，等号 = 表示设置权限。</p>
<pre class="{bash}"><code>chmod +x script.sh</code></pre>
<p>给 script.sh 脚本添加执行权限。</p>
<p>数字模式包括 0-7，分别对应 rwx 权限。r=4，w=2，x=1。例如，755 表示所有者可读写执行，所属组和其他用户可读执行；777 表示所有用户可读写执行。</p>
<pre class="{bash}"><code>chmod 755 file.txt</code></pre>
<p>递归修改目录权限：</p>
<pre class="{bash}"><code>chmod -R 755 /path/to/directory</code></pre>
</section>
<section id="xargs---将输出作为参数传递" class="level3">
<h3 class="anchored" data-anchor-id="xargs---将输出作为参数传递">9. xargs - 将输出作为参数传递</h3>
<p>xargs 命令常与其他命令结合使用，它可以将标准输入转换为命令行参数，并将其传递给后续的命令。</p>
<pre class="{bash}"><code>echo "file1 file2 file3" | xargs rm</code></pre>
<p>将 file1 file2 file3 传递给 rm 命令，删除这三个文件。</p>
<p>结合 find 使用：</p>
<pre class="{bash}"><code>find . -name "*.txt" | xargs rm</code></pre>
<p>压缩文件：</p>
<pre class="{bash}"><code>ls *.log | xargs tar -czvf logs.tar.gz</code></pre>
</section>
<section id="find---查找文件" class="level3">
<h3 class="anchored" data-anchor-id="find---查找文件">10. find - 查找文件</h3>
<p>find 是一个非常强大的文件查找命令，它可以根据不同的条件查找文件。可以按文件名、大小、修改时间等进行搜索。</p>
<p>常见用法：</p>
<pre class="{bash}"><code>find /path/to/search -name "astro"</code></pre>
<p>在指定路径下查找所有 astro 文件。</p>
<pre class="{bash}"><code># clean up log files
find /var/log -type f -name "*.log" -mtime +7 -delete</code></pre>
<p>-type f 表示只查找文件，-mtime +7 表示修改时间在 7 天前的文件，-delete 表示删除这些文件。</p>
<pre class="{bash}"><code># backup files
find /path/to/files -name "*.txt" -exec cp {} /path/to/backup \;</code></pre>
<p>-exec 选项用于执行其他命令，{} 表示查找到的文件，; 表示命令结束。</p>
</section>
<section id="takeaway" class="level3">
<h3 class="anchored" data-anchor-id="takeaway">takeaway</h3>
<p>掌握这些常用的终端命令能帮助我们在开发和运维工作中事半功倍。每个命令都有其特定的功能，熟练运用它们，我们将能够更高效地处理文件、查找信息、修改权限，甚至进行复杂的文本处理。</p>


<!-- -->

</section>

 ]]></description>
  <category>bioinformatics</category>
  <category>tools</category>
  <category>programming</category>
  <category>linux</category>
  <category>terminal</category>
  <guid>https://leslie-lu.github.io/blog/2025/01/06/terminal_commands/</guid>
  <pubDate>Mon, 06 Jan 2025 00:00:00 GMT</pubDate>
  <media:content url="https://www.freecodecamp.org/news/content/images/2022/03/pexels-pixabay-207580.jpg" medium="image" type="image/jpeg"/>
</item>
<item>
  <title>探索 AWK</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2025/01/02/awk/</link>
  <description><![CDATA[ 





<p>在大数据分析和生物信息学领域，处理文本数据是一项常见的任务。awk 是一种功能强大的文本处理工具，它允许用户对文本文件进行灵活的模式匹配、过滤、计算和格式化。</p>
<p>这里，我们将介绍 awk 的基本概念、常用命令及其在实际数据处理中的应用。</p>
<section id="什么是-awk" class="level3">
<h3 class="anchored" data-anchor-id="什么是-awk">什么是 AWK</h3>
<p>awk 是一种编程语言，用于处理和分析文本文件，尤其是在数据处理和报告生成方面非常有用。其名称来源于其三位创造者的姓氏首字母：Alfred Aho、Peter Weinberger 和 Brian Kernighan。</p>
<p>awk 处理文本文件时，会将文件的每一行视为一个记录，每一行中的字段（由空格或制表符分隔）作为字段。通过指定模式和动作，awk 可以对文件内容进行筛选、处理并输出结果。</p>
</section>
<section id="awk-的基本语法" class="level3">
<h3 class="anchored" data-anchor-id="awk-的基本语法">AWK 的基本语法</h3>
<p>awk 命令的基本语法如下：</p>
<pre class="{bash}"><code>awk [OPTION] 'CONDITION {PROCESS}' FILENAME</code></pre>
<p>在 AWK 中，有一些内建的变量非常实用： - $0 : 表示当前行的所有字段。 - $n : 表示第n列字段。比如 $1 表示第一列，$4 表示第四列。 - NR : 当前处理的行号（记录号）。 - NF : 当前行的字段数。</p>
<p>例如，以下命令会打印出文件中所有的行：</p>
<pre class="{bash}"><code>awk '{ print }' filename</code></pre>
<p>如果我们只想打印文件中第二列的数据，可以这样写：</p>
<pre class="{bash}"><code>awk '{ print $2 }' filename</code></pre>
<p>其中，$2 代表第二列，$1 代表第一列，依此类推。</p>
</section>
<section id="常用-awk-命令" class="level3">
<h3 class="anchored" data-anchor-id="常用-awk-命令">常用 AWK 命令</h3>
<section id="打印特定字段" class="level4">
<h4 class="anchored" data-anchor-id="打印特定字段">1. 打印特定字段</h4>
<p>打印某一列的内容是 awk 最常见的用途之一。选择染色体 2 上的变异（保留表头）：</p>
<pre class="{bash}"><code>awk 'NR==1 || $1==2 {print $0}' sumstats.txt | head</code></pre>
<p><code>NR==1</code> 如果是第一行（通常是表头），打印。<code>$1==2</code> 如果第一列是染色体号为 2 的变异，打印这一行。这段代码保留了表头，并筛选出染色体 2 上的所有变异。</p>
</section>
<section id="使用条件语句筛选数据" class="level4">
<h4 class="anchored" data-anchor-id="使用条件语句筛选数据">2. 使用条件语句筛选数据</h4>
<p>我们可以使用 if 语句来根据特定条件筛选数据。例如，选择全基因组显著的变异（p 值 &lt; 5e-8）：</p>
<pre class="{bash}"><code>awk 'NR==1 || $13&lt;5e-8 {print $0}' sumstats.txt | head</code></pre>
<p><code>$13&lt;5e-8</code> 选择第 13 列（P 值列）小于 5e-8 的行。这个命令用于筛选全基因组显著的变异数据。</p>
</section>
<section id="计算和统计" class="level4">
<h4 class="anchored" data-anchor-id="计算和统计">3. 计算和统计</h4>
<p>awk 还可以用于计算数据，比如求和、平均值等。假设我们有一个文件，每行代表一个学生的成绩，我们想计算总成绩：</p>
<pre class="{bash}"><code>awk '{ sum += $2 } END { print sum }' grades.txt</code></pre>
<p>在这个例子中，$2 是成绩列，sum += $2 会累加第二列的所有成绩，END 是在所有数据处理完后执行的操作。</p>
</section>
<section id="格式化输出" class="level4">
<h4 class="anchored" data-anchor-id="格式化输出">4. 格式化输出</h4>
<p>awk 还支持格式化输出，类似于 <code>C 语言</code>中的 <code>printf</code>。例如，想要将数据格式化为固定宽度，可以这样做：</p>
<pre class="{bash}"><code>awk '{ printf "%-10s %-5s %-8s\n", $1, $2, $3 }' data.txt</code></pre>
<p>这会将每一行的三列数据按指定格式输出，其中 %s 表示字符串，-10 表示左对齐并占用 10 个字符宽度。</p>
</section>
<section id="多文件处理" class="level4">
<h4 class="anchored" data-anchor-id="多文件处理">5. 多文件处理</h4>
<p>awk 也可以同时处理多个文件，甚至将不同文件的内容组合起来。例如：</p>
<pre class="{bash}"><code>awk '{ print FILENAME ": " $0 }' file1.txt file2.txt</code></pre>
<p>这里，FILENAME 是 awk 内置的变量，表示当前处理的文件名。<code>$0</code> 表示当前行的内容（即整行数据）。<code>print FILENAME ": " $0</code> 这部分的作用是打印文件名后跟一个冒号和当前行的内容。</p>
</section>
</section>
<section id="awk-在生物信息学中的应用" class="level3">
<h3 class="anchored" data-anchor-id="awk-在生物信息学中的应用">AWK 在生物信息学中的应用</h3>
<p>在生物信息学数据分析中，awk 被广泛应用于处理基因组学数据、GWAS 数据、RNA-Seq 数据等。这些数据通常包含数百万行，我们可以使用 awk 来快速筛选、过滤、提取特定信息。例如，以下是一些常见的应用场景：</p>
<section id="从-vcf-文件中提取信息" class="level4">
<h4 class="anchored" data-anchor-id="从-vcf-文件中提取信息">1. 从 VCF 文件中提取信息</h4>
<p>VCF（Variant Call Format）文件是基因组变异的标准存储格式，通常包含变异位点的各种信息。如果我们想提取 VCF 文件中所有发生变异的基因，可以使用以下命令：</p>
<pre class="{bash}"><code>awk '$1 !~ /^#/ { print $1, $2, $4, $5 }' variants.vcf</code></pre>
<p>这条命令会跳过以 <code>#</code> 开头的注释行，输出变异位点的染色体位置、参考碱基和变异碱基。</p>
</section>
<section id="清洗-rna-seq-数据" class="level4">
<h4 class="anchored" data-anchor-id="清洗-rna-seq-数据">2. 清洗 RNA-Seq 数据</h4>
<p>RNA-Seq 数据的处理通常需要将表达量数据中的低表达基因或特定条件下的数据进行筛选。比如，删除表达量小于某一阈值的基因：</p>
<pre class="{bash}"><code>awk '$2 &gt; 10 { print $1, $2 }' gene_expression.txt</code></pre>
<p>这里，$2 &gt; 10 表示筛选出表达量大于 10 的基因。</p>


<!-- -->

</section>
</section>

 ]]></description>
  <category>bioinformatics</category>
  <category>tools</category>
  <category>programming</category>
  <category>awk</category>
  <category>linux</category>
  <guid>https://leslie-lu.github.io/blog/2025/01/02/awk/</guid>
  <pubDate>Thu, 02 Jan 2025 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202501021926596.png" medium="image" type="image/png"/>
</item>
<item>
  <title>使用 Hail 输出 PLINK 文件：一步到位</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2025/01/01/export_plink/</link>
  <description><![CDATA[ 





<p>在现代基因组学研究中，数据的处理和转换是至关重要的一环。PLINK 文件（包括 .bed, .bim, .fam 三个文件）是遗传学研究中的标准文件格式之一，经常用于 GWAS（全基因组关联研究）等分析。对于研究人员来说，将原始数据转换为 PLINK 文件格式是分析过程中的关键步骤。而 Hail，作为一个处理大规模基因数据的高效工具，提供了方便的方法来导出这些文件。</p>
<p>前面，我们介绍了如何<a href="https://mp.weixin.qq.com/s/rujbT3WC821spr1AKg5AzQ">掌握 Hail</a>，这里，我们将介绍如何使用 Hail 的 export_plink 功能，轻松导出 PLINK 文件，并深入探讨如何在数据预处理和分析过程中使用它。</p>
<section id="使用-hail-导出-plink-文件" class="level3">
<h3 class="anchored" data-anchor-id="使用-hail-导出-plink-文件">使用 Hail 导出 PLINK 文件</h3>
<p>Hail 提供了一个非常便利的函数 <code>export_plink()</code>，能够将 Hail MatrixTable 格式的数据导出为 PLINK 所需的三种文件格式：<code>.bed</code>、<code>.bim</code> 和 <code>.fam</code>。这些文件是 PLINK 软件包用于处理和分析基因型数据的标准文件格式。</p>
<section id="载入数据" class="level4">
<h4 class="anchored" data-anchor-id="载入数据">1. 载入数据</h4>
<p>首先，我们需要加载基因型数据，通常这些数据存储在 VCF 格式的文件中。使用 Hail 的 <code>import_vcf()</code> 函数，可以轻松导入 VCF 文件。</p>
<div id="8e903e32" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> hail <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> hl</span>
<span id="cb1-2"></span>
<span id="cb1-3">mt <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> hl.import_vcf(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'file://path_to_vcf_data.vcf'</span>, force_bgz<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">True</span>, reference_genome<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'GRCh38'</span>)</span></code></pre></div>
</div>
</section>
<section id="数据注释" class="level4">
<h4 class="anchored" data-anchor-id="数据注释">2. 数据注释</h4>
<p>为了确保导出的 PLINK 文件包含完整的信息，我们通常需要对数据进行注释。例如，标注样本的性别、家族信息等。这可以通过 <code>annotate_cols()</code> 函数完成。</p>
<div id="193050b2" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1">mt <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> mt.annotate_cols(</span>
<span id="cb2-2">    pat_id<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'0'</span>,         <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 父代 ID</span></span>
<span id="cb2-3">    mat_id<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'0'</span>,         <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 母代 ID</span></span>
<span id="cb2-4">    is_female<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">True</span>,     <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 是否为女性</span></span>
<span id="cb2-5">    pheno<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">9</span>            <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 表型（-9 表示缺失值）</span></span>
<span id="cb2-6">)</span></code></pre></div>
</div>
<p>在这个例子中，我们为每个样本添加了父母 ID、性别和表型信息。</p>
</section>
<section id="导出为-plink-文件" class="level4">
<h4 class="anchored" data-anchor-id="导出为-plink-文件">3. 导出为 PLINK 文件</h4>
<p>现在，数据已经准备好，可以使用 <code>export_plink()</code> 函数将其导出为 PLINK 所需的 <code>.bed</code>, <code>.bim</code>, <code>.fam</code> 文件。</p>
<div id="57237400" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1">hl.export_plink(</span>
<span id="cb3-2">    mt, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'output/example'</span>, </span>
<span id="cb3-3">    fam_id<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>mt.s,       <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 样本的 ID</span></span>
<span id="cb3-4">    ind_id<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>mt.s,       <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 样本的 ID</span></span>
<span id="cb3-5">    pat_id<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>mt.pat_id,  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 父代 ID</span></span>
<span id="cb3-6">    mat_id<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>mt.mat_id,  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 母代 ID</span></span>
<span id="cb3-7">    is_female<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>mt.is_female, <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 性别信息</span></span>
<span id="cb3-8">    pheno<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>mt.pheno     <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 表型信息</span></span>
<span id="cb3-9">)</span></code></pre></div>
</div>
<p>参数解析： - fam_id: 样本的家族 ID，通常使用样本的 ID（即 mt.s）。 - ind_id: 样本的个体 ID，这里使用 mt.s 作为样本 ID。 - pat_id 和 mat_id: 分别代表父母的 ID，通常可以使用默认值 0 表示没有父母信息，或者根据数据 - is_female: 样本的性别信息，Hail 会根据性别表达为 1（男性）或 2（女性）。这里通过注释 is_female 字段来指示性别。 - pheno: 表型数据，可以是布尔值（如是否患病）或者是数值型数据（如身高、体重等）。</p>
<p>导出的文件会包含以下三部分：</p>
<ul>
<li><code>output/example.bed</code>: 存储基因型数据（二进制格式）。</li>
<li><code>output/example.bim</code>: 包含变异信息，如染色体、位置、参考和变异等。</li>
<li><code>output/example.fam</code>: 包含样本信息，如家族 ID、个体 ID、父母 ID、性别和表型。</li>
</ul>
</section>
</section>
<section id="进阶功能批量导出与错误处理" class="level3">
<h3 class="anchored" data-anchor-id="进阶功能批量导出与错误处理">进阶功能：批量导出与错误处理</h3>
<p>当处理大量基因数据时，可能会涉及多个数据批次。在这种情况下，使用批处理来导出 PLINK 文件变得尤为重要。例如，我们可以使用 Python 脚本批量处理多个数据集，并通过适当的异常处理机制确保过程顺利进行。</p>
<div id="1e90bc6a" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> subprocess</span>
<span id="cb4-2"></span>
<span id="cb4-3"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 批量导出并上传</span></span>
<span id="cb4-4">batch_files <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'batch1.vcf'</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'batch2.vcf'</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'batch3.vcf'</span>]  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 示例批次</span></span>
<span id="cb4-5"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> batch_file <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> batch_files:</span>
<span id="cb4-6">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 导入 VCF 文件并处理</span></span>
<span id="cb4-7">    mt <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> hl.import_vcf(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f'file://</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>batch_file<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">'</span>, force_bgz<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">True</span>, reference_genome<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'GRCh38'</span>)</span>
<span id="cb4-8">    mt <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> mt.annotate_cols(</span>
<span id="cb4-9">        pat_id<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'0'</span>,</span>
<span id="cb4-10">        mat_id<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'0'</span>,</span>
<span id="cb4-11">        is_female<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">True</span>,</span>
<span id="cb4-12">        pheno<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">9</span></span>
<span id="cb4-13">    )</span>
<span id="cb4-14">    </span>
<span id="cb4-15">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 导出 PLINK 文件</span></span>
<span id="cb4-16">    hl.export_plink(mt, <span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f'output/</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>batch_file<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>split(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"."</span>)[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">'</span>, fam_id<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>mt.s, ind_id<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>mt.s, pat_id<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>mt.pat_id, mat_id<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>mt.mat_id, is_female<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>mt.is_female, pheno<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>mt.pheno)</span>
<span id="cb4-17"></span>
<span id="cb4-18">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 上传到远程存储</span></span>
<span id="cb4-19">    subprocess.run([<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'dx'</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'upload'</span>, <span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f'output/</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>batch_file<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>split(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"."</span>)[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">.bed'</span>])</span>
<span id="cb4-20">    subprocess.run([<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'dx'</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'upload'</span>, <span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f'output/</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>batch_file<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>split(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"."</span>)[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">.bim'</span>])</span>
<span id="cb4-21">    subprocess.run([<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'dx'</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'upload'</span>, <span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f'output/</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>batch_file<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>split(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"."</span>)[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">.fam'</span>])</span></code></pre></div>
</div>


<!-- -->

</section>

 ]]></description>
  <category>hail</category>
  <category>bioinformatics</category>
  <category>dnanexus</category>
  <category>genomics</category>
  <category>plink</category>
  <category>vcf</category>
  <guid>https://leslie-lu.github.io/blog/2025/01/01/export_plink/</guid>
  <pubDate>Wed, 01 Jan 2025 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202412282307896.png" medium="image" type="image/png"/>
</item>
<item>
  <title>掌握 Hail</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/12/28/hail/</link>
  <description><![CDATA[ 





<p>在生物信息学领域，处理大规模基因组数据尤其是 VCF（Variant Call Format）格式的数据常常是一个挑战。传统的处理方法可能面临性能瓶颈，而 Hail 作为一个专为大规模基因组数据分析设计的工具，其高效性和可扩展性使其在基因组学界得到了广泛应用。</p>
<p>这里，我们将介绍 Hail 的基本使用技巧，并探讨如何在 DNAnexus 平台上导入和处理 pVCF 数据。</p>
<section id="什么是hail" class="level3">
<h3 class="anchored" data-anchor-id="什么是hail">什么是Hail？</h3>
<p>Hail 是一个开源的、专为基因组数据分析而设计的 Python 库，特别适合用于处理大规模的 VCF 文件。它在处理和分析基因组数据时，提供了比传统工具（如 GATK）更高效的性能，尤其在进行大规模 GWAS（基因组全关联研究）、变异注释和基因型分析时，它能够显著提高计算效率。</p>
<p>Hail 的核心优势在于其对分布式计算的支持，能够利用 Spark 集群进行大数据的并行处理。此外，Hail 也与很多常见的生物信息学工具兼容，比如 VCF 工具、Plink 等，使得它能够轻松集成到现有的生物信息学分析管道中。</p>
</section>
<section id="hail-在-dnanexus-平台上的应用" class="level3">
<h3 class="anchored" data-anchor-id="hail-在-dnanexus-平台上的应用">Hail 在 DNAnexus 平台上的应用</h3>
<p>在 DNAnexus 平台上，我们可以直接使用 Hail 进行大规模基因组数据分析。平台提供了一个强大的计算环境，可以通过 Hail 轻松地读取、处理和分析 VCF 文件。以下是一些常见的应用场景和技巧：</p>
<section id="使用hail加载和处理vcf文件" class="level4">
<h4 class="anchored" data-anchor-id="使用hail加载和处理vcf文件">1. 使用Hail加载和处理VCF文件</h4>
<p>在 DNAnexus 平台上，VCF 文件通常存储在项目中，用户可以直接加载到 Hail 中进行处理。Hail 提供了简便的 API 来读取 VCF 文件，下面是一个简单的示例，展示如何在 Hail 中加载 VCF 文件：</p>
<div id="90e76816" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> hail <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> hl</span>
<span id="cb1-2"></span>
<span id="cb1-3"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 加载VCF文件</span></span>
<span id="cb1-4">vcf_file <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'gs://my_bucket/my_data.vcf.bgz'</span></span>
<span id="cb1-5">mt <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> hl.import_vcf(vcf_file)</span></code></pre></div>
</div>
<p>在这个示例中，我们使用 <code>hl.import_vcf()</code> 方法来加载 VCF 文件，<code>gs://</code> 是 Google Cloud Storage（GCS）路径格式，在 DNAnexus 平台上，我们也可以使用相应的路径来引用存储在平台上的 VCF 文件。</p>
</section>
<section id="使用-hail-进行数据质量控制" class="level4">
<h4 class="anchored" data-anchor-id="使用-hail-进行数据质量控制">2. 使用 Hail 进行数据质量控制</h4>
<p>在基因组数据分析中，数据质量控制（QC）是不可或缺的一部分，Hail 为此提供了多种功能，例如去除低质量的样本或变异、过滤变异的深度或基因型质量等。</p>
<p>以下是一个常见的 QC 操作示例，过滤掉低质量的变异：</p>
<div id="f8f2a844" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 过滤低质量变异</span></span>
<span id="cb2-2">mt <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> mt.filter_rows(mt.qual <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">30</span>)</span></code></pre></div>
</div>
<p>通过这样的操作，我们可以去除低质量的变异，保证后续分析结果的准确性。</p>
</section>
<section id="基于-hail-进行群体遗传学分析" class="level4">
<h4 class="anchored" data-anchor-id="基于-hail-进行群体遗传学分析">3. 基于 Hail 进行群体遗传学分析</h4>
<p>Hail 还广泛应用于群体遗传学分析，例如计算群体间的变异频率、构建群体的基因型矩阵、进行 GWAS 分析等。Hail 的高效数据处理能力使其能够轻松处理海量数据，并进行并行计算，极大地提升了数据分析的效率。</p>
</section>
</section>
<section id="pvcf-数据导入教程" class="level3">
<h3 class="anchored" data-anchor-id="pvcf-数据导入教程">pVCF 数据导入教程</h3>
<p>在基因组学中，VCF 文件是常见的变异数据格式，而 pVCF（partitioned VCF）格式则在处理极大规模数据时显得尤为重要。pVCF 将数据分割成多个小文件，避免了单个文件过大导致的内存问题，并使得数据处理更加灵活高效。</p>
<p>在 DNAnexus 平台上，我们可以利用 Hail 来导入 pVCF 数据，具体步骤如下：</p>
<section id="启动-hail-应用" class="level4">
<h4 class="anchored" data-anchor-id="启动-hail-应用">1. 启动 Hail 应用</h4>
<p>在 DNAnexus 平台上，首先需要启动一个 Hail 集群环境。我们可以使用 dx 命令行工具或通过平台的应用界面启动 Hail 应用。</p>
</section>
<section id="加载-pvcf-文件" class="level4">
<h4 class="anchored" data-anchor-id="加载-pvcf-文件">2. 加载 pVCF 文件</h4>
<p>使用 Hail 的 <code>import_vcf</code> 方法加载 pVCF 文件。需要注意的是，pVCF 文件通常由多个分区组成，因此在导入时需要确保指定正确的路径。</p>
<div id="ed3f4576" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> hail <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> hl</span>
<span id="cb3-2"></span>
<span id="cb3-3"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 导入pVCF文件</span></span>
<span id="cb3-4">mt <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> hl.import_vcf(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'gs://my_bucket/my_pvcf_file.part*'</span>)</span></code></pre></div>
</div>
</section>
<section id="数据分析与处理" class="level4">
<h4 class="anchored" data-anchor-id="数据分析与处理">3. 数据分析与处理</h4>
<p>加载 pVCF 数据后，我们可以利用 Hail 提供的各种功能对数据进行分析。常见的分析操作包括数据过滤、变异注释和群体遗传学分析等。</p>
<blockquote class="blockquote">
<p>小技巧：在 DNAnexus 平台上，我们可以利用分布式计算资源加速分析过程。Hail 与 Apache Spark 紧密集成，可以在集群上并行处理数据，从而大大缩短分析时间。</p>
</blockquote>


<!-- -->

</section>
</section>

 ]]></description>
  <category>hail</category>
  <category>bioinformatics</category>
  <category>dnanexus</category>
  <category>genomics</category>
  <guid>https://leslie-lu.github.io/blog/2024/12/28/hail/</guid>
  <pubDate>Sat, 28 Dec 2024 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202412282307896.png" medium="image" type="image/png"/>
</item>
<item>
  <title>使用 Eigensoft 中的 smartPCA 进行 PCA 分析</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/12/26/smartpca/</link>
  <description><![CDATA[ 





<p><a href="https://mp.weixin.qq.com/s/XChFmrV_vP3BNRUdaQnnDw">昨天</a>我们介绍了如何使用 plink 进行 pca 分析，这里，我们将介绍如何使用 Eigensoft 包中的工具 smartPCA 进行 PCA 分析。</p>
<section id="smartpca" class="level3">
<h3 class="anchored" data-anchor-id="smartpca">smartPCA</h3>
<p>smartPCA 是 <a href="https://hsph.harvard.edu/research/price-lab/software/">Eigensoft 包</a>中的一个工具，专门用于基因型数据的 PCA 分析。它可以处理大规模的遗传数据集，输出主成分和相应的特征值，帮助我们识别数据中最重要的变异模式。</p>
<section id="准备数据" class="level4">
<h4 class="anchored" data-anchor-id="准备数据">1. 准备数据</h4>
<p>首先，需要准备三个输入文件，这些文件包含了基因型数据的核心信息： - SNP 文件（.snp）：包含 SNP 位置信息，如 SNP 名称、染色体、遗传位置、参考等位基因和替代等位基因。 - 个体文件（.ind）：包含个体信息，如个体名称、性别、种群信息等。 - 基因型文件（.geno）：包含实际的基因型数据，每个个体对应一个SNP位点的基因型数据。</p>
<p>这些文件通常采用 EIGENSTRAT 格式，智能地将数据组织成易于处理和分析的形式。</p>
</section>
<section id="编写参数文件" class="level4">
<h4 class="anchored" data-anchor-id="编写参数文件">2. 编写参数文件</h4>
<p>为了运行 smartPCA，需要准备一个参数文件（.par），该文件指定了输入文件和输出文件的路径、PCA 分析的相关设置。一个典型的参数文件示例如下：</p>
<pre class="{bash}"><code>genotypename: &lt;GENOTYPE_DATA&gt;.geno
snpname: &lt;GENOTYPE_DATA&gt;.snp
indivname: &lt;GENOTYPE_DATA&gt;.ind
evecoutname: &lt;OUT_FILE&gt;.evec
evaloutname: &lt;OUT_FILE&gt;.eval
poplistname: &lt;POPULATION_LIST_FILE&gt;.txt
lsqproject: YES
numoutevec: 4
numthreads: 1</code></pre>
<ul>
<li>genotypename: 基因型数据文件路径。</li>
<li>snpname: SNP位点数据文件路径。</li>
<li>indivname: 个体数据文件路径。</li>
<li>evecoutname: 输出的主成分文件路径（.evec）。</li>
<li>evaloutname: 输出的特征值文件路径（.eval）。</li>
<li>poplistname: 种群列表文件路径，指定用于计算主成分的种群。</li>
<li>lsqproject: 是否对缺失数据进行投影。</li>
<li>numoutevec: 计算的主成分数量。</li>
<li>numthreads: 使用的线程数量。</li>
</ul>
</section>
<section id="运行-pca-分析" class="level4">
<h4 class="anchored" data-anchor-id="运行-pca-分析">3. 运行 PCA 分析</h4>
<p>创建好参数文件后，可以通过命令行运行 smartPCA 进行分析。假设参数文件名为 params.par，可以使用以下命令启动 PCA 分析：</p>
<pre class="{bash}"><code>smartpca -p params.par</code></pre>
<p>运行时间通常在 15 到 30 分钟之间，具体时间取决于数据集的大小。</p>
</section>
<section id="查看输出结果" class="level4">
<h4 class="anchored" data-anchor-id="查看输出结果">4. 查看输出结果</h4>
<p>smartPCA 会生成两个主要的输出文件： - <code>.evec</code> 文件：包含每个个体在各个主成分上的坐标。可以使用这些坐标绘制主成分图（例如，二维或三维散点图），以可视化个体或种群之间的关系。 - <code>.eval</code> 文件：包含每个主成分的特征值。这些特征值反映了每个主成分对数据方差的贡献。</p>
<p>例如，特征值较大的主成分通常解释了数据中更大的变异，因此我们可以根据特征值的大小来判断是否保留某个主成分。</p>
</section>
<section id="可视化-pca-结果" class="level4">
<h4 class="anchored" data-anchor-id="可视化-pca-结果">5. 可视化 PCA 结果</h4>
<p>PCA 的最终目的是将数据降到二维或三维空间，便于我们观察数据的分布和结构。常见的做法是将第一主成分和第二主成分的坐标作为横纵坐标，绘制二维散点图。</p>
<p>例如，使用 R 或 Python 中的可视化工具，可以将 .evec 文件中的数据提取出来，并绘制主成分图，来分析不同群体、种群或个体在遗传空间中的分布。</p>
</section>
<section id="投影其他个体" class="level4">
<h4 class="anchored" data-anchor-id="投影其他个体">6. 投影其他个体</h4>
<p>如果我们使用的是包含现代和古代个体的混合数据集，可以使用 smartPCA 的<strong>投影</strong>功能。这个功能允许我们将不在种群列表中的个体投影到已计算的主成分上。这样，可以将古代 DNA 样本投影到现代群体的 PCA 结果中，进一步分析古代遗传变异在现代遗传空间中的位置。</p>
</section>
</section>
<section id="总结" class="level3">
<h3 class="anchored" data-anchor-id="总结">总结</h3>
<p>通过使用 Eigensoft 中的 smartPCA 工具，我们可以方便地对大规模的基因型数据进行 PCA 分析，识别数据中的遗传结构，了解群体之间的遗传关系。通过合理选择主成分，结合特征值和可视化技术，PCA 能够帮助我们从高维遗传数据中提取出有价值的信息，进行种群间比较、演化历史分析等。</p>


<!-- -->

</section>

 ]]></description>
  <category>plink</category>
  <category>gwas</category>
  <category>bioinformatics</category>
  <category>pca</category>
  <category>eigensoft</category>
  <category>smartpca</category>
  <guid>https://leslie-lu.github.io/blog/2024/12/26/smartpca/</guid>
  <pubDate>Thu, 26 Dec 2024 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202412262344320.png" medium="image" type="image/png"/>
</item>
<item>
  <title>GWAS 前 PCA 步骤详解</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/12/25/pca/</link>
  <description><![CDATA[ 





<p>基因组广泛关联研究（GWAS）旨在探索遗传变异与表型特征之间的关系，但由于群体结构（即不同人群间的遗传差异）和样本亲缘关系的影响，可能会导致假阳性或假阴性结果。为了控制这些偏差，<strong>主成分分析（PCA）</strong>成为了 GWAS 前的重要步骤。</p>
<p>这里，我们将详细介绍 GWAS 前 PCA 的原因以及如何通过一系列步骤有效进行 PCA 分析。</p>
<section id="为什么要进行-pca" class="level3">
<h3 class="anchored" data-anchor-id="为什么要进行-pca">为什么要进行 PCA？</h3>
<section id="去除群体结构的影响" class="level4">
<h4 class="anchored" data-anchor-id="去除群体结构的影响">1. 去除群体结构的影响</h4>
<p>在多种族或多地区样本的 GWAS 中，样本的群体结构可能会影响分析结果。例如，不同的群体可能拥有不同的基因频率，这种结构性差异如果不加以控制，可能会误导结果，导致某些表型与基因变异之间的假相关。</p>
</section>
<section id="去除亲缘关系的干扰" class="level4">
<h4 class="anchored" data-anchor-id="去除亲缘关系的干扰">2. 去除亲缘关系的干扰</h4>
<p>如果样本中存在亲缘关系（如父母-子女、兄弟姐妹等），这些亲缘关系会增加样本间的相关性，从而影响 GWAS 的准确性。PCA 能够帮助识别并去除这些干扰，确保样本的独立性。</p>
</section>
<section id="降低计算复杂度" class="level4">
<h4 class="anchored" data-anchor-id="降低计算复杂度">3. 降低计算复杂度</h4>
<p>PCA 能够通过减少数据的维度来降低后续分析的计算复杂度，并帮助更清晰地理解数据的结构。</p>
</section>
</section>
<section id="pca-的步骤" class="level3">
<h3 class="anchored" data-anchor-id="pca-的步骤">PCA 的步骤</h3>
<p>进行 PCA 时，主要分为以下几个关键步骤：</p>
<section id="ld剪枝ld-pruning" class="level4">
<h4 class="anchored" data-anchor-id="ld剪枝ld-pruning">1. LD剪枝（LD-Pruning）</h4>
<p>在进行 PCA 前，我们通常会进行 LD 剪枝，即去除那些高度相关（连锁不平衡，LD）变异位点。这样做的目的是减少冗余信息，使得 PCA 能够更准确地反映独立的遗传变异。</p>
<p>在 PLINK 中，可以使用以下命令进行 LD 剪枝：</p>
<pre class="{bash}"><code>plink2 --bfile ${genotypeFile} \
       --indep-pairwise 50 5 0.2 \
       --out ${outPrefix}.prune</code></pre>
<p><code>--indep-pairwise 50 5 0.2</code> 进行 LD 剪枝，窗口大小为 50 个 SNP，步长为 5，LD 阈值为 0.2，表示去除那些与其他 SNP 高度相关的 SNP。<code>--out</code> 指定输出文件的前缀。这将生成一个包含独立 SNP 的文件 <code>${outPrefix}.prune.in</code>，后续将用于 PCA 计算。</p>
</section>
<section id="去除亲缘关系样本" class="level4">
<h4 class="anchored" data-anchor-id="去除亲缘关系样本">2. 去除亲缘关系样本</h4>
<p>PCA 计算时需要去除亲缘关系较近的样本，通常是 2 度以内的亲属。PLINK 的 <code>--king-cutoff</code> 命令可以用来筛选样本，并去除与其他样本亲缘关系过近的样本。</p>
<pre class="{bash}"><code>plink2 --bfile ${genotypeFile} \
       --king-cutoff 0.0884 \
       --out ${outPrefix}.king.cutoff</code></pre>
<p><code>--king-cutoff 0.0884</code> 此命令通过阈值 0.0884（约对应亲缘关系为 2 度的样本）去除亲缘关系过近的样本。这会生成两个文件：<code>plink_results_king.king.cutoff.in.id</code>（保留的样本 ID）和 <code>plink_results_king.king.cutoff.out.id</code>（被排除的样本 ID）。</p>
</section>
<section id="使用无亲缘关系样本和独立-snp-进行-pca" class="level4">
<h4 class="anchored" data-anchor-id="使用无亲缘关系样本和独立-snp-进行-pca">3. 使用无亲缘关系样本和独立 SNP 进行 PCA</h4>
<p>接下来，使用去除亲缘关系的样本和独立 SNP 来运行 PCA。PCA 计算的目的是识别样本间最显著的遗传变异。我们可以使用 PLINK 中的 <code>--pca</code> 命令来进行 PCA 计算。</p>
<pre class="{bash}"><code>plink2 --bfile ${genotypeFile} \
       --keep ${outPrefix}.king.cutoff.in.id \
       --extract ${outPrefix}.prune.in \
       --freq counts \
       --threads ${threads} \
       --pca approx allele-wts 10 \
       --out ${outPrefix}.pca</code></pre>
<p><code>--keep ${outPrefix}.king.cutoff.in.id</code> 指定只使用无亲缘关系的样本，<code>--extract ${outPrefix}.prune.in</code> 指定仅使用经过 LD 剪枝的独立 SNP。<code>--freq counts</code> 计算等位基因频率，<code>--pca approx allele-wts 10</code> 请求进行 PCA 计算，并输出前 10 个主成分的等位基因权重。此命令会生成多个输出文件，包括主成分得分文件（<code>.eigenvec</code>）、主成分方差解释比例文件（<code>.eigenval</code>）等。</p>
</section>
<section id="将-pca-结果投影到所有样本" class="level4">
<h4 class="anchored" data-anchor-id="将-pca-结果投影到所有样本">4. 将 PCA 结果投影到所有样本</h4>
<p>完成 PCA 后，我们可以将主成分的得分投影到所有样本中。这样可以确保即使是在 PCA 分析后没有被直接计算的样本，也能够获得与前几个主成分的关联。</p>
<pre class="{bash}"><code>plink2 --bfile ${genotypeFile} \
       --threads ${threads} \
       --read-freq ${outPrefix}.acount \
       --score ${outPrefix}.eigenvec.allele 2 6 header-read no-mean-imputation variance-standardize \
       --score-col-nums 7-16 \
       --out ${outPrefix}_projected</code></pre>
<p><code>--read-freq ${outPrefix}.acount</code> 读取计算过的等位基因频率，<code>--score ${outPrefix}.eigenvec.allele 2 6 header-read no-mean-imputation variance-standardize</code> 使用主成分分析的结果对所有样本进行投影，<code>--score-col-nums 7-16</code> 指定投影的主成分列。投影后的结果可以用于进一步的 GWAS 分析，确保将群体结构和亲缘关系的影响考虑在内。</p>
</section>
<section id="分析和解释-pca-结果" class="level4">
<h4 class="anchored" data-anchor-id="分析和解释-pca-结果">5. 分析和解释 PCA 结果</h4>
<p>完成 PCA 分析后，我们可以查看每个主成分的解释比例，了解各个主成分对于遗传变异的贡献。通常，前几个主成分会解释大部分的方差，因此我们关注的是这些主成分的贡献。</p>
<p>在 PLINK 的输出文件中，<code>.eigenval</code> 文件包含每个主成分的特征值，这些特征值表示该主成分对于数据方差的贡献比例。通过查看这些值，我们可以判断哪些主成分最能解释数据中的变异。</p>
</section>
</section>
<section id="总结" class="level3">
<h3 class="anchored" data-anchor-id="总结">总结</h3>
<p>PCA 是 GWAS 分析中的一个关键步骤，能够有效去除群体结构和亲缘关系的影响，从而提高 GWAS 结果的可靠性和准确性。通过 PCA，我们不仅能去除数据中的噪声，还能更好地理解样本之间的遗传结构，为 GWAS 的成功开展奠定坚实基础。</p>


<!-- -->

</section>

 ]]></description>
  <category>plink</category>
  <category>gwas</category>
  <category>bioinformatics</category>
  <category>pca</category>
  <guid>https://leslie-lu.github.io/blog/2024/12/25/pca/</guid>
  <pubDate>Wed, 25 Dec 2024 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202412252318097.png" medium="image" type="image/png"/>
</item>
<item>
  <title>预 GWAS 阶段的基因型数据 QC 流程</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/12/24/genotype_data_QC/</link>
  <description><![CDATA[ 





<p>在进行全基因组关联研究（GWAS）前，数据质量的控制（QC）是至关重要的一步。</p>
<p>预处理和质量控制可以确保我们使用的数据集干净、可靠，避免潜在的偏倚和错误。这里，我们将介绍如何在 GWAS 前进行基因型数据的 QC，确保数据的准确性和可靠性。</p>
<section id="计算缺失率missing-rate与呼叫率call-rate" class="level3">
<h3 class="anchored" data-anchor-id="计算缺失率missing-rate与呼叫率call-rate">1. 计算缺失率（Missing Rate）与呼叫率（Call Rate）</h3>
<p>在 GWAS 分析中，缺失数据可能会影响结果的准确性。基因型数据的质量首先需要评估每个样本和每个 SNP 的缺失率。</p>
<p>缺失率表示某个样本在所有标记位点的基因型缺失的比例；呼叫率表示某个 SNP 在所有样本中的基因型被成功识别的比例。样本缺失率：样本的基因型数据可能因技术问题、平台差异等因素缺失，需要计算每个样本的缺失率，并根据预设的阈值剔除缺失过多的样本。SNP 呼叫率：类似地，每个SNP的呼叫率需要计算。如果某些 SNP 在大多数样本中都没有成功呼叫，可以考虑排除这些 SNP。</p>
<p>在 PLINK 中，可以使用以下命令来计算样本的缺失率和 SNP 的呼叫率：</p>
<pre class="{bash}"><code>plink --bfile ${genotypeFile} --missing --out plink_missing</code></pre>
</section>
<section id="计算等位基因频率allele-frequency" class="level3">
<h3 class="anchored" data-anchor-id="计算等位基因频率allele-frequency">2. 计算等位基因频率（Allele Frequency）</h3>
<p>等位基因频率是 GWAS 中重要的统计量，它表示某个特定等位基因在样本中的出现频率。为了确保我们分析的是常见的变异，我们通常会设置最小等位基因频率（MAF）阈值。通常，筛选出 MAF 低于 1% 的 SNP 是合理的，因为低频变异可能会增加假阳性。</p>
<p>在 PLINK 中，计算等位基因频率非常简单：</p>
<pre class="{bash}"><code>plink --bfile ${genotypeFile} --freq --out plink_freq</code></pre>
</section>
<section id="hardy-weinberg-平衡精确检验hardy-weinberg-equilibrium-test" class="level3">
<h3 class="anchored" data-anchor-id="hardy-weinberg-平衡精确检验hardy-weinberg-equilibrium-test">3. Hardy-Weinberg 平衡精确检验（Hardy-Weinberg Equilibrium Test）</h3>
<p>Hardy-Weinberg 平衡（HWE）检验是 GWAS 中常用的一种质量控制手段。根据 HWE 定律，如果一个群体处于均衡状态，则基因型的分布应该符合预期的频率。如果某个 SNP 的基因型偏离了 HWE，可能是因为样本污染、系统性错误或者是与某些表型相关的变异。通常，对于病例对照研究，HWE检验的p值阈值设定为<img src="https://latex.codecogs.com/png.latex?10%5E%7B-6%7D">。</p>
<p>使用 PLINK 执行 HWE 检验：</p>
<pre class="{bash}"><code>plink --bfile ${genotypeFile} --hwe 1e-6 --out plink_hwe</code></pre>
</section>
<section id="ld-pruning" class="level3">
<h3 class="anchored" data-anchor-id="ld-pruning">4. LD-Pruning</h3>
<p>连锁不平衡（LD）修剪是为了去除那些高度相关的 SNP，减少冗余，确保分析中使用的 SNP 具有独立性。若 SNP 之间存在高度的 LD，它们可能会影响 GWAS 结果的准确性。通常使用 LD-pruning 来去除相关性高的 SNP。</p>
<p>在 PLINK 中，常用的 LD-pruning 命令如下：</p>
<pre class="{bash}"><code>plink --bfile ${genotypeFile} --indep-pairwise 50 5 0.2 --out plink_results</code></pre>
<p>该命令会根据给定的窗口大小（50 个 SNP）、步长（每次移动 5 个 SNP）和 <img src="https://latex.codecogs.com/png.latex?r%5E%7B2%7D"> 阈值（0.2），进行 LD 修剪。</p>
</section>
<section id="计算近交系数-finbreeding-f-coefficient" class="level3">
<h3 class="anchored" data-anchor-id="计算近交系数-finbreeding-f-coefficient">5. 计算近交系数 F（Inbreeding F coefficient）</h3>
<p>近交系数 F（F coefficient）用于衡量样本中的近交程度。较高的 F 值可能表示样本存在近交，而较低的 F 值可能表示样本污染。计算 F 值时，可以使用 PLINK 的 <code>--het</code> 命令，它会生成每个样本的观测和期望纯合子基因型数量，并计算 F 值。</p>
<pre class="{bash}"><code>plink --bfile ${genotypeFile} --het --out plink_results</code></pre>
<p>输出结果中，F 值较高的样本可以考虑进一步检查或排除。常见的处理方法是将 F 值超过 3 个标准差（SD）的样本排除。</p>
</section>
<section id="数据管理make-bed-recode" class="level3">
<h3 class="anchored" data-anchor-id="数据管理make-bed-recode">6. 数据管理（make-bed / recode）</h3>
<p>为了便于后续分析，PLINK 提供了多种数据格式转换工具。最常用的格式是 BED 格式，它是 PLINK 的二进制格式，能够大大提高存储和计算效率。<code>make-bed</code> 将原始的 PED/MAP 文件转换为 BED 格式。通常在预处理数据时使用该命令。</p>
<pre class="{bash}"><code>plink --bfile ${genotypeFile} --make-bed --out plink_bed</code></pre>
<p>bash</p>
<p><code>recode</code> 如果你需要将数据转回 PED 格式或其他格式，可以使用 <code>recode</code> 命令。</p>
<pre class="{bash}"><code>plink --bfile ${genotypeFile} --recode --out plink_recode</code></pre>
<p>这些命令帮助将数据从一种格式转换为另一种格式，确保数据可以被其他分析工具有效读取。</p>
</section>
<section id="总结" class="level3">
<h3 class="anchored" data-anchor-id="总结">总结</h3>
<p>基因型数据的 QC 是 GWAS 分析中的基础步骤，它确保数据的可靠性和准确性。通过执行上述步骤，你可以在 GWAS 分析前排除掉缺失值过多、低频变异、偏离 Hardy-Weinberg 平衡的 SNP，以及冗余的高度 LD SNP。高质量的数据是可靠分析的前提，只有确保数据质量，才能得出科学、可靠的结果。</p>


<!-- -->

</section>

 ]]></description>
  <category>plink</category>
  <category>gwas</category>
  <category>bioinformatics</category>
  <category>genotype data</category>
  <category>qc</category>
  <guid>https://leslie-lu.github.io/blog/2024/12/24/genotype_data_QC/</guid>
  <pubDate>Tue, 24 Dec 2024 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202412241722219.png" medium="image" type="image/png"/>
</item>
<item>
  <title>PLINK 常用命令介绍</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/12/23/plink_command/</link>
  <description><![CDATA[ 





<p>PLINK 是一个广泛使用的基因组学分析工具，尤其适用于大规模遗传数据分析。无论是进行全基因组关联研究（GWAS），还是进行简单的基因型数据质量控制，PLINK 都是研究人员的重要工具之一。这里，我们将介绍 PLINK 中一些常用的命令，帮助大家更高效地处理和分析基因型数据。</p>
<section id="基本文件操作命令" class="level3">
<h3 class="anchored" data-anchor-id="基本文件操作命令">1. 基本文件操作命令</h3>
<section id="make-bed" class="level4">
<h4 class="anchored" data-anchor-id="make-bed">–make-bed</h4>
<p>将现有的文本格式数据（如 .ped 和 .map 文件）转换为二进制格式（.bed, .bim, .fam 文件），以便提高数据处理速度。</p>
<pre class="{bash}"><code>plink --ped input.ped --map input.map --make-bed --out output</code></pre>
<p>这条命令将 input.ped 和 input.map 文件转换为二进制格式，并保存为 output.bed、output.bim 和 output.fam 文件。</p>
</section>
<section id="bfile" class="level4">
<h4 class="anchored" data-anchor-id="bfile">–bfile</h4>
<p>在进行 PLINK 命令时，可以通过指定 .bed、.bim 和 .fam 文件前缀来加载二进制格式的数据文件。</p>
<pre class="{bash}"><code>plink --bfile mydata --freq</code></pre>
<p>该命令加载 mydata.bed、mydata.bim 和 mydata.fam 文件，并计算 SNP 频率。</p>
</section>
</section>
<section id="数据过滤命令" class="level3">
<h3 class="anchored" data-anchor-id="数据过滤命令">2. 数据过滤命令</h3>
<section id="keep-和-remove" class="level4">
<h4 class="anchored" data-anchor-id="keep-和-remove">–keep 和 –remove</h4>
<p><code>--keep</code> 用于保留指定样本，<code>--remove</code> 用于排除指定样本。这两个命令接受一个包含样本 ID 的文件。</p>
<pre class="{bash}"><code>plink --bfile mydata --keep keep_list.txt --make-bed --out filtered_data</code></pre>
<p>这个命令将 keep_list.txt 文件中的样本保留在数据集中，并生成新的二进制文件 filtered_data.bed。</p>
</section>
<section id="extract-和-exclude" class="level4">
<h4 class="anchored" data-anchor-id="extract-和-exclude">–extract 和 –exclude</h4>
<p><code>--extract</code> 用于选择指定的 SNPs（通过 .txt 文件列出），而 <code>--exclude</code> 用于排除某些 SNPs。</p>
<pre class="{bash}"><code>plink --bfile mydata --extract snp_list.txt --make-bed --out selected_snps</code></pre>
<p>此命令将 snp_list.txt 文件中的 SNPs 提取出来，并保存为新的二进制文件 selected_snps.bed。</p>
</section>
<section id="maf-和-geno" class="level4">
<h4 class="anchored" data-anchor-id="maf-和-geno">–maf 和 –geno</h4>
<p><code>--maf</code> 用于设置最小等位基因频率（Minor Allele Frequency），<code>--geno</code> 用于排除缺失率较高的 SNP。</p>
<pre class="{bash}"><code>plink --bfile mydata --maf 0.01 --geno 0.05 --make-bed --out filtered_data</code></pre>
<p>这个命令将过滤掉 MAF 小于 1% 或缺失率大于 5%的 SNP。</p>
</section>
</section>
<section id="关联分析命令" class="level3">
<h3 class="anchored" data-anchor-id="关联分析命令">3. 关联分析命令</h3>
<section id="assoc" class="level4">
<h4 class="anchored" data-anchor-id="assoc">–assoc</h4>
<p>进行简单的关联分析，计算每个 SNP 和表型之间的关联性。</p>
<pre class="{bash}"><code>plink --bfile mydata --assoc --out association_results</code></pre>
<p>该命令将进行每个 SNP 和表型的关联分析，并将结果保存为 association_results.assoc 文件。</p>
</section>
<section id="linear" class="level4">
<h4 class="anchored" data-anchor-id="linear">–linear</h4>
<p>进行线性回归分析，适用于连续表型。</p>
<pre class="{bash}"><code>plink --bfile mydata --linear --out linear_results</code></pre>
<p>此命令进行线性回归分析，输出与表型相关的 SNP 及其统计信息。</p>
</section>
<section id="logistic" class="level4">
<h4 class="anchored" data-anchor-id="logistic">–logistic</h4>
<p>进行 logistic 回归分析，适用于二分类表型（如病例对照研究）。</p>
<pre class="{bash}"><code>plink --bfile mydata --logistic --out logistic_results</code></pre>
<p>此命令进行 logistic 回归分析，输出 SNP 与表型的关系。</p>
</section>
</section>
<section id="质量控制命令" class="level3">
<h3 class="anchored" data-anchor-id="质量控制命令">4. 质量控制命令</h3>
<section id="check-sex" class="level4">
<h4 class="anchored" data-anchor-id="check-sex">–check-sex</h4>
<p>用于检查样本的性别是否与遗传数据一致。</p>
<pre class="{bash}"><code>plink --bfile mydata --check-sex --out sex_check</code></pre>
<p>该命令将检查数据集中所有样本的性别，并生成 sex_check.sexcheck 文件。</p>
</section>
<section id="missing" class="level4">
<h4 class="anchored" data-anchor-id="missing">–missing</h4>
<p>用于计算样本和 SNP 的缺失情况，帮助识别潜在的质量问题。</p>
<pre class="{bash}"><code>plink --bfile mydata --missing --out missing_data</code></pre>
<p>这个命令将生成一个包含缺失数据统计的文件 missing_data.lmiss 和 missing_data.imiss。</p>
</section>
</section>
<section id="文件合并命令" class="level3">
<h3 class="anchored" data-anchor-id="文件合并命令">5. 文件合并命令</h3>
<section id="merge-和-bmerge" class="level4">
<h4 class="anchored" data-anchor-id="merge-和-bmerge">–merge 和 –bmerge</h4>
<p><code>--merge</code> 合并多个 PLINK 数据集，<code>--bmerge</code> 与 <code>--merge</code> 类似，但适用于二进制文件。</p>
<pre class="{bash}"><code>plink --bfile data1 --bmerge data2.bed data2.bim data2.fam --make-bed --out merged_data</code></pre>
<p>这个命令将二进制文件 data1 和 data2 合并，并保存为新的 merged_data.bed 文件。</p>
</section>
</section>
<section id="数据导出命令" class="level3">
<h3 class="anchored" data-anchor-id="数据导出命令">6. 数据导出命令</h3>
<section id="recode" class="level4">
<h4 class="anchored" data-anchor-id="recode">–recode</h4>
<p>将数据从二进制格式转换为其他格式，例如 .ped 格式。</p>
<pre class="{bash}"><code>plink --bfile mydata --recode --out ped_format</code></pre>
<p>该命令将 mydata 数据集转换为 .ped 和 .map 文件格式，并保存为 ped_format.ped 和 ped_format.map。</p>
</section>
<section id="recode-vcf" class="level4">
<h4 class="anchored" data-anchor-id="recode-vcf">–recode vcf</h4>
<p>将 PLINK 二进制数据转换为 VCF 格式。</p>
<pre class="{bash}"><code>plink --bfile mydata --recode vcf --out vcf_output</code></pre>
<p>此命令将 mydata 数据集转换为 .vcf 格式，并输出为 vcf_output.vcf 文件。</p>
</section>
</section>
<section id="并行化命令" class="level3">
<h3 class="anchored" data-anchor-id="并行化命令">7. 并行化命令</h3>
<section id="threads" class="level4">
<h4 class="anchored" data-anchor-id="threads">–threads</h4>
<p>指定 PLINK 使用的线程数，从而加速计算。</p>
<pre class="{bash}"><code>plink --bfile mydata --assoc --threads 4 --out assoc_results</code></pre>
<p>该命令将在进行关联分析时使用 4 个线程，以加速处理。</p>


<!-- -->

</section>
</section>

 ]]></description>
  <category>plink</category>
  <category>gwas</category>
  <category>bioinformatics</category>
  <guid>https://leslie-lu.github.io/blog/2024/12/23/plink_command/</guid>
  <pubDate>Mon, 23 Dec 2024 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202412232113560.png" medium="image" type="image/png"/>
</item>
<item>
  <title>理解 PLINK格式</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/12/21/plink/</link>
  <description><![CDATA[ 





<p>在基因组学研究中，PLINK 是一个广泛使用的工具，用于关联分析、基因型数据处理以及数据格式转换。PLINK 以多种文件格式存储基因型数据，每种格式适用于不同的应用场景。这里，本文将介绍 PLINK 的几种主要数据格式及其特点，帮助大家更好地理解和使用这些文件。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202412232106583.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">PLINK</figcaption>
</figure>
</div>
<section id="plink-数据的基本组成" class="level3">
<h3 class="anchored" data-anchor-id="plink-数据的基本组成">PLINK 数据的基本组成</h3>
<p>在 PLINK 中，基因型数据的存储由三部分信息组成：</p>
<ul>
<li>个体信息：每个研究对象的基本信息，如样本 ID、性别等。</li>
<li>变异信息：每个 SNP 的基本信息，如染色体位置和碱基变化。</li>
<li>基因型矩阵：每个样本在每个位点上的基因型数据。</li>
</ul>
<p>为了存储和处理这些数据，PLINK 提供了多种格式集合，包括 ped/map、fam/bim/bed 和 psam/pvar/pgen。</p>
</section>
<section id="数据格式及其特点" class="level3">
<h3 class="anchored" data-anchor-id="数据格式及其特点">数据格式及其特点</h3>
<section id="pedmap-格式" class="level4">
<h4 class="anchored" data-anchor-id="pedmap-格式">ped/map 格式</h4>
<p>这是 <a href="https://www.cog-genomics.org/plink/1.9/formats" title="plink 1.9">PLINK</a> 的原始标准文本格式，用于存储完整的基因型数据表。</p>
<section id="ped-文件" class="level5">
<h5 class="anchored" data-anchor-id="ped-文件">.ped 文件</h5>
<p>.ped 文件包含每个样本的详细基因型数据，无标题行，每行代表一个样本。每行的前六列是样本的基本信息，后续每两个字段表示一个 SNP 的等位基因。</p>
<div id="7bdde2b6" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span> HG00403 <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">9</span> G G T T A A G A C C</span>
<span id="cb1-2"><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span> HG00404 <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">9</span> G G T T A A G A T C</span></code></pre></div>
</div>
<p>字段说明：第 1-6 列：样本信息（家庭 ID、样本 ID、父母 ID、性别、表型等）。第 7 列及之后：每个 SNP 的两个等位基因（如 <code>G G</code> 表示基因型为 GG）。</p>
</section>
<section id="map-文件" class="level5">
<h5 class="anchored" data-anchor-id="map-文件">.map 文件</h5>
<p>.map 文件存储每个变异位点的信息，无标题行，每行代表一个 SNP。</p>
<div id="bbf700f6" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>       <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>:<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">13273</span>:G:C     <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>       <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">13273</span></span>
<span id="cb2-2"><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>       <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>:<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">14599</span>:T:A     <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>       <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">14599</span></span></code></pre></div>
</div>
<p>字段说明：第 1 列：染色体编号。第 2 列：变异 ID（格式为染色体:位置:参考等位基因:替代等位基因）。第 3 列：遗传距离（默认为 0）。第 4 列：物理位置（以碱基为单位）。</p>
<p>优点：直观易读，便于检查数据。缺点：文件体积大，尤其是对于大规模数据。</p>
</section>
</section>
<section id="fambimbed-格式" class="level4">
<h4 class="anchored" data-anchor-id="fambimbed-格式">fam/bim/bed 格式</h4>
<p>这是 PLINK 的二进制格式，包含与 ped/map 相同的信息，但文件更小，适合大数据处理。</p>
<section id="fam-文件" class="level5">
<h5 class="anchored" data-anchor-id="fam-文件">.fam 文件</h5>
<p>样本基本信息，内容与 .ped 文件的前六列一致。</p>
<div id="7a971135" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span> HG00403 <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">9</span></span>
<span id="cb3-2"><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span> HG00404 <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">9</span></span></code></pre></div>
</div>
</section>
<section id="bim-文件" class="level5">
<h5 class="anchored" data-anchor-id="bim-文件">.bim 文件</h5>
<p>SNP 基本信息，与 .map 文件内容相似，但增加了等位基因列。</p>
<div id="d26c82e9" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>       <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>:<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">13273</span>:G:C     <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>       <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">13273</span>   C       G</span>
<span id="cb4-2"><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>       <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>:<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">14599</span>:T:A     <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>       <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">14599</span>   A       T</span></code></pre></div>
</div>
</section>
<section id="bed-文件" class="level5">
<h5 class="anchored" data-anchor-id="bed-文件">.bed 文件</h5>
<p>二进制格式的基因型矩阵，每个位点的数据存储为二进制编码。</p>
<div id="baef317c" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">00</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">6</span><span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">c</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">b</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span> ff ff bf bf ff ff ff ef fb ff ff ff fe</span></code></pre></div>
</div>
<p>优点：存储效率高，适合大规模基因型数据的分析。缺点：文件内容不可直接阅读，需要通过软件解析。</p>
</section>
</section>
<section id="psampvarpgen-格式" class="level4">
<h4 class="anchored" data-anchor-id="psampvarpgen-格式">psam/pvar/pgen 格式</h4>
<p>这是 <a href="https://www.cog-genomics.org/plink/2.0/" title="plink 2">PLINK2</a> 引入的新格式，提供更灵活的数据管理和高效的处理能力。</p>
<p>.psam 文件：存储个体信息。.pvar 文件：存储变异信息，与 .bim 文件相似。.pgen 文件：存储基因型矩阵的二进制文件。</p>
</section>
</section>
<section id="格式的适用场景" class="level3">
<h3 class="anchored" data-anchor-id="格式的适用场景">格式的适用场景</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 19%">
<col style="width: 40%">
<col style="width: 39%">
</colgroup>
<thead>
<tr class="header">
<th>格式集合</th>
<th>特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ped/map</td>
<td>文本格式，直观易读，但占用空间大</td>
<td>数据检查、数据格式初学者</td>
</tr>
<tr class="even">
<td>fam/bim/bed</td>
<td>二进制格式，存储高效，需借助软件解析</td>
<td>大规模数据分析，如GWAS</td>
</tr>
<tr class="odd">
<td>psam/pvar/pgen</td>
<td>PLINK2格式，兼容性强，处理速度快</td>
<td>需要复杂分析和高性能计算时</td>
</tr>
</tbody>
</table>


<!-- -->

</section>

 ]]></description>
  <category>plink</category>
  <category>gwas</category>
  <category>bioinformatics</category>
  <guid>https://leslie-lu.github.io/blog/2024/12/21/plink/</guid>
  <pubDate>Sat, 21 Dec 2024 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202412232106583.png" medium="image" type="image/png"/>
</item>
<item>
  <title>从基因到疾病：等位基因频率与效应大小的关系</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/12/20/maf/</link>
  <description><![CDATA[ 





<p>基因变异如何影响疾病风险？在遗传学研究中，等位基因频率（Minor Allele Frequency, MAF） 和 效应大小（Effect Size, OR, Odds Ratio） 是两个关键参数，用于衡量基因变异的稀有程度及其对疾病风险的影响。这里，我们试着用简单直观的方式，带大家了解等位基因频率和效应大小的关系，以及它们在不同疾病中的作用。</p>
<section id="等位基因频率与效应大小是什么" class="level3">
<h3 class="anchored" data-anchor-id="等位基因频率与效应大小是什么">等位基因频率与效应大小是什么？</h3>
<p>等位基因频率（MAF）是指某个变异（如 SNP，单核苷酸多态性）在群体中较少出现的等位基因的比例。根据频率，变异可以分为以下几类：</p>
<ul>
<li>非常罕见变异（Very Rare）：MAF &lt; 0.001</li>
<li>罕见变异（Rare）：0.001 ≤ MAF &lt; 0.01</li>
<li>低频变异（Low-frequency）：0.01 ≤ MAF &lt; 0.05</li>
<li>常见变异（Common）：MAF ≥ 0.05</li>
</ul>
<p>而效应大小通过优势比（OR, Odds Ratio） 衡量某个变异对疾病风险的影响程度：</p>
<ul>
<li>OR &gt; 3：高效应大小，意味着这个变异对疾病的影响很强。</li>
<li>OR接近1：低效应大小，表示影响很小。</li>
</ul>
</section>
<section id="等位基因频率与效应大小的关系" class="level3">
<h3 class="anchored" data-anchor-id="等位基因频率与效应大小的关系">等位基因频率与效应大小的关系</h3>
<section id="高效应大小且非常罕见变异孟德尔遗传病" class="level4">
<h4 class="anchored" data-anchor-id="高效应大小且非常罕见变异孟德尔遗传病">高效应大小且非常罕见变异：孟德尔遗传病</h4>
<ul>
<li>特点：极少数人携带的变异直接导致疾病发生。</li>
<li>例子：囊性纤维化（CFTR 基因突变）、镰状细胞贫血（HBB 基因突变）。</li>
<li>应用：这种高效应变异易于通过家系研究或全外显子组测序发现。</li>
</ul>
</section>
<section id="低频变异效应大小中等复杂疾病中的关键位点" class="level4">
<h4 class="anchored" data-anchor-id="低频变异效应大小中等复杂疾病中的关键位点">低频变异，效应大小中等：复杂疾病中的关键位点</h4>
<ul>
<li>特点：变异频率较低，但对特定人群的疾病风险有显著影响。</li>
<li>例子：一些罕见心血管疾病或代谢性疾病的相关位点。</li>
<li>挑战：需要更大样本量和更高精度的分析工具来发现。</li>
</ul>
</section>
<section id="常见变异低效应大小复杂疾病中常见变异" class="level4">
<h4 class="anchored" data-anchor-id="常见变异低效应大小复杂疾病中常见变异">常见变异，低效应大小：复杂疾病中常见变异</h4>
<ul>
<li>特点：频率较高，单个变异对疾病的影响微弱，但多个变异可能协同作用。</li>
<li>例子：2 型糖尿病、肥胖、抑郁症等多基因疾病。</li>
<li>应用：通过全基因组关联研究（GWAS）和多基因风险评分（PRS）进行疾病预测。</li>
</ul>
</section>
<section id="罕见变异但效应较低难以检测的遗传因素" class="level4">
<h4 class="anchored" data-anchor-id="罕见变异但效应较低难以检测的遗传因素">罕见变异但效应较低：难以检测的遗传因素</h4>
<ul>
<li>特点：这种变异影响微弱且在人群中极其罕见，目前的技术难以发现其对疾病的潜在作用。</li>
<li>挑战：需要结合更大规模数据和功能实验加以探索。</li>
</ul>
</section>
</section>
<section id="为什么这对研究很重要" class="level3">
<h3 class="anchored" data-anchor-id="为什么这对研究很重要">为什么这对研究很重要？</h3>
<section id="揭示疾病的遗传基础" class="level4">
<h4 class="anchored" data-anchor-id="揭示疾病的遗传基础">揭示疾病的遗传基础</h4>
<p>理解等位基因频率和效应大小的关系，有助于解析不同变异在疾病发生中的作用。对于孟德尔遗传病，关注高效应大小的罕见变异；而对于复杂疾病，更多地关注常见变异和低频变异的累积效应。</p>
</section>
<section id="优化疾病预测与治疗" class="level4">
<h4 class="anchored" data-anchor-id="优化疾病预测与治疗">优化疾病预测与治疗</h4>
<p>高效应变异可以作为明确的诊断标志物，用于早期筛查和治疗设计。低效应变异为复杂疾病的风险预测提供信息，通过多基因风险预测模型提高预测准确性，能够为个性化医疗和疾病干预策略提供新思路，从而推动精准医学发展。</p>


<!-- -->

</section>
</section>

 ]]></description>
  <category>maf</category>
  <category>gwas</category>
  <category>mendelian disease</category>
  <guid>https://leslie-lu.github.io/blog/2024/12/20/maf/</guid>
  <pubDate>Fri, 20 Dec 2024 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202412202301424.webp" medium="image" type="image/webp"/>
</item>
<item>
  <title>深入了解 VCF/VCF.GZ/VCF.GZ.TBI 文件</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/12/19/vcf/</link>
  <description><![CDATA[ 





<p>在生物信息学研究中，变异数据的存储和分析是核心任务之一。而 VCF 文件（Variant Call Format）作为广泛使用的文件格式，几乎贯穿了从测序数据到变异注释和分析的整个流程。这里，我们将深入探讨 VCF 及其相关的压缩文件（VCF.GZ）和索引文件（VCF.GZ.TBI），帮助大家更好地理解这些文件及其应用场景。</p>
<section id="什么是-vcf-文件" class="level3">
<h3 class="anchored" data-anchor-id="什么是-vcf-文件">什么是 VCF 文件？</h3>
<p>VCF（Variant Call Format）文件是一种专为存储基因组变异数据设计的文件格式，它可以记录不同个体或样本中的突变信息，包括单核苷酸变异（SNP）、插入和缺失（InDels）以及结构变异（SVs）。</p>
<p>VCF文件具有以下主要特点： - 文本格式：易于读取和解析，便于集成到各种分析工具中。 - 可扩展性：支持通过 INFO 字段存储额外的变异注释。 - 标准化：通过一致的格式定义，保证跨研究和工具的兼容性。</p>
</section>
<section id="vcf-文件的结构" class="level3">
<h3 class="anchored" data-anchor-id="vcf-文件的结构">VCF 文件的结构</h3>
<p>一个典型的 VCF 文件由两部分组成：</p>
<section id="header头部" class="level4">
<h4 class="anchored" data-anchor-id="header头部">Header（头部）</h4>
<p>以#开头，包含文件的元信息，如 VCF 版本、参考基因组、字段定义等。例如：</p>
<pre class="{bash}"><code>#fileformat=VCFv4.2
##reference=GRCh38
##INFO=&lt;ID=AF,Number=A,Type=Float,Description="Allele Frequency"&gt;
#CHROM POS ID REF ALT QUAL FILTER INFO FORMAT SAMPLE1 SAMPLE2</code></pre>
<p><code>#CHROM</code>：染色体编号；<code>POS</code>：变异在基因组上的位置；<code>ID</code>：变异的标识符（如 rsID）；<code>REF</code> 和 <code>ALT</code>：参考等位基因和替代等位基因。</p>
</section>
<section id="data数据部分" class="level4">
<h4 class="anchored" data-anchor-id="data数据部分">Data（数据部分）</h4>
<p>存储实际的变异信息，每行记录一个变异。例如：</p>
<pre class="{bash}"><code>1  123456  rs123456  A  G  50  PASS  AF=0.1  GT:AD:DP  0/1:5,10:15  0/0:20,0:20</code></pre>
<p>这里记录了第 1 号染色体上第 123456 位的一个 SNP，参考碱基是 A，突变碱基是 G。</p>
</section>
</section>
<section id="vcf.gz-文件为什么要压缩" class="level3">
<h3 class="anchored" data-anchor-id="vcf.gz-文件为什么要压缩">VCF.GZ 文件：为什么要压缩？</h3>
<p>由于全基因组测序数据的规模庞大，原始的 VCF 文件往往非常大，这给存储和传输带来了不小的负担。因此，生物信息学领域通常会对 VCF 文件进行压缩，生成 VCF.GZ 文件。</p>
<p>VCF.GZ的特点：</p>
<ul>
<li>基于 Gzip 压缩：VCF.GZ 文件采用 Gzip 算法压缩，具有良好的压缩率。</li>
<li>兼容性强：绝大多数生物信息学工具（如 bcftools、GATK、vcftools 等）都支持直接读取 VCF.GZ 文件。</li>
<li>便于存储和共享：相比未压缩的 VCF 文件，VCF.GZ 文件体积更小，减少了存储成本，并加快了传输速度。</li>
</ul>
<p>要生成VCF.GZ文件，可以使用以下命令：</p>
<pre class="{bash}"><code>bgzip -c input.vcf &gt; input.vcf.gz</code></pre>
</section>
<section id="vcf.gz.tbi-文件加速随机访问的关键" class="level3">
<h3 class="anchored" data-anchor-id="vcf.gz.tbi-文件加速随机访问的关键">VCF.GZ.TBI 文件：加速随机访问的关键</h3>
<p>对于全基因组数据，快速定位某个染色体区域的变异是一项基本需求。索引文件（VCF.GZ.TBI）正是为了解决这一问题而设计的。</p>
<p>VCF.GZ.TBI的作用：</p>
<ul>
<li>快速检索：VCF.GZ.TBI 文件为 VCF.GZ 文件生成了索引，使得工具可以快速定位到特定染色体区域的变异记录。</li>
<li>支持分区分析：在多样本和多染色体的情况下，索引文件显著提升了并行处理的效率。</li>
</ul>
<p>生成索引文件可以使用以下命令：</p>
<pre class="{bash}"><code>tabix -p vcf input.vcf.gz</code></pre>
<p>完成后，会生成一个名为 input.vcf.gz.tbi 的索引文件。</p>
</section>
<section id="vcfvcf.gzvcf.gz.tbi-在实际中的应用" class="level3">
<h3 class="anchored" data-anchor-id="vcfvcf.gzvcf.gz.tbi-在实际中的应用">VCF/VCF.GZ/VCF.GZ.TBI 在实际中的应用</h3>
<section id="存储与共享变异数据" class="level4">
<h4 class="anchored" data-anchor-id="存储与共享变异数据">存储与共享变异数据</h4>
<p>未压缩的 VCF 文件便于直接查看，但更适用于小规模数据集。VCF.GZ 文件更适合大规模数据的存储和共享。</p>
</section>
<section id="加速基因组区域检索" class="level4">
<h4 class="anchored" data-anchor-id="加速基因组区域检索">加速基因组区域检索</h4>
<p>索引文件（VCF.GZ.TBI）在大规模队列分析中尤为重要。如使用 bcftools view 仅提取某条染色体上的特定区域：</p>
<pre class="{bash}"><code>bcftools view -r chr1:100000-200000 input.vcf.gz</code></pre>
</section>
<section id="兼容主流生信工具" class="level4">
<h4 class="anchored" data-anchor-id="兼容主流生信工具">兼容主流生信工具</h4>
<p>几乎所有主流的变异分析工具都支持 VCF 格式及其压缩和索引版本。例如：</p>
<ul>
<li>GATK：进行变异过滤和注释。</li>
<li>vcftools：计算等位基因频率、进行样本过滤。</li>
<li>bcftools：快速子集提取和格式转换。</li>
</ul>
</section>
<section id="云环境中的应用" class="level4">
<h4 class="anchored" data-anchor-id="云环境中的应用">云环境中的应用</h4>
<p>通过压缩后的 VCF.GZ 文件和索引，配合分布式计算框架（如 Spark SQL），可以在云端快速处理大规模变异数据。</p>


<!-- -->

</section>
</section>

 ]]></description>
  <category>vcf</category>
  <category>bioinformatics</category>
  <category>genetics</category>
  <guid>https://leslie-lu.github.io/blog/2024/12/19/vcf/</guid>
  <pubDate>Thu, 19 Dec 2024 00:00:00 GMT</pubDate>
  <media:content url="https://www.researchgate.net/publication/318713795/figure/fig1/AS:520537769877504@1501117283765/ariant-Call-Format-VCF-file-This-is-a-text-file-that-stores-genomic-information-in.png" medium="image" type="image/png"/>
</item>
<item>
  <title>感知机：人工神经网络的起点</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/12/16/perceptron/</link>
  <description><![CDATA[ 





<section id="感知机的诞生人工神经网络的起点" class="level3">
<h3 class="anchored" data-anchor-id="感知机的诞生人工神经网络的起点">感知机的诞生：人工神经网络的起点</h3>
<p>1958年，弗兰克·罗森布拉特（Frank Rosenblatt）在康奈尔大学航空实验室提出了感知机，这是第一个模拟人脑神经元功能的算法模型。感知机的设计灵感来自人脑的神经元连接方式，目标是通过数学模型模仿人类学习的<a href="https://medium.com/@vincentlambert0/it-all-started-with-a-perceptron-86bd0fb80b96" title="medium">过程</a>。</p>
<section id="核心思想" class="level4">
<h4 class="anchored" data-anchor-id="核心思想">核心思想</h4>
<p>感知机的基本功能是进行线性分类。它通过将输入值加权求和后与阈值比较，来决定输出属于哪个类别。简单来说，感知机的输出是一个二元值（如 0 或 1 ），用来表示输入数据所属的类别。</p>
</section>
<section id="数学模型" class="level4">
<h4 class="anchored" data-anchor-id="数学模型">数学模型</h4>
<p>感知机基于以下公式：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0Ay%20=%20f%5Cleft(%5Csum_%7Bi=1%7D%5E%7Bn%7D%20w_i%20x_i%20+%20b%5Cright)%0A"></p>
</section>
</section>
<section id="感知机的局限性xor-问题的挑战" class="level3">
<h3 class="anchored" data-anchor-id="感知机的局限性xor-问题的挑战">感知机的局限性：XOR 问题的挑战</h3>
<p>尽管感知机在某些任务中表现良好，但其能力受到线性可分性限制。1969年，著名的《Perceptrons》一书由马文·明斯基（Marvin Minsky）和西摩·帕珀特（Seymour Papert）撰写，他们指出感知机无法解决非线性可分的问题，例如XOR问题。感知机只能通过一条直线分割两个类别的数据点。当数据分布无法用一条直线区分（如 XOR 问题），感知机便无能为力。这一挑战让研究者认识到，单层感知机无法胜任复杂任务，需要更复杂的多层结构来解决。</p>
<div id="8be07b3e" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">class</span> Perceptron:</span>
<span id="cb1-2">    <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">__init__</span>(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>, input_size, learning_rate<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.01</span>, epochs<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1000</span>):</span>
<span id="cb1-3">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Initialize weights to zeros, with one extra weight for the bias</span></span>
<span id="cb1-4">        <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.weights <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.zeros(input_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>)  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># +1 for the bias</span></span>
<span id="cb1-5">        <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.learning_rate <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> learning_rate  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Learning rate controls weight updates</span></span>
<span id="cb1-6">        <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.epochs <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> epochs  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Number of iterations over the training data</span></span>
<span id="cb1-7"></span>
<span id="cb1-8">    <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> activation_function(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>, x):</span>
<span id="cb1-9">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Apply step function: return 1 if x &gt;= 0, else return 0</span></span>
<span id="cb1-10">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span> <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> x <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span> <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">else</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span></span>
<span id="cb1-11"></span>
<span id="cb1-12">    <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> predict(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>, x):</span>
<span id="cb1-13">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Compute the weighted sum (dot product), including bias</span></span>
<span id="cb1-14">        z <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.weights.T.dot(np.insert(x, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>))  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Insert bias term into input</span></span>
<span id="cb1-15">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.activation_function(z)</span>
<span id="cb1-16"></span>
<span id="cb1-17">    <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> train(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>, X, y):</span>
<span id="cb1-18">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> _ <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.epochs):</span>
<span id="cb1-19">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> xi, target <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">zip</span>(X, y):</span>
<span id="cb1-20">                prediction <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.predict(xi)</span>
<span id="cb1-21">                error <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> target <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> prediction</span>
<span id="cb1-22">                update <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.learning_rate <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> error</span>
<span id="cb1-23">                </span>
<span id="cb1-24">                <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.weights[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>:] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+=</span> update <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> xi </span>
<span id="cb1-25">                <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.weights[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+=</span> update</span>
<span id="cb1-26"></span>
<span id="cb1-27"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Training data (XOR logic)</span></span>
<span id="cb1-28">X <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.array([[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>], [<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>], [<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>], [<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>]])</span>
<span id="cb1-29">y <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.array([<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>])</span></code></pre></div>
</div>
</section>
<section id="多层感知机mlp的出现突破局限" class="level3">
<h3 class="anchored" data-anchor-id="多层感知机mlp的出现突破局限">多层感知机（MLP）的出现：突破局限</h3>
<p>为了克服单层感知机的局限性，研究者提出了多层感知机（Multi-Layer Perceptron, MLP）。它通过引入隐藏层和非线性激活函数（如 sigmoid 函数），实现了对复杂数据的学习能力。1986 年，David Rumelhart等人提出了反向传播（Backpropagation）算法，这使得训练多层感知机变得可行。该算法通过梯度下降更新权重，优化了模型性能。此外，隐藏层中的非线性激活函数打破了单层感知机的线性限制，使模型能够处理复杂的非线性关系。</p>
<div id="f3025779" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> tensorflow.keras.models <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> Sequential</span>
<span id="cb2-2"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> tensorflow.keras.layers <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> Dense, Input</span>
<span id="cb2-3"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> tensorflow.keras.optimizers <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> Adam</span>
<span id="cb2-4"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">class</span> MLPerceptron:</span>
<span id="cb2-5">    <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">__init__</span>(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>, input_size, learning_rate<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.05</span>, epochs<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2000</span>):</span>
<span id="cb2-6">        <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.input_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> input_size</span>
<span id="cb2-7">        <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.learning_rate <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> learning_rate</span>
<span id="cb2-8">        <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.epochs <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> epochs</span>
<span id="cb2-9">        <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.model <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> Sequential()</span>
<span id="cb2-10">        <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.model.add(Input((input_size,)))  </span>
<span id="cb2-11">        <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.model.add(Dense(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>, activation<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"tanh"</span>, ))  </span>
<span id="cb2-12">        <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.model.add(Dense(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, activation<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"sigmoid"</span>)) </span>
<span id="cb2-13">        <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.model.<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">compile</span>(</span>
<span id="cb2-14">            loss<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"binary_crossentropy"</span>, optimizer<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"adam"</span>, metrics<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>[<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"accuracy"</span>]</span>
<span id="cb2-15">        )</span>
<span id="cb2-16"></span>
<span id="cb2-17">    <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> train(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>, X, y):</span>
<span id="cb2-18">        <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.model.fit(X, y, epochs<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.epochs, verbose<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>)</span>
<span id="cb2-19"></span>
<span id="cb2-20">    <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> predict(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>, x):</span>
<span id="cb2-21">        prediction <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.model.predict(np.array([x]))</span>
<span id="cb2-22">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span> <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> prediction <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.5</span> <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">else</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>  </span></code></pre></div>
</div>
</section>
<section id="感知机的现代继承者" class="level3">
<h3 class="anchored" data-anchor-id="感知机的现代继承者">感知机的现代继承者</h3>
<p>虽然感知机本身不再是当前人工智能的核心技术，但它为后续技术的发展奠定了重要基础。现代深度学习模型（如卷积神经网络、循环神经网络）可以被视为感知机的扩展和进化。多层感知机推动了深度神经网络的研究热潮，尤其是在 2010 年代 GPU 计算力提升后，深度学习应用于图像识别、自然语言处理等领域。感知机的提出使得研究者开始探索机器如何<code>学习</code>这一基本问题，也激发了人工智能领域的快速发展。</p>
</section>
<section id="感知机的意义与启示" class="level3">
<h3 class="anchored" data-anchor-id="感知机的意义与启示">感知机的意义与启示</h3>
<p>感知机的历史体现了技术发展的非线性特性：早期的技术突破可能因为局限性而受到批评，但它们却是后续更复杂技术的基石。感知机虽然简单，但它的概念推动了我们对人类学习过程和计算机模拟的理解。虽然感知机的局限曾导致人工智能研究进入<code>低谷期</code>（AI冬天），但最终多层感知机证明了它的价值。</p>


<!-- -->

</section>

 ]]></description>
  <category>perceptron</category>
  <category>artificial neural network</category>
  <category>machine learning</category>
  <category>deep learning</category>
  <guid>https://leslie-lu.github.io/blog/2024/12/16/perceptron/</guid>
  <pubDate>Mon, 16 Dec 2024 00:00:00 GMT</pubDate>
  <media:content url="https://miro.medium.com/v2/resize:fit:828/format:webp/1*6OkGcBSlGpA5TtlRxhF6zA.png" medium="image" type="image/png"/>
</item>
<item>
  <title>DNAnexus 表型数据提取</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/12/11/table_exporter/</link>
  <description><![CDATA[ 





<p>自从 UK Biobank 数据必须在 DNAnexus 上操作后，我们不得不使用 UKB 的付费平台。DNAnexus 是一个功能强大的云平台，提供了多种工具来处理、分析和可视化大规模基因组数据。在研究中，表型数据（如疾病状态、实验测量值、临床记录等）是理解基因与环境因素相互作用的重要资源。DNAnexus 提供了 <code>Table Exporter</code> 工具以及 <code>dx extract_dataset</code>，帮助研究人员从数据库中高效提取表型数据，并将其导出为可分析的格式。</p>
<p>在这篇文章中，我们将介绍如何在 DNAnexus 上使用 Table Exporter 提取表型数据。</p>
<section id="table-exporter-简介" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="table-exporter-简介">Table Exporter 简介</h3>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202412111909627.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">Table Exporter</figcaption>
</figure>
</div>
<p>Table Exporter 是 DNAnexus 提供的一项功能，允许用户从项目中提取存储的表型数据，并根据需要导出为 CSV、TSV 或 SQL 格式的文件。这些文件可以包含参与者的各种表型信息，如年龄、性别、疾病状态、基因型等。该工具的灵活性使得它不仅适用于小规模数据提取，还能够处理大规模的数据集，支持定制化字段的选择，以及针对特定需求的格式化输出。</p>
</section>
<section id="如何使用-table-exporter-提取数据" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="如何使用-table-exporter-提取数据">如何使用 Table Exporter 提取数据</h3>
<section id="步骤-1登录-dnanexus-平台" class="level4">
<h4 class="anchored" data-anchor-id="步骤-1登录-dnanexus-平台">步骤 1：登录 DNAnexus 平台</h4>
<p>首先，确保你已经拥有 DNAnexus 帐号并登录。若没有帐户，可以在 DNAnexus 官方网站申请注册。登录后，你将进入 Project Dashboard，即你的项目仪表板。</p>
</section>
<section id="步骤-2选择项目" class="level4">
<h4 class="anchored" data-anchor-id="步骤-2选择项目">步骤 2：选择项目</h4>
<p>在仪表板中，选择包含你需要提取表型数据的项目。你可以选择已有的项目，或者新建一个项目。</p>
</section>
<section id="步骤-3配置-table-exporter" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="步骤-3配置-table-exporter">步骤 3：配置 Table Exporter</h4>
<p>在项目中找到 Table Exporter 工具，并点击进入配置界面。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202412111911044.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">Table Exporter 配置</figcaption>
</figure>
</div>
<p>在此界面中，你需要选择要导出的表型数据字段。这些字段通常是与研究目标相关的变量，例如： 年龄、性别、疾病状态、身高、体重等基本信息。Table Exporter 支持将数据导出为不同格式：CSV：适用于大多数数据分析工具（如 Excel、R、Python 等），能够以表格形式查看。TSV：适合更大数据量的处理，且与数据库中的表格数据兼容性更高。SQL：如果你希望导出为 SQL 查询格式，用于后续数据库查询，可以选择此格式。选择适合你需求的导出格式后，点击 Next 进入下一步。在导出时，Table Exporter 还提供了一些额外的输出选项：字段名称（Field Names）：你可以选择导出数据时是否包括字段名称作为表头。数据过滤（Data Filtering）：根据需要，可以设置过滤条件，仅导出符合条件的数据。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202412111915368.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">advanced option</figcaption>
</figure>
</div>
<p>配置完成后，点击 Start Export 按钮，DNAnexus 将开始生成导出的数据文件。根据数据量的不同，可能需要一些时间来处理。你可以在 Job History（作业历史）中查看任务进度。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202412111917226.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">job history</figcaption>
</figure>
</div>


<!-- -->

</section>
</section>

 ]]></description>
  <category>dnanexus</category>
  <category>phenotype</category>
  <category>table exporter</category>
  <guid>https://leslie-lu.github.io/blog/2024/12/11/table_exporter/</guid>
  <pubDate>Wed, 11 Dec 2024 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202412111909627.png" medium="image" type="image/png"/>
</item>
<item>
  <title>Ubuntu 20.04 上安装 R</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/12/04/install_r_on_ubuntu/</link>
  <description><![CDATA[ 





<p>如果你是 Ubuntu 用户，并且打算安装 R 语言环境来进行数据分析、统计计算或者数据科学工作，本文将为你提供一个详细的安装步骤。</p>
<p>从下载源代码到配置必要的依赖项，我们将一步步带你完成整个过程。</p>
<section id="更新系统包管理器" class="level3">
<h3 class="anchored" data-anchor-id="更新系统包管理器">1. 更新系统包管理器</h3>
<p>首先，我们需要确保系统包管理器是最新的。运行以下命令来更新 APT 源，并执行系统的全面升级。</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb1-1"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">sudo</span> apt update</span>
<span id="cb1-2"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">sudo</span> apt full-upgrade</span>
<span id="cb1-3"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">sudo</span> apt autoremove</span></code></pre></div>
<p>这三条命令将会更新你的软件包列表，升级现有软件包，并移除不再需要的包，保持系统整洁。</p>
</section>
<section id="下载-r-源代码" class="level3">
<h3 class="anchored" data-anchor-id="下载-r-源代码">2. 下载 R 源代码</h3>
<p>由于 R 的最新版本可以通过源代码安装，这里我们选择手动下载 R 4.4.2 版本的源代码包，并解压。</p>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb2-1"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">wget</span> https://cran.r-project.org/src/base/R-4/R-4.4.2.tar.gz</span>
<span id="cb2-2"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">tar</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-xvzf</span> R-4.4.2.tar.gz</span></code></pre></div>
<p>解压完成后，你会看到一个名为 R-4.4.2 的文件夹。</p>
</section>
<section id="安装必要的依赖项" class="level3">
<h3 class="anchored" data-anchor-id="安装必要的依赖项">3. 安装必要的依赖项</h3>
<p>R 的编译需要一些库和工具，所以需要先安装依赖项。运行以下命令来安装缺失的库：</p>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb3-1"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">sudo</span> apt install <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-y</span> libx11-dev libxext-dev libxmu-dev libxt-dev</span>
<span id="cb3-2"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">sudo</span> apt install <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-y</span> libdeflate-dev texinfo texlive-base texlive-fonts-recommended texlive-fonts-extra texlive-latex-base texlive-latex-extra latexmk libcurl4-openssl-dev libxml2-dev libxt-dev pandoc ghostscript</span></code></pre></div>
</section>
<section id="编译-r" class="level3">
<h3 class="anchored" data-anchor-id="编译-r">4. 编译 R</h3>
<p>在安装完所有依赖项之后，我们可以开始编译 R。首先创建一个目录来存放 R 的安装文件：</p>
<div class="sourceCode" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb4-1"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">mkdir</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-p</span> ~/software/r/r-4.4.2</span></code></pre></div>
<p>然后进入到 R 的源代码目录，使用 <code>./configure</code> 命令来配置编译选项，然后使用 <code>make</code> 命令开始编译：</p>
<div class="sourceCode" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb5-1"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">cd</span> R-4.4.2/</span>
<span id="cb5-2"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">./configure</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">--prefix</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">$HOME</span>/software/r/r-4.4.2</span>
<span id="cb5-3"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">make</span></span></code></pre></div>
<p>这一步可能需要一些时间，具体时间取决于你的机器配置。</p>
</section>
<section id="安装-java-环境可选" class="level3">
<h3 class="anchored" data-anchor-id="安装-java-环境可选">5. 安装 Java 环境（可选）</h3>
<p>如果你需要在 R 中运行与 Java 相关的功能，比如使用 rJava 包，可能需要安装 Java。可以运行以下命令来检查 Java 版本并安装 OpenJDK 11：</p>
<div class="sourceCode" id="cb6" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb6-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">java</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-version</span></span>
<span id="cb6-2"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">sudo</span> apt install openjdk-11-jre-headless</span></code></pre></div>
<p>然后设置 Java 的环境变量：</p>
<div class="sourceCode" id="cb7" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb7-1"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">echo</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">$JAVA_HOME</span></span>
<span id="cb7-2"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">sudo</span> update-alternatives <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">--config</span> java</span></code></pre></div>
<p>编辑 <code>~/.bashrc</code> 文件，添加 JAVA_HOME 变量的配置：</p>
<div class="sourceCode" id="cb8" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb8-1"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">vi</span> ~/.bashrc</span>
<span id="cb8-2"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 在文件末尾添加如下内容：</span></span>
<span id="cb8-3"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">export</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">JAVA_HOME</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>/usr/lib/jvm/java-11-openjdk-amd64 <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#具体路径根据你的安装路径而定</span></span>
<span id="cb8-4"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">export</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">PATH</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">$JAVA_HOME</span>/bin:<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">$PATH</span></span></code></pre></div>
<p>保存并退出后，使用以下命令使更改生效：</p>
<div class="sourceCode" id="cb9" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb9-1"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">source</span> ~/.bashrc</span></code></pre></div>
</section>
<section id="完成-r-安装" class="level3">
<h3 class="anchored" data-anchor-id="完成-r-安装">6. 完成 R 安装</h3>
<p>在完成所有必要的配置后，可以将 R 安装到指定目录。然后，进入到 <code>R-4.4.2</code> 的文件夹中，运行以下命令来安装 R：</p>
<div class="sourceCode" id="cb10" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb10-1"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">sudo</span> make install</span></code></pre></div>
</section>
<section id="验证安装" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="验证安装">7. 验证安装</h3>
<p>安装完成后，可以通过运行以下命令来验证 R 是否安装成功：</p>
<div class="sourceCode" id="cb11" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb11-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">R</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">--version</span></span></code></pre></div>
<p>如果返回的是 R 的版本信息，那么说明安装已经成功。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202412042352774.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">R 安装成功</figcaption>
</figure>
</div>


<!-- -->

</section>

 ]]></description>
  <category>r</category>
  <category>ubuntu</category>
  <category>linux</category>
  <guid>https://leslie-lu.github.io/blog/2024/12/04/install_r_on_ubuntu/</guid>
  <pubDate>Wed, 04 Dec 2024 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202412042352774.png" medium="image" type="image/png"/>
</item>
<item>
  <title>Swiss Army Knife 工具运行 R 的 log 记录</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/12/03/DNAnexus_log/</link>
  <description><![CDATA[ 





<p>用 DNAnexus 平台上的 Swiss Army Knife 工具运行了下 R，记录下运行的 log。</p>
<p>这个日志记录了任务的执行过程，其中涉及到多个文件的下载、解压和执行。下面是对这个日志的详细解释：</p>
<section id="初始化日志记录" class="level4">
<h4 class="anchored" data-anchor-id="初始化日志记录">1. 初始化日志记录</h4>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb1-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">Logging</span> initialized <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">(</span><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">priority</span><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">)</span></span>
<span id="cb1-2"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">Logging</span> initialized <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">(</span><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">bulk</span><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">)</span></span></code></pre></div>
<p>以上表示日志记录系统已经初始化，准备开始记录任务的执行情况。<code>priority</code> 和 <code>bulk</code> 表示不同级别或不同类型的日志记录。</p>
</section>
<section id="下载和解压文件" class="level4">
<h4 class="anchored" data-anchor-id="下载和解压文件">2. 下载和解压文件</h4>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb2-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">Downloading</span> bundled file resources.tar.gz</span>
<span id="cb2-2"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;&gt;&gt;</span> Unpacking <span class="ex" style="color: null;
background-color: null;
font-style: inherit;">resources.tar.gz</span> to /</span>
<span id="cb2-3"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">tar:</span> Removing leading <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">`</span><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">/</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">' from member names</span></span></code></pre></div>
<p>省略了一些类似的 log 输出，表明有多个文件（如 <code>resources.tar.gz</code>, <code>qctool.tar.gz</code>, <code>plink.tar.gz</code> 等）被依次下载并解压。<code>tar: Removing leading '/' from member names</code>：这是 <code>tar</code> 解压时的标准行为，表示会删除文件路径中的首个 <code>/</code>，避免解压到根目录（<code>/</code>）而覆盖系统文件。</p>
</section>
<section id="设置-ssh-公钥" class="level4">
<h4 class="anchored" data-anchor-id="设置-ssh-公钥">3. 设置 SSH 公钥</h4>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb3-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">Setting</span> SSH public key</span></code></pre></div>
<p>这里系统设置了一个 SSH 公钥，可能用于与远程服务器的连接。</p>
</section>
<section id="安装和运行环境信息" class="level4">
<h4 class="anchored" data-anchor-id="安装和运行环境信息">4. 安装和运行环境信息</h4>
<div class="sourceCode" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb4-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">dxpy/0.385.0</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">(</span><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">Linux-5.15.0-1072-aws-x86_64-with-glibc2.29</span><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">)</span> <span class="ex" style="color: null;
background-color: null;
font-style: inherit;">Python/3.8.10</span></span>
<span id="cb4-2"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">bash</span> running <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">(</span><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">job</span> ID job-xxxx<span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">)</span></span></code></pre></div>
<p><code>dxpy</code> 是用于与 DNAnexus 平台交互的 Python 库。运行环境是 Linux（版本 5.15.0-1072-aws），使用 Python 3.8.10。作业 ID 是 <code>job-xxxx</code>，表示当前任务在平台上的唯一标识符。</p>
</section>
<section id="下载文件到本地文件系统" class="level4">
<h4 class="anchored" data-anchor-id="下载文件到本地文件系统">5. 下载文件到本地文件系统</h4>
<div class="sourceCode" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb5-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">downloading</span> file: file-xxxx to filesystem: /home/dnanexus/in/in/0/hello_world.r</span></code></pre></div>
<p>从 DNAnexus 平台下载了名为 <code>hello_world.r</code> 的文件，并将其保存到 <code>/home/dnanexus/in/in/0/</code> 目录。</p>
</section>
<section id="dxfuse-版本信息和文件系统守护进程" class="level4">
<h4 class="anchored" data-anchor-id="dxfuse-版本信息和文件系统守护进程">6. dxfuse 版本信息和文件系统守护进程</h4>
<div class="sourceCode" id="cb6" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb6-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">Using</span> dxfuse version v1.4.0</span>
<span id="cb6-2"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">The</span> log file is located at /root/.dxfuse/dxfuse.log</span>
<span id="cb6-3"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">starting</span> fs daemon</span>
<span id="cb6-4"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">wait</span> for ready</span>
<span id="cb6-5"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">Daemon</span> started successfully</span></code></pre></div>
<p>使用 <code>dxfuse</code> （一个用于将 DNAnexus 文件系统挂载到本地文件系统的工具）版本 1.4.0。启动了文件系统守护进程，用于与 DNAnexus 文件系统进行交互。</p>
</section>
<section id="下载文件使用多个线程" class="level4">
<h4 class="anchored" data-anchor-id="下载文件使用多个线程">7. 下载文件使用多个线程</h4>
<div class="sourceCode" id="cb7" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb7-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">Downloading</span> files using 4 threads+ [[ <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">''</span> == <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">''</span> ]]</span></code></pre></div>
<p>文件的下载是并行进行的，使用了 4 个线程来加速下载。</p>
</section>
<section id="执行-r-脚本" class="level4">
<h4 class="anchored" data-anchor-id="执行-r-脚本">8. 执行 R 脚本</h4>
<div class="sourceCode" id="cb8" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb8-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">+</span> eval <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'Rscript hello_world.r'</span></span>
<span id="cb8-2"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">++</span> Rscript hello_world.r</span>
<span id="cb8-3"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">[1]</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Hello, world!"</span></span></code></pre></div>
<p>执行了 R 脚本 hello_world.r，并成功输出了 “Hello, world!”，表明脚本运行成功。</p>
</section>
<section id="完成任务" class="level4">
<h4 class="anchored" data-anchor-id="完成任务">9. 完成任务</h4>
<div class="sourceCode" id="cb9" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb9-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">+</span> set +x</span></code></pre></div>
<p>这是一个 Shell 命令，表示关闭命令回显模式。+x 表示在执行时打印每条命令的详细信息，关闭后将不再显示。</p>


<!-- -->

</section>

 ]]></description>
  <category>dnanexus</category>
  <category>r</category>
  <category>log</category>
  <category>swiss army knife</category>
  <guid>https://leslie-lu.github.io/blog/2024/12/03/DNAnexus_log/</guid>
  <pubDate>Tue, 03 Dec 2024 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202412032312284.png" medium="image" type="image/png"/>
</item>
<item>
  <title>使用 SAIGE 进行 GWAS 分析的详细流程</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/12/02/SAIGE_GWAS/</link>
  <description><![CDATA[ 





<p><a href="https://documentation.dnanexus.com/science/scientific-guides/saige-gwas-walkthrough" title="SAIGE GWAS">本文</a>介绍如何基于 UK Biobank 数据和 DNAnexus 平台，使用 <strong>SAIGE</strong> 工具在大规模基因组关联研究（GWAS）中分析遗传变异与性状之间的关联。SAIGE 的简要介绍参考<a href="https://mp.weixin.qq.com/s/pCfu0tJxvvRIHqtbK9eSug">这里</a>。</p>
<section id="流程概览" class="level3">
<h3 class="anchored" data-anchor-id="流程概览"><strong>流程概览</strong></h3>
<p>SAIGE GWAS 分析分为以下步骤：</p>
<ol type="1">
<li><strong>准备数据：合并自测基因型数据</strong></li>
<li><strong>生成 GRM 模型和方差比文件</strong></li>
<li><strong>执行单变异关联测试</strong></li>
<li><strong>（可选）合并结果文件</strong></li>
</ol>
</section>
<section id="step-1-合并自测基因型数据" class="level3">
<h3 class="anchored" data-anchor-id="step-1-合并自测基因型数据"><strong>Step 1: 合并自测基因型数据</strong></h3>
<p>在第一步中，我们将 22 条常染色体的基因型数据文件合并为 PLINK 格式的文件集（<code>.bim</code>, <code>.bed</code>, <code>.fam</code>），为后续分析生成输入文件。</p>
<section id="使用-swiss-army-knife-sak-应用" class="level4">
<h4 class="anchored" data-anchor-id="使用-swiss-army-knife-sak-应用"><strong>使用 Swiss Army Knife (SAK) 应用</strong></h4>
<p>在 DNAnexus 平台上，使用 <strong>Swiss Army Knife (SAK)</strong> 应用完成文件合并：</p>
<ol type="1">
<li><strong>输入文件</strong>：上传或选择包含染色体 1 至 22 的 PLINK 文件。</li>
<li><strong>命令行代码</strong>：</li>
</ol>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb1-1"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">ls</span> <span class="pp" style="color: #AD0000;
background-color: null;
font-style: inherit;">*</span>.bed <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">|</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">sed</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-e</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'s/.bed//g'</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;</span> files_to_merge.txt<span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">;</span></span>
<span id="cb1-2"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">plink</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">--merge-list</span> files_to_merge.txt <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">--make-bed</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">--out</span> ukb_cal_chr1_22_v2_merged<span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">;</span></span>
<span id="cb1-3"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rm</span> files_to_merge.txt<span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">;</span></span></code></pre></div>
<p>这段代码会创建一个包含所有待合并文件的列表，并使用 PLINK 将其合并为单一文件集。</p>
<ol start="3" type="1">
<li><strong>输出</strong>：<code>ukb_cal_chr1_22_v2_merged.bed</code>、<code>.bim</code>&nbsp;和&nbsp;<code>.fam</code>&nbsp;文件，作为下一步的输入。</li>
</ol>
</section>
</section>
<section id="step-2-生成-grm-模型和方差比文件" class="level3">
<h3 class="anchored" data-anchor-id="step-2-生成-grm-模型和方差比文件"><strong>Step 2: 生成 GRM 模型和方差比文件</strong></h3>
<p>使用 <strong><code>saige_gwas_grm</code></strong> 应用生成遗传相关矩阵（GRM）模型文件和方差比文件。这些文件用于混合模型的拟合和关联测试。</p>
<section id="输入文件" class="level4">
<h4 class="anchored" data-anchor-id="输入文件"><strong>输入文件</strong></h4>
<ol type="1">
<li><p><strong>PLINK 文件集</strong>：<code>ukb_cal_chr1_22_v2_merged</code> 文件。</p></li>
<li><p><strong>表型文件</strong>：包含样本 ID、表型和协变量（如性别、年龄）的文件，要求与基因型数据匹配。</p></li>
</ol>
</section>
<section id="命令实例" class="level4">
<h4 class="anchored" data-anchor-id="命令实例">命令实例</h4>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb2-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">dx</span> run saige_gwas_grm <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\</span></span>
<span id="cb2-2">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-igenotype_file</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>ukb_cal_chr1_22_v2_merged.bed <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\</span></span>
<span id="cb2-3">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-iphenotype_file</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>phenotype.txt <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\</span></span>
<span id="cb2-4">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-icovariate_columns</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>age,sex <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\</span></span>
<span id="cb2-5">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-imem_instance</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>mem3_ssd1_v2_x32</span></code></pre></div>
</section>
</section>
<section id="step-3-执行单变异关联测试" class="level3">
<h3 class="anchored" data-anchor-id="step-3-执行单变异关联测试"><strong>Step 3: 执行单变异关联测试</strong></h3>
<p>单变异关联测试使用 <strong><code>saige_gwas_svat</code></strong> 应用逐染色体进行分析，计算每个变异与表型之间的关联。</p>
<section id="批量运行" class="level4">
<h4 class="anchored" data-anchor-id="批量运行"><strong>批量运行</strong></h4>
<p>对于 UK Biobank 数据，每条染色体的数据存储在单独的 BGEN 文件中，可以使用批量模式运行：</p>
<ol type="1">
<li><p><strong>选择 BGEN 文件和索引文件</strong>：每条染色体的 <strong><code>.bgen</code></strong> 和 <strong><code>.bgen.bgi</code></strong> 文件。</p></li>
<li><p><strong>运行命令</strong>：</p>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb3-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">dx</span> run saige_gwas_svat <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\</span></span>
<span id="cb3-2">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-igenotypes_bgen</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>chr<span class="pp" style="color: #AD0000;
background-color: null;
font-style: inherit;">*</span>.bgen <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\</span></span>
<span id="cb3-3">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-igenotypes_bgen_index</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>chr<span class="pp" style="color: #AD0000;
background-color: null;
font-style: inherit;">*</span>.bgen.bgi <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\</span></span>
<span id="cb3-4">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-imodel_rda</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>model.rda <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\</span></span>
<span id="cb3-5">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-ivariance_ratio_txt</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>variance_ratio.txt <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\</span></span>
<span id="cb3-6">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-iphenotype_file</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>phenotype.txt <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\</span></span>
<span id="cb3-7">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-imem_instance</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>mem3_ssd3_v2_x24</span></code></pre></div></li>
</ol>
</section>
<section id="输出文件" class="level4">
<h4 class="anchored" data-anchor-id="输出文件"><strong>输出文件</strong></h4>
<ul>
<li>每条染色体的关联结果文件，例如：<code>saige_step2_ukb_imp_chr1_v3.txt</code>。</li>
</ul>
</section>
</section>
<section id="step-4-合并结果文件" class="level3">
<h3 class="anchored" data-anchor-id="step-4-合并结果文件"><strong>Step 4: 合并结果文件</strong></h3>
<p>可选地将所有染色体的结果文件合并为单一文件，以便进一步分析（如显著性筛选和孟德尔随机化分析）。</p>
<section id="使用-sak-应用" class="level4">
<h4 class="anchored" data-anchor-id="使用-sak-应用"><strong>使用 SAK 应用</strong></h4>
<p>在 SAK 的命令行中执行以下代码：</p>
<div class="sourceCode" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb4-1"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">head</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-1</span> saige_step2_ukb_imp_chr1_v3.txt <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;</span> saige_step2_ukb_imp_all_chr.txt<span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">;</span></span>
<span id="cb4-2"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">tail</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-n</span> +2 <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-q</span> saige_step2_ukb_imp_chr<span class="pp" style="color: #AD0000;
background-color: null;
font-style: inherit;">*</span>_v3.txt <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;&gt;</span> saige_step2_ukb_imp_all_chr.txt<span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">;</span></span>
<span id="cb4-3"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">gzip</span> saige_step2_ukb_imp_all_chr.txt<span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">;</span></span></code></pre></div>
</section>
</section>
<section id="后续分析" class="level3">
<h3 class="anchored" data-anchor-id="后续分析"><strong>后续分析</strong></h3>
<ol type="1">
<li><p><strong>显著性筛选</strong>：根据 GWAS 的统计学标准筛选显著变异（如 p 值 &lt;5×10<sup>−8</sup>）。</p></li>
<li><p><strong>下游分析</strong>：</p></li>
</ol>
<ul>
<li>使用显著变异进行孟德尔随机化分析。</li>
<li>进行生物学功能注释，识别潜在的致病基因或路径。</li>
</ul>


<!-- -->

</section>

 ]]></description>
  <category>saige</category>
  <category>gwas</category>
  <category>genomics</category>
  <guid>https://leslie-lu.github.io/blog/2024/12/02/SAIGE_GWAS/</guid>
  <pubDate>Mon, 02 Dec 2024 00:00:00 GMT</pubDate>
  <media:content url="https://saigegit.github.io/SAIGE-doc/assets/img/saige-siage-gene-outline.png" medium="image" type="image/png"/>
</item>
<item>
  <title>星球 JC | 解读 TRIPOD-AI</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/11/29/TRIPOD_AI/</link>
  <description><![CDATA[ 





<blockquote class="blockquote">
<p>大家好，这一期预测模型星球 Journal Club 的分享来自中国医科大学的陈奕含同学。</p>
</blockquote>
<section id="tripod-ai-的制定" class="level3">
<h3 class="anchored" data-anchor-id="tripod-ai-的制定">TRIPOD-AI 的制定</h3>
<p>TRIPOD 协作组于 2015 年公布了《个体预后或诊断的多变量预测模型透明报告》（Transparent Reporting of a Multivariable Prediction Model for Individual Prognosis or Diagnosis，TRIPOD），用以规范预测模型的报告过程；随后为进一步提高报告质量评价的客观性及一致性，协作组于 2019 年公布了 TRIPOD 报告规范依从性评判标准，此标准也可作为提高研究报告准确性和完整性的指导文件。</p>
<p>由于人工智能与机器学习的发展，更多研究将人工智能算法应用于预测模型的开发，因此在前期工作的基础上，TRIPOD 协作组于 2024 年发表了名为 TRIPOD-AI：updated guidance for reporting clinical prediction models that use regression or machine learning methods《TRIPOD-AI：报告使用回归或机器学习方法的临床预测模型的更新指南》的文章，取代 TRIPOD 2015，以此来指导预测模型类文章的报告，提高报告规范性。协作组成员在 TRIPOD 2015 的基础上，结合其他报告中的条目与系统评价的结果，构建了一个唯一候选条目的最终列表，进而进行德尔菲专家修订。通过两轮德尔菲专家会议，包含不同领域的专家。此外，还进行了公众参与会议和共识会议，最终确定了 TRIPOD+AI 声明。</p>
</section>
<section id="tripodai-声明条目" class="level3">
<h3 class="anchored" data-anchor-id="tripodai-声明条目">TRIPOD+AI 声明条目</h3>
<p>TRIPOD+AI 清单包括标题、摘要、引言、方法、开放科学实践、患者和公众参与、结果和讨论等 27 个主要条目。部分条目包含多个子条目，共计 52 个清单子条目。其涵盖了描述预测模型开发、预测模型性能评估(验证)或两者兼而有之的研究。其中，任何项记为 D；E 适用于所有研究，无论是开发预测模型还是评估预测模型的性能。检查表中的 D 项适用于描述预测模型开发的研究，而 E 项适用于评估预测模型性能的研究。对于开发和评估预测模型性能的研究，所有检查表项都适用。</p>
<p>TRIPOD+AI 也为预测模型研究的期刊或会议摘要提供了单独的核查表，并与 TRIPOD+AI 保持一致。另外，PROBAST+AI 用来评估预测模型的质量和偏倚风险。需要注意的是，TRIPOD+AI 中包含的建议是最低限度的报告建议，作者还应提供额外的信息，如在补充材料中报告和引用一些所要求的或补充的信息。TRIPOD+AI 强调了整个清单的公平性，其意味着预测模型的设计和使用方式不会对任何特定群体的个人产生不利的歧视，也不会造成或加剧现有的医疗服务或患者结果方面的不平等。公平性的一个重要方面是确保用于开发或评估预测模型的数据具有代表性和多样性（这些差异应该能够代表预测模型所要使用的人群），并在模型开发过程中承认、处理和缓解数据偏差的限制。为了实现公平目标，清单在背景(项目 3c)、方法(项目 5a、7、8a、8b、9c、12f、14)、结果(项 20b、23a)和讨论(第 25、26 项)中都嵌入了相关内容。</p>
<p>TRIPOD+AI 也添加了开放科学实践的内容，有助于促进透明度、可重复性和研究人员之间的合作。通过注册研究并使研究材料(如协议、数据、代码和预测模型)公开，使其他研究人员可以在新数据中验证研究结果并评估模型性能，以确保模型准确，并评估模型的安全性。在人工智能的背景下，开放科学部分涵盖了资助申报、利益冲突、协议可获得性、研究注册、数据共享、代码共享等方面。</p>
<p><strong>Table 2 预测模型研究报告的 TRIPOD+AI 清单</strong></p>
<table class="caption-top table">
<colgroup>
<col style="width: 13%">
<col style="width: 8%">
<col style="width: 11%">
<col style="width: 66%">
</colgroup>
<thead>
<tr class="header">
<th>段落/主题</th>
<th>条目</th>
<th>开发/评估</th>
<th>清单条目</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>标题</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>标题</td>
<td>1</td>
<td>D；E</td>
<td>将研究确定为开发或评估多变量预测模型的性能、目标人群和待预测结果</td>
</tr>
<tr class="odd">
<td><strong>摘要</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>摘要</td>
<td>2</td>
<td>D；E</td>
<td>摘要检查表见 TRIPOD+AI</td>
</tr>
<tr class="odd">
<td><strong>介绍</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>背景</td>
<td>3a</td>
<td>D；E</td>
<td>解释医疗保健背景(包括无论是诊断性还是预后性)以及开发或评估预测模型的理由，包括对现有模型的参考</td>
</tr>
<tr class="odd">
<td></td>
<td>3b</td>
<td>D；E</td>
<td>描述照护路径情境下预测模型的目标人群和意向目的，包括其意向用户(例如,医疗保健专业人员、患者、公众等)</td>
</tr>
<tr class="even">
<td></td>
<td>3c</td>
<td>D；E</td>
<td>描述任何已知的社会人口群体之间的健康不平等</td>
</tr>
<tr class="odd">
<td>目的</td>
<td>4</td>
<td>D；E</td>
<td>明确研究目的，包括研究是否描述了预测模型的开发或验证(或两者兼而有之)</td>
</tr>
<tr class="even">
<td><strong>方法</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>数据</td>
<td>5a</td>
<td>D；E</td>
<td>分别描述开发和评估数据集(例如,随机试验,队列,常规护理或登记数据)的数据来源、使用这些数据的理由以及数据的代表性</td>
</tr>
<tr class="even">
<td></td>
<td>5b</td>
<td>D；E</td>
<td>指定收集到的参与者数据的日期，包括参与者计提的开始日期和结束日期；并且，如果适用，则结束随访</td>
</tr>
<tr class="odd">
<td>研究对象</td>
<td>6a</td>
<td>D；E</td>
<td>指定研究设置(例如,初级保健、次级保健、普通人群)的关键要素，包括中心的数量和位置</td>
</tr>
<tr class="even">
<td></td>
<td>6b</td>
<td>D；E</td>
<td>描述研究参与者的合格标准</td>
</tr>
<tr class="odd">
<td></td>
<td>6c</td>
<td>D；E</td>
<td>给出接受的任何治疗的细节，以及在模型开发或评估过程中如何处理，如果相关</td>
</tr>
<tr class="even">
<td>数据准备</td>
<td>7</td>
<td>D；E</td>
<td>描述任何数据预处理和质量检查，包括在相关的社会人口统计群体中是否类似</td>
</tr>
<tr class="odd">
<td>结局</td>
<td>8a</td>
<td>D；E</td>
<td>明确定义正在预测的结果和时间范围，包括如何评估和何时评估，选择该结果的理由，以及结果评估的方法是否在社会人口统计学群体中保持一致</td>
</tr>
<tr class="even">
<td></td>
<td>8b</td>
<td>D；E</td>
<td>如果结果评估需要主观解释，请描述结果评估者的资质和人口学特征</td>
</tr>
<tr class="odd">
<td></td>
<td>8c</td>
<td>D；E</td>
<td>报告任何盲目评估预测结局的行为</td>
</tr>
<tr class="even">
<td>预测因子</td>
<td>9a</td>
<td>D</td>
<td>描述初始预测因子(例如,文献,以前的模型,所有可用的预测器)的选择，以及在模型建立之前对预测因子的任何预选择</td>
</tr>
<tr class="odd">
<td></td>
<td>9b</td>
<td>D；E</td>
<td>明确定义所有预测因子，包括如何和何时测量(以及对结果和其他预测因素进行盲法评估的任何行动)</td>
</tr>
<tr class="even">
<td></td>
<td>9c</td>
<td>D；E</td>
<td>如果预测器测量需要主观解释，则描述预测器评估师的资格和人口统计学特征</td>
</tr>
<tr class="odd">
<td>样本量</td>
<td>10</td>
<td>D；E</td>
<td>说明研究规模是如何达到(分别进行开发和评估)的，并证明研究规模足以回答研究问题。包括任何样本量计算的细节</td>
</tr>
<tr class="even">
<td>缺失数据</td>
<td>11</td>
<td>D；E</td>
<td>描述缺失数据是如何处理的。提供省略任何数据的理由</td>
</tr>
<tr class="odd">
<td>分析方法</td>
<td>12a</td>
<td>D</td>
<td>描述数据在分析中如何使用(例如,模型性能的开发和评估)，包括是否对数据进行分区，考虑任何样本量要求</td>
</tr>
<tr class="even">
<td></td>
<td>12b</td>
<td>D</td>
<td>根据模型的类型，描述在(函数形式,重新标度,转换,或任何标准化)分析中如何处理预测因子</td>
</tr>
<tr class="odd">
<td></td>
<td>12c</td>
<td>D</td>
<td>指定模型的类型，基本原理，所有模型构建步骤，包括任何超参数的调整，以及内部验证的方法</td>
</tr>
<tr class="even">
<td></td>
<td>12d</td>
<td>D；E</td>
<td>描述是否以及如何在集群(例如,医院、国家)中处理和量化模型参数值和模型性能的估计中的任何异质性。其他考虑参见 TRIPOD-Cluster</td>
</tr>
<tr class="odd">
<td></td>
<td>12e</td>
<td>D；E</td>
<td>指定所有用于评估模型性能的(及其理论基础)和用于比较多个模型的(如区分度、校准度、临床实用性等) (如果相关)的指标和图</td>
</tr>
<tr class="even">
<td></td>
<td>12f</td>
<td>E</td>
<td>描述由于模型评估而产生的任何模型更新(例如,重新校准)，无论是总体还是针对特定的社会人口群体或设置</td>
</tr>
<tr class="odd">
<td></td>
<td>12g</td>
<td>E</td>
<td>对于模型评估，描述如何计算模型预测的(例如,公式、代码、对象、应用程序编程接口等)</td>
</tr>
<tr class="even">
<td>类别不均衡</td>
<td>13</td>
<td>D；E</td>
<td>如果使用了类别不平衡方法，说明为什么这样做，如何这样做，以及后续任何重新校准模型或模型预测的方法</td>
</tr>
<tr class="odd">
<td>公平性</td>
<td>14</td>
<td>D；E</td>
<td>描述任何用于解决模型公平性的方法及其原理</td>
</tr>
<tr class="even">
<td>模型输出</td>
<td>15</td>
<td>D</td>
<td>指定预测模型(例如,概率,分类)的输出。为任何分类以及如何确定阈值提供详细信息和理由</td>
</tr>
<tr class="odd">
<td>训练与评估</td>
<td>16</td>
<td>D；E</td>
<td>确定开发和评估数据在医疗保健环境、合格标准、结果和预测因素之间的任何差异</td>
</tr>
<tr class="even">
<td>伦理批准</td>
<td>17</td>
<td>D；E</td>
<td>命名批准该研究的机构研究委员会或伦理委员会，并描述参与者知情同意或伦理委员会放弃知情同意的情况</td>
</tr>
<tr class="odd">
<td><strong>开放科学</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>资助</td>
<td>18a</td>
<td>D；E</td>
<td>给出本研究的资金来源和资助者的角色</td>
</tr>
<tr class="odd">
<td>利益冲突方</td>
<td>18b</td>
<td>D；E</td>
<td>声明所有作者的利益冲突和财务披露</td>
</tr>
<tr class="even">
<td>计划书</td>
<td>18c</td>
<td>D；E</td>
<td>说明研究方案可在何处获取或声明方案未准备好</td>
</tr>
<tr class="odd">
<td>注册</td>
<td>18d</td>
<td>D；E</td>
<td>为研究提供注册信息，包括注册名和注册号，或者说明研究未进行注册</td>
</tr>
<tr class="even">
<td>数据共享</td>
<td>18e</td>
<td>D；E</td>
<td>详细说明研究数据的可获得性</td>
</tr>
<tr class="odd">
<td>代码共享</td>
<td>18f</td>
<td>D；E</td>
<td>提供分析代码可用性的详细信息</td>
</tr>
<tr class="even">
<td><strong>患者和公众参与</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>患者和公众参与</td>
<td>19</td>
<td>D；E</td>
<td>在研究的设计、进行、报告、解释或传播过程中提供任何患者和公众参与的详细信息，或陈述没有参与的情况</td>
</tr>
<tr class="even">
<td><strong>结果</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>参与者</td>
<td>20a</td>
<td>D；E</td>
<td>描述研究过程中参与者的流动情况，包括有结果和没有结果的参与者人数，如果适用，则对随访时间进行总结。一张图可能会有帮助</td>
</tr>
<tr class="even">
<td></td>
<td>20b</td>
<td>D；E</td>
<td>报告每个数据源或设置的总体和适用的特征，包括关键日期、关键预测因素(包括人口统计特征)、接受的治疗、样本量、结果事件数、随访时间和缺失数据的数量。一张表可能是有帮助的。报告关键人口群体之间的差异</td>
</tr>
<tr class="odd">
<td></td>
<td>20c</td>
<td>E</td>
<td>对于模型评估，展示了与开发数据分布的重要预测因子(人口统计学,预测因素和结果)的比较</td>
</tr>
<tr class="even">
<td>模型开发</td>
<td>21</td>
<td>D；E</td>
<td>指定每个分析(例如,模型开发、超参数调优、模型评估等)中参与者和结果事件的数量</td>
</tr>
<tr class="odd">
<td>模型规范</td>
<td>22</td>
<td>D</td>
<td>提供完整预测模型(例如,公式、代码、对象、应用程序编程接口等)的详细信息，允许在新的个体中进行预测，并允许第三方评估和实施，包括访问或重用(例如,免费的,专有的)的任何限制</td>
</tr>
<tr class="even">
<td>模型表现</td>
<td>23a</td>
<td>D；E</td>
<td>报告模型性能估计的置信区间，包括对任何关键子组的(例如,社会人口学)。考虑情节来辅助呈现</td>
</tr>
<tr class="odd">
<td></td>
<td>23b</td>
<td>D；E</td>
<td>如果检查，报告了跨集群的模型性能的任何异质性的结果。详情见 TRIPOD-Cluster</td>
</tr>
<tr class="even">
<td>模型更新</td>
<td>24</td>
<td>E</td>
<td>报告任何模型更新的结果，包括更新后的模型和随后的性能</td>
</tr>
<tr class="odd">
<td><strong>讨论</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>解释</td>
<td>25</td>
<td>D；E</td>
<td>对主要结果进行总体解释，包括目标和先前研究背景下的公平问题</td>
</tr>
<tr class="odd">
<td>局限性</td>
<td>26</td>
<td>D；E</td>
<td>讨论研究(如非代表性样本、样本量、过拟合、缺失数据等)的任何局限性及其对任何偏倚、统计不确定性和可推广性的影响</td>
</tr>
<tr class="even">
<td>该模型在当前护理背景下的可用性</td>
<td>27a</td>
<td>D</td>
<td>描述在实现预测模型时，应该如何评估和处理质量差或不可用的输入数据(例如,预测值)</td>
</tr>
<tr class="odd">
<td></td>
<td>27b</td>
<td>D</td>
<td>指定在处理输入数据或使用模型时是否需要用户进行交互，以及需要用户具备何种水平的专业知识</td>
</tr>
<tr class="even">
<td></td>
<td>27c</td>
<td>D；E</td>
<td>讨论了未来研究的下一步工作，特别关注模型的适用性和通用性</td>
</tr>
</tbody>
</table>
<p><strong>Table 3 期刊或会议摘要中预测模型研究的必要报告项目</strong></p>
<table class="caption-top table">
<colgroup>
<col style="width: 19%">
<col style="width: 80%">
</colgroup>
<thead>
<tr class="header">
<th>段落和条目</th>
<th>清单表条目</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>标题</strong></td>
<td></td>
</tr>
<tr class="even">
<td>1</td>
<td>将研究确定为开发或评估多变量预测模型的性能、目标人群和待预测结果</td>
</tr>
<tr class="odd">
<td><strong>背景</strong></td>
<td></td>
</tr>
<tr class="even">
<td>2</td>
<td>对医疗保健背景进行简要解释，并为开发或评估所有模型的性能提供理论依据</td>
</tr>
<tr class="odd">
<td><strong>目的</strong></td>
<td></td>
</tr>
<tr class="even">
<td>3</td>
<td>明确研究目标，包括研究是否描述模型开发、评价，或者两者兼而有之</td>
</tr>
<tr class="odd">
<td><strong>方法</strong></td>
<td></td>
</tr>
<tr class="even">
<td>4</td>
<td>描述数据的来源</td>
</tr>
<tr class="odd">
<td>5</td>
<td>描述数据收集的合格标准和地点</td>
</tr>
<tr class="even">
<td>6</td>
<td>明确模型所要预测的结果，包括预后模型情况下预测的时间范围</td>
</tr>
<tr class="odd">
<td>7</td>
<td>说明模型类型，总结模型建立步骤，以及内部验证的方法</td>
</tr>
<tr class="even">
<td>8</td>
<td>明确用于评估模型性能的度量指标(如区分度、校准度、临床实用性等)</td>
</tr>
<tr class="odd">
<td><strong>结果</strong></td>
<td></td>
</tr>
<tr class="even">
<td>9</td>
<td>报告参与人数和结果事件</td>
</tr>
<tr class="odd">
<td>10</td>
<td>汇总最终模型中的预测因子</td>
</tr>
<tr class="even">
<td>11</td>
<td>报告模型性能估计(带置信区间)</td>
</tr>
<tr class="odd">
<td><strong>讨论</strong></td>
<td></td>
</tr>
<tr class="even">
<td>12</td>
<td>对主要结果进行了整体解释</td>
</tr>
<tr class="odd">
<td><strong>注册</strong></td>
<td></td>
</tr>
<tr class="even">
<td>13</td>
<td>给出注册表或存储库的注册号和名称</td>
</tr>
</tbody>
</table>
</section>
<section id="实例" class="level3">
<h3 class="anchored" data-anchor-id="实例">实例</h3>
<section id="标题将研究确定为开发或评估多变量预测模型的性能目标人群和待预测结果de" class="level4">
<h4 class="anchored" data-anchor-id="标题将研究确定为开发或评估多变量预测模型的性能目标人群和待预测结果de">1 标题：将研究确定为开发或评估多变量预测模型的性能、目标人群和待预测结果。D；E</h4>
<p>信息丰富的标题有助于潜在读者和系统审阅者识别预测模型研究；报告信息丰富的标题，提供有关目标人群和模型预测结果的关键信息。</p>
<p>实例 1 的标题为《Multimodal Machine Learning-Based Marker Enables Early Detection and Prognosis Prediction for Hyperuricemia：基于多模态机器学习的标志物可以实现高尿酸血症的早期检测和预后预测》，不能直接从标题得知是模型的开发、验证还是二者兼有的研究，“预测”表明该研究是一篇临床预测模型类文章，“高尿酸血症”显示预测结局为发生高尿酸血症，但并未在标题中表明研究的目标人群，根据正文内容可知其目标人群为医院就医的患者，无其他特殊限定。但若研究人群为罹患某一疾病或具备某一特征的人群，则应在标题中体现，能进一步反映出模型的适用范围和研究的临床价值。</p>
</section>
<section id="摘要摘要检查表见-tripodai-摘要清单de" class="level4">
<h4 class="anchored" data-anchor-id="摘要摘要检查表见-tripodai-摘要清单de">2 摘要：摘要检查表见 TRIPOD+AI 摘要清单。D；E</h4>
<p>报告针对TRIPOD+AI for Abstracts检查表中每个项目的摘要。</p>
<p>根据 TRIPOD+AI for Abstracts，在采用结构式摘要，报告研究背景、目的、方法（数据来源、收集情况、预测结果、模型类型及性能度量指标）、结果（样本量和结果事件、预测因子和模型性能）、讨论及注册情况。实例 1 对研究背景略做阐述，并报告数据情况（英国生物库与南方医院队列）、结局事件（ISHUA）、模型性能（报告了相关数值），简略提及基因与临床数据两大类预测因子、但未提及度量指标类别及注册情况。</p>
</section>
<section id="背景" class="level4">
<h4 class="anchored" data-anchor-id="背景">3 背景</h4>
<section id="解释医疗保健背景包括无论是诊断性还是预后性以及开发或评估预测模型的理由包括对现有模型的参考de" class="level5">
<h5 class="anchored" data-anchor-id="解释医疗保健背景包括无论是诊断性还是预后性以及开发或评估预测模型的理由包括对现有模型的参考de">3.1：解释医疗保健背景(包括无论是诊断性还是预后性)以及开发或评估预测模型的理由，包括对现有模型的参考。D；E</h5>
<p>描述打算使用或需要模型的医疗保健环境；在现有预测模型可用的情况下，提供开发新模型的明确理由；对于评估现有模型的研究，提供评估的理由，并提供所有正在评估的模型的参考资料。</p>
<p>实例 2《Use of Machine Learning Models to Predict Death After Acute Myocardial Infarction：利用机器学习模型预测急性心肌梗死后死亡》中对于准备开发的模型需求和明确理由做出了清晰叙述。</p>
</section>
<section id="描述照护路径情境下预测模型的目标人群和意向目的包括其意向用户例如医疗保健专业人员患者公众等de" class="level5">
<h5 class="anchored" data-anchor-id="描述照护路径情境下预测模型的目标人群和意向目的包括其意向用户例如医疗保健专业人员患者公众等de">3.2：描述照护路径情境下预测模型的目标人群和意向目的，包括其意向用户(例如,医疗保健专业人员、患者、公众等)。D；E</h5>
<p>描述谁是开发或评估模型的目标人群，例如，特定年龄、特定国家/地区或患有特定疾病的人；描述模型的预期目的，包括模型旨在支持的临床决策或指导（例如，转诊进行进一步检测或入院，分诊、开始治疗或改变生活方式）以及该模型在护理路径中的预期使用点；描述该模型的预期用户是谁，以及该模型是否适用于医疗保健专业人员、患者、公众或其他。</p>
<p>实例 3《Explainable machine-learning predictions for the prevention of hypoxaemia during surgery：可解释的机器学习预测用于预防手术中的低氧血症》一文中在背景中阐述了希望应用的医疗群体与应用场景。</p>
</section>
<section id="描述任何已知的社会人口群体之间的健康不平等de" class="level5">
<h5 class="anchored" data-anchor-id="描述任何已知的社会人口群体之间的健康不平等de">3.3：描述任何已知的社会人口群体之间的健康不平等。D；E</h5>
<p>在打算使用该模型的医疗保健环境中，描述目标人群中社会人口群体之间的任何已知健康不平等（以及支持健康不平等的引文）。</p>
</section>
</section>
<section id="目的明确研究目的包括研究是否描述了预测模型的开发或验证或两者兼而有之de" class="level4">
<h4 class="anchored" data-anchor-id="目的明确研究目的包括研究是否描述了预测模型的开发或验证或两者兼而有之de">4 目的：明确研究目的，包括研究是否描述了预测模型的开发或验证(或两者兼而有之)。D；E</h4>
<p>提供研究所有目标的明确陈述，描述研究是开发预测模型、评估预测模型的性能，还是同时评估两者。</p>
<p>实例4《Construction of a risk prediction model for detecting postintensive care syndrome—mental disorders：重症监护后综合征-精神障碍风险预测模型的构建》在背景部分明确提及该研究构建模型的类型。</p>
</section>
<section id="数据" class="level4">
<h4 class="anchored" data-anchor-id="数据">5 数据</h4>
<section id="分别描述开发和评估数据集例如随机试验队列常规护理或登记数据的数据来源使用这些数据的理由以及数据的代表性de" class="level5">
<h5 class="anchored" data-anchor-id="分别描述开发和评估数据集例如随机试验队列常规护理或登记数据的数据来源使用这些数据的理由以及数据的代表性de">5.1：分别描述开发和评估数据集(例如,随机试验,队列,常规护理或登记数据)的数据来源、使用这些数据的理由以及数据的代表性。D；E</h5>
<p>提供用于模型开发和模型性能评估的数据来源的描述，包括数据是否（例如）来自随机试验、队列、登记处或电子常规医疗记录；说明研究是使用现有数据还是前瞻性地收集新数据以用于预测模型研究；使用现有数据的位置（即它们最初是出于不同的目的收集的），提供使用这些数据的理由，并评论这些数据的适用性（特别是如果数据是从不同的环境或国家/地区使用到预期目标人群的）和这些数据相对于预期目标人群和背景的代表性；应为所有数据集提供数据源的描述，并单独用于开发和评估；如果使用了任何合成数据，请说明原因，并提供有关如何创建合成数据（和代码，参见第 18f 项）并在研究中使用的所有详细信息。</p>
<p>实例1《Multimodal Machine Learning-Based Marker Enables Early Detection and Prognosis Prediction for Hyperuricemia：基于多模态机器学习的标志物可以实现高尿酸血症的早期检测和预后预测》。</p>
</section>
<section id="指定收集到的参与者数据的日期包括参与者计提的开始日期和结束日期并且如果适用则结束随访de" class="level5">
<h5 class="anchored" data-anchor-id="指定收集到的参与者数据的日期包括参与者计提的开始日期和结束日期并且如果适用则结束随访de">5.2：指定收集到的参与者数据的日期，包括参与者计提的开始日期和结束日期；并且，如果适用，则结束随访。D；E</h5>
<p>指定选择参与者或使用数据的期间的开始和结束日期；对于预测预后的模型，随访持续时间很重要，因此请报告随访结束的日期。</p>
<p>实例5《Machine learning-based prediction of composite risk of cardiovascular events in patients with stable angina pectoris combined with coronary heart disease: development and validation of a clinical prediction model for Chinese patients：基于机器学习的稳定型心绞痛合并冠心病患者心血管事件复合风险预测：中国患者临床预测模型的开发与验证》。</p>
</section>
</section>
<section id="参与者" class="level4">
<h4 class="anchored" data-anchor-id="参与者">6 参与者</h4>
<section id="明确研究环境的关键要素例如初级保健二级保健一般人群包括中心的数量和位置de" class="level5">
<h5 class="anchored" data-anchor-id="明确研究环境的关键要素例如初级保健二级保健一般人群包括中心的数量和位置de">6.1：明确研究环境的关键要素（例如，初级保健、二级保健、一般人群），包括中心的数量和位置。D；E</h5>
<p>描述医疗保健场景，以及研究参与者的招募地点；报告研究的地理位置（至少是国家/地区）和中心（包括中心的数量）。</p>
<p>实例 6《Development and validation of a prediction rule for estimating gastric cancer risk in the Chinese high-risk population: a nationwide multicentre study：在中国高危人群中建立和验证胃癌风险预测规则：一项全国性多中心研究》。</p>
</section>
<section id="描述研究参与者的合格标准de" class="level5">
<h5 class="anchored" data-anchor-id="描述研究参与者的合格标准de">6.2：描述研究参与者的合格标准。D；E</h5>
<p>应报告参与者的资格标准，以了解预测模型的潜在适用性和普遍性；这包括报告连续变量的任何限制，例如，用于定义纳入参与者资格的年龄范围。</p>
<p>实例 4《Construction of a risk prediction model for detecting postintensive care syndrome—mental disorders：重症监护后综合征-精神障碍风险预测模型的构建》。</p>
</section>
<section id="给出接受的任何治疗的细节以及在模型开发或评估过程中如何处理如果相关de" class="level5">
<h5 class="anchored" data-anchor-id="给出接受的任何治疗的细节以及在模型开发或评估过程中如何处理如果相关de">6.3：给出接受的任何治疗的细节，以及在模型开发或评估过程中如何处理，如果相关。D；E</h5>
<p>应报告在随访之前或开始时接受的任何治疗，以及在预测模型的开发或评估期间是否以及如何处理这些治疗（如果相关）；在使用预测模型和测量结果之间接受的任何治疗，这可能会改变结果的概率，应报告（如果相关）。</p>
<p>实例 7《Utility of Machine Learning Algorithms in Predicting Preoperative Lymph Node Metastasis in Patients With Rectal Cancer Based on Three-Dimensional Endorectal Ultrasound and Clinical and Laboratory Data：基于三维直肠腔内超声和临床及实验室数据的机器学习算法在预测直肠癌患者术前淋巴结转移中的应用》。</p>
</section>
</section>
<section id="数据准备描述任何数据预处理和质量检查包括在相关的社会人口统计群体中是否类似de" class="level4">
<h4 class="anchored" data-anchor-id="数据准备描述任何数据预处理和质量检查包括在相关的社会人口统计群体中是否类似de">7 数据准备：描述任何数据预处理和质量检查，包括在相关的社会人口统计群体中是否类似。D；E</h4>
<p>描述任何数据清理步骤，包括任何特征工程、原始数据转换、特征缩减和数据质量检查。所有用于数据清理的代码都应该可用（参见第18f项）；对于使用来自多个来源的数据（例如，来自不同研究、队列或注册库的数据）的分析，请描述任何协调（例如，结果和预测因子）；确认关键社会人口群体的所有数据预处理/数据清理步骤是否相似（如果相关）；如果数据预处理/数据清理步骤广泛，考虑在补充材料中报告此信息。</p>
<p>实例 8《Machine Learning for Predicting Risk and Prognosis of Acute Kidney Disease in Critically Ill Elderly Patients During Hospitalization: Internet-Based and Interpretable Model Study：机器学习预测老年危重症患者住院期间急性肾脏病的风险和预后：基于互联网和可解释模型的研究》。</p>
</section>
<section id="结局" class="level4">
<h4 class="anchored" data-anchor-id="结局">8 结局</h4>
<section id="明确定义正在预测的结果和时间范围包括如何评估和何时评估选择该结果的理由以及结果评估的方法是否在社会人口统计学群体中保持一致de" class="level5">
<h5 class="anchored" data-anchor-id="明确定义正在预测的结果和时间范围包括如何评估和何时评估选择该结果的理由以及结果评估的方法是否在社会人口统计学群体中保持一致de">8.1：明确定义正在预测的结果和时间范围，包括如何评估和何时评估，选择该结果的理由，以及结果评估的方法是否在社会人口统计学群体中保持一致。D；E</h5>
<p>对于诊断预测模型，应明确定义结果，包括是否使用（广泛接受的）参考标准（真实情况）来确定结果的存在与否；对于预后模型，即预测未来结果的模型，作者应报告结果预测的时间范围。例如，预测心胸手术后28天的死亡风险，或骨质疏松症患者10年的骨折风险。此外，应报告随访期间结果评估的频率；如果使用标准定义，例如使用ICD1代码，则应说明和引用；应报告社会人口群体之间结果评估的任何差异；在某些情况下，可能需要确认没有使用预测因子来定义结果或作为结果的代理。</p>
<p>实例 5《Machine learning-based prediction of composite risk of cardiovascular events in patients with stable angina pectoris combined with coronary heart disease: development and validation of a clinical prediction model for Chinese patients：基于机器学习的稳定型心绞痛合并冠心病患者心血管事件复合风险预测：中国患者临床预测模型的开发与验证》。</p>
</section>
<section id="如果结果评估需要主观解释请描述结果评估者的资质和人口学特征de" class="level5">
<h5 class="anchored" data-anchor-id="如果结果评估需要主观解释请描述结果评估者的资质和人口学特征de">8.2：如果结果评估需要主观解释，请描述结果评估者的资质和人口学特征。D；E</h5>
<p>对于需要主观解释的结局（例如，解释影像学检查的结果，描述结局评价者的数量、资格和人口统计学特征）；如果结果的测量和解释需要（额外的）培训或具体说明，则应报告这些；如果内容广泛，请考虑在补充材料中报告此信息。</p>
<p>实例 7《Utility of Machine Learning Algorithms in Predicting Preoperative Lymph Node Metastasis in Patients With Rectal Cancer Based on Three-Dimensional Endorectal Ultrasound and Clinical and Laboratory Data：基于三维直肠腔内超声和临床及实验室数据的机器学习算法在预测直肠癌患者术前淋巴结转移中的应用》。</p>
</section>
<section id="报告任何盲目评估预测结局的行为de" class="level5">
<h5 class="anchored" data-anchor-id="报告任何盲目评估预测结局的行为de">8.3：报告任何盲目评估预测结局的行为。D；E</h5>
<p>预测的结果应该对预测因子的信息不知情地进行评估——特别是与需要主观解释的结果相关，从而避免数据（标签）泄漏；如果合适，作者应描述结果评估者可以获得哪些信息，并报告任何对结果评估盲法的具体行动。</p>
</section>
</section>
<section id="预测因子" class="level4">
<h4 class="anchored" data-anchor-id="预测因子">9 预测因子</h4>
<section id="描述初始预测因子例如文献以前的模型所有可用的预测因子的选择以及在模型建立之前对预测因子的任何预选择d" class="level5">
<h5 class="anchored" data-anchor-id="描述初始预测因子例如文献以前的模型所有可用的预测因子的选择以及在模型建立之前对预测因子的任何预选择d">9.1：描述初始预测因子(例如,文献,以前的模型,所有可用的预测因子)的选择，以及在模型建立之前对预测因子的任何预选择。D</h5>
<p>提供有关如何考虑将初始预测因子列表包含在模型构建中的详细信息，以及它们是根据文献的（系统）回顾、临床输入（领域专家）选择的，或者只是使用可用数据中的所有预测因子；如果在模型构建之前进行了任何预测因子的预选，然后提供此操作的详细信息。例如，由于大量缺失数据而在模型构建中遗漏了预测变量，或者预测变量被认为与预测结果不合理（临床）相关；初始预测变量的列表可能很广泛，在这些情况下，建议在补充材料中报告这些预测变量。</p>
</section>
<section id="明确定义所有预测因子包括如何和何时测量以及对结果和其他预测因素进行盲法评估的任何行动de" class="level5">
<h5 class="anchored" data-anchor-id="明确定义所有预测因子包括如何和何时测量以及对结果和其他预测因素进行盲法评估的任何行动de">9.2：明确定义所有预测因子，包括如何和何时测量(以及对结果和其他预测因素进行盲法评估的任何行动)。D；E</h5>
<p>应明确定义建模中包含的所有预测变量，以及度量单位和分类预测变量的所有类别，以便读者和其他人可以复制、实施或评估模型的性能；有关如何以及何时测量预测变量值的详细信息。请注意，预测变量应在打算使用模型之前或之时进行测量；对于需要主观解释的预测变量，将其盲解释为建模中考虑的其他预测变量的值可能很重要（例如，避免数据泄漏）。作者应报告任何使预测变量测量的评估对其他预测变量不知情的行为；特别是对于诊断模型，预测变量的测量应在不了解个体结果的情况下进行，因为这可能会人为地夸大预测变量与结果之间的关联。作者应报告任何使预测因子测量值的评估对结果值视而不见的操作；在某些情况下，预测因子的数量可能非常大，因此在主要手稿中报告它们都是无益的，在这些情况下，明确定义所有预测因子仍然很重要，应考虑在补充材料中报告这一点。</p>
<p>实例 9《A clinical prediction model based on interpretable machine learning algorithms for prolonged hospital stay in acute ischemic stroke patients: a real-world study：基于可解释性机器学习算法的急性缺血性卒中患者住院时间延长的临床预测模型：真实世界研究》。</p>
</section>
<section id="如果预测因子测量需要主观解释则描述预测因子评估者的资格和人口统计学特征de" class="level5">
<h5 class="anchored" data-anchor-id="如果预测因子测量需要主观解释则描述预测因子评估者的资格和人口统计学特征de">9.3：如果预测因子测量需要主观解释，则描述预测因子评估者的资格和人口统计学特征。D；E</h5>
<p>对于需要主观解释的预测因子（例如，解释影像学检查的结果），应报告预测因子评估者的资格和人口统计学特征；如果测量和解释需要（额外）培训或具体说明，则应报告这些。这可以在补充材料中报告。</p>
</section>
</section>
<section id="样本量说明研究规模是如何达到分别进行开发和评估的并证明研究规模足以回答研究问题包括任何样本量计算的细节de" class="level4">
<h4 class="anchored" data-anchor-id="样本量说明研究规模是如何达到分别进行开发和评估的并证明研究规模足以回答研究问题包括任何样本量计算的细节de">10 样本量：说明研究规模是如何达到(分别进行开发和评估)的，并证明研究规模足以回答研究问题。包括任何样本量计算的细节。D；E</h4>
<p>描述样本量是如何确定的—这应该单独进行，以确定模型开发所需的样本量和评估模型性能所需的样本量，无论数据是前瞻性收集的还是使用现有数据；提供任何样本量计算中使用的详细信息和所有估计值；如果没有进行正式的样本量计算，例如，使用了所有可用数据，提供数据大小是否足以回答研究问题的理由。</p>
</section>
<section id="缺失数据描述缺失数据是如何处理的提供省略任何数据的理由de" class="level4">
<h4 class="anchored" data-anchor-id="缺失数据描述缺失数据是如何处理的提供省略任何数据的理由de">11 缺失数据：描述缺失数据是如何处理的。提供省略任何数据的理由。D；E</h4>
<p>数据缺失是一个无处不在的问题。作者应报告正在考虑包含在模型中的每个预测变量的缺失值数量；应报告缺失值的处理情况，包括对缺失原因的任何假设；如果个体（或预测变量）由于缺失值而被遗漏，则应报告此情况，并给出原因；如果已估算缺失值，那么应报告插补任何缺失值的方法的完整详细信息；如果已插补缺失值，请确认它是针对训练和任何测试数据单独完成的（即避免泄漏）。</p>
<p>实例 2《Use of Machine Learning Models to Predict Death After Acute Myocardial Infarction：利用机器学习模型预测急性心肌梗死后死亡》。</p>
</section>
<section id="分析方法" class="level4">
<h4 class="anchored" data-anchor-id="分析方法">12 分析方法</h4>
<section id="描述数据在分析中如何使用例如模型性能的开发和评估包括是否对数据进行分区考虑任何样本量要求d" class="level5">
<h5 class="anchored" data-anchor-id="描述数据在分析中如何使用例如模型性能的开发和评估包括是否对数据进行分区考虑任何样本量要求d">12.1：描述数据在分析中如何使用(例如,模型性能的开发和评估)，包括是否对数据进行分区，考虑任何样本量要求。D</h5>
<p>描述如何使用可用数据来开发模型和评估模型性能，包括是否以及如何对数据进行分区，以及对数据进行分区的原因（例如，模型开发、超参数调整、评估模型性能、内部和外部交叉验证）；如果数据已分区，请报告在分区过程中是否考虑了样本量要求（参见第10项）， 以及分区数据的大小是否足以进行分析和回答研究问题；如果数据已经被划分为训练（包括任何超参数调优数据）和测试数据，请确认没有数据泄漏；如果数据包含来自同一个体的多个记录或样本，并且数据已分区为训练（包括任何超参数优化数据）和测试数据，请确认任何分区数据中没有个体泄漏，如果没有，请如何描述在分析中如何处理这种情况（参见第12c项）。</p>
<p>实例 9《Machine Learning for Predicting Risk and Prognosis of Acute Kidney Disease in Critically Ill Elderly Patients During Hospitalization: Internet-Based and Interpretable Model Study：机器学习预测老年危重症患者住院期间急性肾脏病的风险和预后：基于互联网和可解释模型的研究》。</p>
</section>
<section id="根据模型的类型描述在函数形式重新标度转换或任何标准化分析中如何处理预测因子d" class="level5">
<h5 class="anchored" data-anchor-id="根据模型的类型描述在函数形式重新标度转换或任何标准化分析中如何处理预测因子d">12.2：根据模型的类型，描述在(函数形式,重新标度,转换,或任何标准化)分析中如何处理预测因子。D</h5>
<p>对于在分析过程中转换（即重新缩放或标准化）的任何预测变量，请描述这是如何完成的；对于任何已进行类别折叠的分类预测变量，例如，由于样本量小/结果事件太少，请提供详细信息和原因。</p>
</section>
<section id="指定模型的类型基本原理所有模型构建步骤包括任何超参数的调整以及内部验证的方法d" class="level5">
<h5 class="anchored" data-anchor-id="指定模型的类型基本原理所有模型构建步骤包括任何超参数的调整以及内部验证的方法d">12.3：指定模型的类型，基本原理，所有模型构建步骤，包括任何超参数的调整，以及内部验证的方法。D</h5>
<p>明确说明正在开发的模型类型（例如，逻辑回归、Cox回归、随机森林、神经网络），并提供使用每种模型构建方法的基本原理——考虑预测结果的类型以及预测模型在实践中将如何实施；对于每个模型，清楚地描述模型构建中的所有步骤，包括任何超参数优化、已优化的超参数以及调整方式。如果应用了许多模型构建方法，并且字数限制禁止完整描述，则使用补充材料提供详细信息；对于正在开发多个模型的研究（例如，使用不同的模型构建方法），清楚地描述选择哪个模型的标准（如果有），请参阅关于模型性能的第12e项和第23项）；模型开发过程中的内部验证方法（评估模型性能）应该清楚地描述，例如，是否使用了k折叠交叉验证或引导。阐明在内部评估方法期间是否重放了所有模型构建步骤（包括超参数调整）；清楚地描述用于检查模型稳定性（例如，bootstrapping）（例如，在预测因子选择、预测性能和个体预测方面））；如果数据包含来自同一个体的多个记录或样本，描述在模型构建和内部验证中如何处理此问题（例如，如果使用K折交叉验证，请确认某个人的所有记录/样本是否都包含在同一折中（例如，避免数据泄露）。</p>
<p>实例 10《Construction of a clinical prediction model for complicated appendicitis based on machine learning techniques：基于机器学习技术的复杂性阑尾炎临床预测模型构建》。</p>
</section>
<section id="描述是否以及如何在跨集群例如医院国家中处理和量化模型参数值和模型性能的估计中的任何异质性其他考虑参见tripod-clusterde" class="level5">
<h5 class="anchored" data-anchor-id="描述是否以及如何在跨集群例如医院国家中处理和量化模型参数值和模型性能的估计中的任何异质性其他考虑参见tripod-clusterde">12.4：描述是否以及如何在跨集群(例如,医院、国家)中处理和量化模型参数值和模型性能的估计中的任何异质性。其他考虑参见TRIPOD-Cluster。D；E</h5>
<p>如果在模型开发或模型性能评估期间，分析考虑了数据中的任何聚类（例如，通过组合来自多项研究的个体参与者数据，或按医疗中心/医院或国家聚类的数据），则应清楚地描述用于解释聚类的基本原理和方法；对于预测模型研究的具体报告建议，这些研究考虑了模型参数值的聚类和异质性，并且性能，作者应查阅TRIPOD-Cluster检查表。</p>
</section>
<section id="指定所有用于评估模型性能的及其理论基础和用于比较多个模型的如区分度校准度临床实用性等-如果相关的指标和图de" class="level5">
<h5 class="anchored" data-anchor-id="指定所有用于评估模型性能的及其理论基础和用于比较多个模型的如区分度校准度临床实用性等-如果相关的指标和图de">12.5：指定所有用于评估模型性能的(及其理论基础)和用于比较多个模型的(如区分度、校准度、临床实用性等) (如果相关)的指标和图。D；E</h5>
<p>报告用于评估模型性能的所有度量。通常预计至少会提供模型判别和校准（包括校准图）；如果预测模型预测的是事件发生时间结果，则清楚地描述用于解释事件发生时间性质（即删失）的措施和方法。同样，还应说明对任何竞争风险的处理（如果适用）；对于预后模型，报告评估模型预测性能的所有时间点；报告用于图形显示模型性能的方法，例如校准图（具有平滑的校准曲线）和决策曲线；如果正在比较多个模型，即，与现有模型进行比较或比较多种建模方法，那么应清楚地解释用于比较这些模型的方法，以及对卓越性能做出任何判断的标准。</p>
<p>实例 5《Machine learning-based prediction of composite risk of cardiovascular events in patients with stable angina pectoris combined with coronary heart disease: development and validation of a clinical prediction model for Chinese patients：基于机器学习的稳定型心绞痛合并冠心病患者心血管事件复合风险预测：中国患者临床预测模型的开发与验证》。</p>
</section>
<section id="描述由于模型评估而产生的任何模型更新例如重新校准无论是总体还是针对特定的社会人口群体或设置e" class="level5">
<h5 class="anchored" data-anchor-id="描述由于模型评估而产生的任何模型更新例如重新校准无论是总体还是针对特定的社会人口群体或设置e">12.6：描述由于模型评估而产生的任何模型更新(例如,重新校准)，无论是总体还是针对特定的社会人口群体或设置。E</h5>
<p>如果模型在验证后更新，例如重新校准或重新拟合——无论是在整个队列中还是在特定的社会人口群体中，请提供有关用于更新模型的方法的详细信息。</p>
</section>
<section id="对于模型评估描述如何计算模型预测的例如公式代码对象应用程序编程接口等e" class="level5">
<h5 class="anchored" data-anchor-id="对于模型评估描述如何计算模型预测的例如公式代码对象应用程序编程接口等e">12.7：对于模型评估，描述如何计算模型预测的(例如,公式、代码、对象、应用程序编程接口等)。E</h5>
<p>对于在单独的数据集中评估现有模型的研究（即外部验证研究），请提供有关如何计算模型的单个预测的详细信息。如果模型不是免费/公开可用的，请解释预测是如何获得的；如果正在评估回归模型方程，请提供该方程的详细信息（例如，考虑提出此方程，提供对开发该方程的原始研究的引用）；对于评估没有方程的预测模型（例如，神经网络、随机森林）的研究，请提供有关如何进行预测的详细信息，例如，代码、软件对象、API，以及在哪里可以找到这些信息（即URL、DOI）；如果模型的单个预测用于创建风险组或分类（在模型开发中未指定），则应报告有关如何以及为何执行此操作的详细信息（参见第15项）。</p>
<p>实例 5《Machine learning-based prediction of composite risk of cardiovascular events in patients with stable angina pectoris combined with coronary heart disease: development and validation of a clinical prediction model for Chinese patients：基于机器学习的稳定型心绞痛合并冠心病患者心血管事件复合风险预测：中国患者临床预测模型的开发与验证》。</p>
</section>
</section>
<section id="类别不均衡如果使用了类别不平衡方法说明为什么这样做如何这样做以及后续任何重新校准模型或模型预测的方法de" class="level4">
<h4 class="anchored" data-anchor-id="类别不均衡如果使用了类别不平衡方法说明为什么这样做如何这样做以及后续任何重新校准模型或模型预测的方法de">13 类别不均衡：如果使用了类别不平衡方法，说明为什么这样做，如何这样做，以及后续任何重新校准模型或模型预测的方法。D；E</h4>
<p>如果使用了类不平衡方法（例如，欠/超采样、SMOTE），则提供这样做的理由，以及如何做到这一点——考虑到对样本量的任何影响（例如，对于欠采样方法）；不平衡校正对模型校准有影响，得出的概率估计值太高（这也对定义任何风险组有影响），描述了用于重新校准模型或模型预测的方法。</p>
<p>实例 11《机器学习基于不平衡数据预测急性新发缺血性卒中患者院内死亡模型研究》。</p>
</section>
<section id="公平性描述任何用于解决模型公平性的方法及其原理de" class="level4">
<h4 class="anchored" data-anchor-id="公平性描述任何用于解决模型公平性的方法及其原理de">14 公平性：描述任何用于解决模型公平性的方法及其原理。D；E</h4>
<p>公平性是指确保预测模型不歧视个人或群体，例如基于种族、性别、年龄等个人属性，所有用于解决公平性的方法都应清楚地解释其基本原理；在开发模型和评估其性能时，确保数据包含代表性群体（目标人群）非常重要，研究人员应尝试证明这一点；如果预测模型是使用代表性不足的群体或未包括的特定群体的数据开发的，那么需要在代表性数据中对这些群体进行评估，以评估这些群体中的模型，以提高对发展和评价数据之外的更多个体群体的普遍性。</p>
</section>
<section id="模型输出指定预测模型例如概率分类的输出为任何分类以及如何确定阈值提供详细信息和理由d" class="level4">
<h4 class="anchored" data-anchor-id="模型输出指定预测模型例如概率分类的输出为任何分类以及如何确定阈值提供详细信息和理由d">15 模型输出：指定预测模型(例如,概率,分类)的输出。为任何分类以及如何确定阈值提供详细信息和理由。D</h4>
<p>大多数模型输出个体的概率估计，而一些模型将输出转化为分类（例如，分为低风险或高风险组），这应该明确说明。如果已经创建了分类或风险组，则应在护理路径的背景下这样做的基本原理以及这些风险组如何为任何临床决策提供信息；对于生成分类或风险组的模型，应明确报告，并应指定任何阈值（例如，定义组的估计概率范围）（这些是否基于文献， 临床指南、统计考虑或 ad-hoc）；如果已经提供了单个预测模型输出的不确定性区间，则提供有关如何完成此操作的详细信息（例如，使用参数估计的方差-协方差矩阵或共形预测）。</p>
<p>实例 1《Multimodal Machine Learning-Based Marker Enables Early Detection and Prognosis Prediction for Hyperuricemia：基于多模态机器学习的标志物可以实现高尿酸血症的早期检测和预后预测》。</p>
</section>
<section id="训练与评估确定开发和评估数据在医疗保健环境合格标准结果和预测因素之间的任何差异de" class="level4">
<h4 class="anchored" data-anchor-id="训练与评估确定开发和评估数据在医疗保健环境合格标准结果和预测因素之间的任何差异de">16 训练与评估：确定开发和评估数据在医疗保健环境、合格标准、结果和预测因素之间的任何差异。D；E</h4>
<p>在一个环境、中心或国家开发的预测模型不一定对不同的环境、中心或国家有用。来自不同来源的数据之间的资格标准、结果和预测因子定义可能（故意）不同。描述开发数据与用于评估模型性能的数据之间的任何差异，有助于理解和解释模型在原始模型开发数据上下文中的性能和泛化性。</p>
</section>
<section id="伦理批准命名批准该研究的机构研究委员会或伦理委员会并描述参与者知情同意或伦理委员会放弃知情同意的情况de" class="level4">
<h4 class="anchored" data-anchor-id="伦理批准命名批准该研究的机构研究委员会或伦理委员会并描述参与者知情同意或伦理委员会放弃知情同意的情况de">17 伦理批准：命名批准该研究的机构研究委员会或伦理委员会，并描述参与者知情同意或伦理委员会放弃知情同意的情况。D；E</h4>
<p>如果该研究没有机构研究委员会或伦理批准，那么请明确说明，并说明原因。</p>
<p>例 7《Utility of Machine Learning Algorithms in Predicting Preoperative Lymph Node Metastasis in Patients With Rectal Cancer Based on Three-Dimensional Endorectal Ultrasound and Clinical and Laboratory Data：基于三维直肠腔内超声和临床及实验室数据的机器学习算法在预测直肠癌患者术前淋巴结转移中的应用》。</p>
</section>
<section id="开放科学" class="level4">
<h4 class="anchored" data-anchor-id="开放科学">18 开放科学</h4>
<section id="资助给出本研究的资金来源和资助者的角色de" class="level5">
<h5 class="anchored" data-anchor-id="资助给出本研究的资金来源和资助者的角色de">18.1 资助：给出本研究的资金来源和资助者的角色。D；E</h5>
<p>提供有关研究是否获得资助的详细信息，并提供有关资助者在研究中的作用的任何详细信息；为所有作者提供任何其他资金来源。</p>
<p>实例 5《Machine learning-based prediction of composite risk of cardiovascular events in patients with stable angina pectoris combined with coronary heart disease: development and validation of a clinical prediction model for Chinese patients：基于机器学习的稳定型心绞痛合并冠心病患者心血管事件复合风险预测：中国患者临床预测模型的开发与验证》。</p>
</section>
<section id="利益冲突方声明所有作者的利益冲突和财务披露de" class="level5">
<h5 class="anchored" data-anchor-id="利益冲突方声明所有作者的利益冲突和财务披露de">18.2 利益冲突方：声明所有作者的利益冲突和财务披露。D；E</h5>
<p>披露读者可能认为相关或可能影响研究设计、实施、解释或报告的任何作者关系或活动。</p>
<p>实例 5《Machine learning-based prediction of composite risk of cardiovascular events in patients with stable angina pectoris combined with coronary heart disease: development and validation of a clinical prediction model for Chinese patients：基于机器学习的稳定型心绞痛合并冠心病患者心血管事件复合风险预测：中国患者临床预测模型的开发与验证》。</p>
</section>
<section id="计划书说明研究方案可在何处获取或声明方案未准备好de" class="level5">
<h5 class="anchored" data-anchor-id="计划书说明研究方案可在何处获取或声明方案未准备好de">18.3 计划书：说明研究方案可在何处获取或声明方案未准备好。D；E</h5>
<p>提供有关研究方案可用性的所有详细信息，包括可以找到研究方案的位置（例如，出版物详细信息、补充材料、在存储库中公开提供，例如在开放科学框架上），包括URL或DOI；明确说明是否未制定或未公开提供研究方案（以及原因）；如果与研究方案中规定的内容有任何显着偏差， 提供偏差的摘要和原因。</p>
<p>实例 12《Development and validation of a multimodal feature fusion prognostic model for lumbar degenerative disease based on machine learning: a study protocol：基于机器学习的腰椎退行性疾病多模态特征融合预后模型的开发与验证：研究方案》。</p>
</section>
<section id="注册为研究提供注册信息包括注册名和注册号或者说明研究未进行注册de" class="level5">
<h5 class="anchored" data-anchor-id="注册为研究提供注册信息包括注册名和注册号或者说明研究未进行注册de">18.4 注册：为研究提供注册信息，包括注册名和注册号，或者说明研究未进行注册。D；E</h5>
<p>如果研究已注册（例如，在clinicaltrials.gov上，开放科学框架），请提供有关注册号、注册名称和注册链接（包括任何DOI）的详细信息；明确说明研究是否尚未注册。</p>
</section>
<section id="数据共享详细说明研究数据的可获得性de" class="level5">
<h5 class="anchored" data-anchor-id="数据共享详细说明研究数据的可获得性de">18.5 数据共享：详细说明研究数据的可获得性。D；E</h5>
<p>提供有关研究数据可用性的详细信息，包括可以找到数据的位置（例如，公共存储库、URL、DOI）、如何检索数据、获取和使用数据的任何条件或限制。任何共享数据都应附带数据字典；如果无法共享数据，请提供原因；避免使用陈词滥调，例如“根据合理请求提供数据”，而不指定构成合理请求的条件。</p>
</section>
<section id="代码共享提供分析代码可用性的详细信息de" class="level5">
<h5 class="anchored" data-anchor-id="代码共享提供分析代码可用性的详细信息de">18.6 代码共享：提供分析代码可用性的详细信息▲。D；E</h5>
<p>提供有关分析代码可用性的所有详细信息（以及如何运行代码的文档），包括可以找到代码的位置（例如，代码存储库、DOI、链接）、如何检索代码、应报告获取和使用代码的任何条件或许可（和版本）；分析代码是复制（原则上）研究的所有报告结果和发现所需的所有代码（包括数据清理）。应报告（原则上）重现研究结果所需的软件和任何软件包（包括任何版本号）。在某些情况下，可能需要报告有关计算环境的更多详细信息（例如，硬件、操作系统、CPU、RAM）。</p>
</section>
</section>
<section id="患者和公众参与在研究的设计进行报告解释或传播过程中提供任何患者和公众参与的详细信息或陈述没有参与的情况de" class="level4">
<h4 class="anchored" data-anchor-id="患者和公众参与在研究的设计进行报告解释或传播过程中提供任何患者和公众参与的详细信息或陈述没有参与的情况de">19 患者和公众参与：在研究的设计、进行、报告、解释或传播过程中提供任何患者和公众参与的详细信息，或陈述没有参与的情况。D；E</h4>
<p>描述患者或公众如何参与研究及其结果的规划、设计、实施、报告或传播；研究结果是否向患者或公众展示？；考虑使用 GRIPP2 声明来报告患者和公众对研究的参与情况；如果没有患者或公众参与研究的任何方面，请明确说明。</p>
</section>
<section id="参与者-1" class="level4">
<h4 class="anchored" data-anchor-id="参与者-1">20 参与者</h4>
<section id="描述研究过程中参与者的流动情况包括有结果和没有结果的参与者人数如果适用则对随访时间进行总结一张图可能会有帮助de" class="level5">
<h5 class="anchored" data-anchor-id="描述研究过程中参与者的流动情况包括有结果和没有结果的参与者人数如果适用则对随访时间进行总结一张图可能会有帮助de">20.1：描述研究过程中参与者的流动情况，包括有结果和没有结果的参与者人数，如果适用，则对随访时间进行总结。一张图可能会有帮助。D；E</h5>
<p>流程图可用于描述参与者通过研究的流程，其中流程图的入口点是参与者的来源，然后后续步骤可以与资格标准、后续行动（如果适用）相关。和数据可用性；流程图中要呈现的其他有用信息包括缺失值的参与者数量和结果事件的数量；对于延迟参考测试的预后或诊断研究，应报告随访时间的摘要（例如，中位随访和范围）。</p>
<p>实例 9《Machine Learning for Predicting Risk and Prognosis of Acute Kidney Disease in Critically Ill Elderly Patients During Hospitalization: Internet-Based and Interpretable Model Study：机器学习预测老年危重症患者住院期间急性肾脏病的风险和预后：基于互联网和可解释模型的研究》。</p>
</section>
<section id="报告每个数据源或设置的总体和适用的特征包括关键日期关键预测因素包括人口统计特征接受的治疗样本量结果事件数随访时间和缺失数据的数量一张表可能是有帮助的报告关键人口群体之间的差异de" class="level5">
<h5 class="anchored" data-anchor-id="报告每个数据源或设置的总体和适用的特征包括关键日期关键预测因素包括人口统计特征接受的治疗样本量结果事件数随访时间和缺失数据的数量一张表可能是有帮助的报告关键人口群体之间的差异de">20.2：报告每个数据源或设置的总体和适用的特征，包括关键日期、关键预测因素(包括人口统计特征)、接受的治疗、样本量、结果事件数、随访时间和缺失数据的数量。一张表可能是有帮助的。报告关键人口群体之间的差异。D；E</h5>
<p>报告（可能使用表格）使用的所有数据集的摘要，包括结果的分布、预测因子（例如，平均值/中位数、标准差/四分位数范围、频率）、接受的任何治疗、样本量（和结果事件的数量、随访时间的摘要，以及每个预测因子的缺失值的数量和比例；如果相关， 报告感兴趣的关键人口统计群体之间的任何差异可能很有用。</p>
<p>实例 7《Utility of Machine Learning Algorithms in Predicting Preoperative Lymph Node Metastasis in Patients With Rectal Cancer Based on Three-Dimensional Endorectal Ultrasound and Clinical and Laboratory Data：基于三维直肠腔内超声和临床及实验室数据的机器学习算法在预测直肠癌患者术前淋巴结转移中的应用》。</p>
</section>
<section id="对于模型评估展示了与开发数据分布的重要预测因子人口统计学预测因素和结果的比较e" class="level5">
<h5 class="anchored" data-anchor-id="对于模型评估展示了与开发数据分布的重要预测因子人口统计学预测因素和结果的比较e">20.3：对于模型评估，展示了与开发数据分布的重要预测因子(人口统计学,预测因素和结果)的比较。E</h5>
<p>对于评估现有模型性能的研究（包括模型开发研究中的模型），提供重要变量（例如，平均值/中位数、标准差/四分位数范围、频率）分布的比较，例如人口统计学、模型中的预测变量和结果，包括缺失值的比例。这可能最好以表格形式呈现，并考虑按结果状态报告。</p>
<p>实例 6《Development and validation of a prediction rule for estimating gastric cancer risk in the Chinese high-risk population: a nationwide multicentre study：在中国高危人群中建立和验证胃癌风险预测规则：一项全国性多中心研究》。</p>
</section>
</section>
<section id="模型开发指定每个分析例如模型开发超参数调优模型评估等中参与者和结果事件的数量de" class="level4">
<h4 class="anchored" data-anchor-id="模型开发指定每个分析例如模型开发超参数调优模型评估等中参与者和结果事件的数量de">21 模型开发：指定每个分析(例如,模型开发、超参数调优、模型评估等)中参与者和结果事件的数量。D；E</h4>
<p>应为每次分析（即每个模型开发、每个模型评估）报告样本量（包括结果事件的数量），因为它们在预测模型研究的不同分析中通常会有所不同（例如，在数据分区、模型超参数调整之后），尤其是在存在缺失数据的情况下；如果数据包含单个报告的多个样本或记录，也报告个体数量。</p>
</section>
<section id="模型规范提供完整预测模型例如公式代码对象应用程序编程接口等的详细信息允许在新的个体中进行预测并允许第三方评估和实施包括访问或重用例如免费的专有的的任何限制d" class="level4">
<h4 class="anchored" data-anchor-id="模型规范提供完整预测模型例如公式代码对象应用程序编程接口等的详细信息允许在新的个体中进行预测并允许第三方评估和实施包括访问或重用例如免费的专有的的任何限制d">22 模型规范：提供完整预测模型(例如,公式、代码、对象、应用程序编程接口等)的详细信息，允许在新的个体中进行预测，并允许第三方评估和实施，包括访问或重用(例如,免费的,专有的)的任何限制★。D</h4>
<p>预测模型开发研究的“产品product”是预测模型。因此，提供有关模型的详细信息以及如何使用它来预测新个体非常重要。例如，为回归模型提供方程，对于使用模型无法“写下”为方程的方法开发的模型，提供有关代码、软件对象或API可用性的详细信息，以便其他人可以在自己的数据中评估此模型，或在日常实践中实施它；如果开发了多个模型， 然后提供有关所有模型可用性的详细信息；解释如何使用该模型允许其他人对新个体进行预测；提供任何硬件要求和软件（和软件包）的详细信息，以实现第三方测试、实施和监控；如果模型无法公开可用（例如，出于商业原因），则应明确报告，并报告访问模型以计算新个体和第三方评估的预测的任何条件。</p>
<p>实例 6《Development and validation of a prediction rule for estimating gastric cancer risk in the Chinese high-risk population: a nationwide multicentre study：在中国高危人群中建立和验证胃癌风险预测规则：一项全国性多中心研究》。</p>
</section>
<section id="模型表现" class="level4">
<h4 class="anchored" data-anchor-id="模型表现">23 模型表现</h4>
<section id="报告模型性能估计的置信区间包括对任何关键子组的例如社会人口学考虑情节来辅助呈现de" class="level5">
<h5 class="anchored" data-anchor-id="报告模型性能估计的置信区间包括对任何关键子组的例如社会人口学考虑情节来辅助呈现de">23.1：报告模型性能估计的置信区间，包括对任何关键子组的(例如,社会人口学)。考虑情节来辅助呈现。D；E</h5>
<p>应将第 12e 项中描述的所有模型性能度量的估计值与置信区间一起呈现；报告总体和任何感兴趣关键群体（例如，性别、种族）（例如，作为公平性检查的一部分）的模型性能估计值，以及置信区间；使用图表来呈现和辅助评估，例如校准图（具有平滑的校准曲线和预测值的分布）和决策曲线；报告所有评估的性能估计值（例如，在开发数据中;在评估数据中;来自内部验证过程等），包括检查的每个时间点（用于预后模型）；报告模型稳定性的任何检查，例如，在自举样本中开发的模型中的性能估计和单个预测的可变性方面；清楚地指出哪些数据已被用于呈现每个性能估计。</p>
<p>实例 13《Interpretable machine learning-based clinical prediction model for predicting lymph node metastasis in patients with intrahepatic cholangiocarcinoma：可解释的基于机器学习的临床预测模型用于预测肝内胆管癌患者的淋巴结转移》。</p>
</section>
<section id="如果检查报告了跨集群的模型性能的任何异质性的结果详情见tripod-clusterde" class="level5">
<h5 class="anchored" data-anchor-id="如果检查报告了跨集群的模型性能的任何异质性的结果详情见tripod-clusterde">23.2：如果检查，报告了跨集群的模型性能的任何异质性的结果。详情见TRIPOD-Cluster。D；E</h5>
<p>如果模型性能的评估考虑了数据中的任何聚类（例如，来自组合来自多项研究的个体参与者数据，或按中心/医院或国家聚类的数据），则应报告结果以及置信区间（参见第23a项）；关预测模型研究的具体报告建议，这些研究考虑了模型性能的聚类和异质性， 作者应查阅TRIPOD-cluster清单。</p>
</section>
</section>
<section id="模型更新报告任何模型更新的结果包括更新后的模型和随后的性能e" class="level4">
<h4 class="anchored" data-anchor-id="模型更新报告任何模型更新的结果包括更新后的模型和随后的性能e">24 模型更新：报告任何模型更新的结果，包括更新后的模型和随后的性能。E</h4>
<p>如果预测模型在验证后进行了更新（例如，重新校准、重新拟合），则应报告更新后的预测模型的详细信息，以便进行第三方评估和实施，包括对访问或重复使用的任何限制（见第22项）；应报告更新模型的性能（参见第23a项，可能第23b项）。</p>
</section>
<section id="解释对主要结果进行总体解释包括目标和先前研究背景下的公平问题de" class="level4">
<h4 class="anchored" data-anchor-id="解释对主要结果进行总体解释包括目标和先前研究背景下的公平问题de">25 解释：对主要结果进行总体解释，包括目标和先前研究背景下的公平问题。D；E</h4>
<p>对研究结果的解释将研究结果置于其他证据的背景下。如果存在现有模型，则在这些现有研究的背景下讨论结果；对于评估现有预测模型性能的研究，如果现有研究已经评估了模型的性能，那么讨论和总结这些结果并将其置于上下文中非常重要；确保对结果的解释不会超出模型开发和评估报告的结果，以防止过度解释或“旋转”；了解模型在评估数据中的性能与该模型的任何其他评估研究中模型的性能进行比较是有用的。当结果出现分歧时，应讨论模型性能差异的可能原因。</p>
<p>实例 13《Interpretable machine learning-based clinical prediction model for predicting lymph node metastasis in patients with intrahepatic cholangiocarcinoma：可解释的基于机器学习的临床预测模型用于预测肝内胆管癌患者的淋巴结转移》。</p>
</section>
<section id="局限性讨论研究如非代表性样本样本量过拟合缺失数据等的任何局限性及其对任何偏倚统计不确定性和可推广性的影响de" class="level4">
<h4 class="anchored" data-anchor-id="局限性讨论研究如非代表性样本样本量过拟合缺失数据等的任何局限性及其对任何偏倚统计不确定性和可推广性的影响de">26 局限性：讨论研究(如非代表性样本、样本量、过拟合、缺失数据等)的任何局限性及其对任何偏倚、统计不确定性和可推广性的影响。D；E</h4>
<p>承认局限性是任何科学论文的一个重要方面——可以指研究设计、实施或分析的任何方面。对研究局限性进行有意义的讨论，考虑与分析中使用的数据的代表性、样本量、过度拟合和缺失数据/数据质量相关的任何问题。</p>
<p>实例 13《Interpretable machine learning-based clinical prediction model for predicting lymph node metastasis in patients with intrahepatic cholangiocarcinoma：可解释的基于机器学习的临床预测模型用于预测肝内胆管癌患者的淋巴结转移》。</p>
</section>
<section id="该模型在当前照护背景下的可用性" class="level4">
<h4 class="anchored" data-anchor-id="该模型在当前照护背景下的可用性">27 该模型在当前照护背景下的可用性</h4>
<section id="描述在实现预测模型时应该如何评估和处理质量差或不可用的输入数据例如预测值d" class="level5">
<h5 class="anchored" data-anchor-id="描述在实现预测模型时应该如何评估和处理质量差或不可用的输入数据例如预测值d">27.1：描述在实现预测模型时，应该如何评估和处理质量差或不可用的输入数据(例如,预测值)。D</h5>
<p>作者应该评论如何在模型打算用作日常实践中护理路径的一部分时处理不可用的预测变量值。还应评估在打算使用模型时估算缺失值的任何策略（因此在方法和结果中提到）；同样，在实施时，作者应讨论（如果相关）处理质量差的输入数据（例如，图像分辨率、数据格式）。</p>
<p>实例 14《Risk factors for severe respiratory syncytial virus infection during the first year of life: development and validation of a clinical prediction model：生命第1年发生严重呼吸道合胞病毒感染的危险因素：临床预测模型的建立与验证》。</p>
</section>
<section id="指定在处理输入数据或使用模型时是否需要用户进行交互以及需要用户具备何种水平的专业知识d" class="level5">
<h5 class="anchored" data-anchor-id="指定在处理输入数据或使用模型时是否需要用户进行交互以及需要用户具备何种水平的专业知识d">27.2：指定在处理输入数据或使用模型时是否需要用户进行交互，以及需要用户具备何种水平的专业知识。D</h5>
<p>提供有关预期或要求用户如何与预测模型交互以按预期使用模型的详细信息，例如处理输入数据的任何注意事项；使用模型、处理或收集输入数据是否需要或需要任何专业知识或培训，如果需要，请提供详细信息。</p>
</section>
<section id="讨论未来研究的任何后续步骤具体了解模型的适用性和可推广e" class="level5">
<h5 class="anchored" data-anchor-id="讨论未来研究的任何后续步骤具体了解模型的适用性和可推广e">27.3：讨论未来研究的任何后续步骤，具体了解模型的适用性和可推广。E</h5>
<p>是否需要对模型进行进一步评估，例如，在不同的人群或亚组中，或者模型是否准备好在临床试验中进行评估，或作为护理途径的一部分实施。</p>
<p>实例 14《Risk factors for severe respiratory syncytial virus infection during the first year of life: development and validation of a clinical prediction model：生命第1年发生严重呼吸道合胞病毒感染的危险因素：临床预测模型的建立与验证》。</p>


<!-- -->

</section>
</section>
</section>

 ]]></description>
  <category>journal club</category>
  <category>tripod</category>
  <category>ai</category>
  <guid>https://leslie-lu.github.io/blog/2024/11/29/TRIPOD_AI/</guid>
  <pubDate>Fri, 29 Nov 2024 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202411291930779.png" medium="image" type="image/png"/>
</item>
<item>
  <title>SAIGE</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/11/28/SAIGE/</link>
  <description><![CDATA[ 





<section id="saige" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="saige">SAIGE</h3>
<p>SAIGE（Scalable and Accurate Implementation of GEneralized mixed models）是一个用于大规模基因组关联研究（GWAS）的 <a href="https://saigegit.github.io/SAIGE-doc/" title="SAIGE">R 包</a>，旨在通过<code>广义混合模型（Generalized Mixed Models, GMM）</code>处理样本之间的相关性，并对大规模遗传数据进行高效分析。SAIGE 具有处理大量样本、考虑遗传关系、避免样本相关性干扰等优点，是解析全基因组数据的理想工具。</p>
<p>本文将介绍 SAIGE 的主要功能、使用场景及其工作原理。</p>
<section id="saige-的主要特点" class="level4">
<h4 class="anchored" data-anchor-id="saige-的主要特点">1. SAIGE 的主要特点</h4>
<section id="高效的计算方法" class="level5">
<h5 class="anchored" data-anchor-id="高效的计算方法">1.1 高效的计算方法</h5>
<p>SAIGE 的核心优势之一是其高效的计算方法。它能够处理大规模数据集，尤其适用于大约几十万到上百万的样本。SAIGE 通过采用广义混合模型（GMM）来估计样本之间的遗传相关性，从而准确估计每个基因位点的效应大小，并进行全基因组关联测试。</p>
</section>
<section id="处理样本相关性" class="level5">
<h5 class="anchored" data-anchor-id="处理样本相关性">1.2 处理样本相关性</h5>
<p>在 GWAS 中，样本之间的相关性（例如家族结构或人口结构）可能会导致结果的偏差。SAIGE 通过<code>基因型关系矩阵（GRM）</code>来处理样本的相关性，使得 GWAS 结果更加可靠。无论是亲缘关系还是其他类型的样本相关性，SAIGE 都能够有效地调整，避免不必要的假阳性结果。</p>
</section>
<section id="支持多种表型类型" class="level5">
<h5 class="anchored" data-anchor-id="支持多种表型类型">1.3 支持多种表型类型</h5>
<p>SAIGE 不仅支持定量性状（例如身高、体重等），还支持二元性状（例如病例对照数据）。它能够处理不同类型的表型，并针对不同表型类型应用相应的统计方法，例如，<code>Firth 的偏差减少逻辑回归（Firth’s Bias-Reduced Logistic Regression）</code>来分析稀有变异。</p>
</section>
<section id="稀有变异分析的扩展功能saige-gene" class="level5">
<h5 class="anchored" data-anchor-id="稀有变异分析的扩展功能saige-gene">1.4 稀有变异分析的扩展功能（SAIGE-GENE+）</h5>
<p>SAIGE-GENE+ 是 SAIGE 的扩展，用于稀有变异的集成分析。它提供了多种常用的稀有变异测试方法，包括 BURDEN 测试、SKAT 测试和 SKAT-O 测试，帮助识别变异集与表型的关系。</p>
</section>
<section id="高度可定制化" class="level5">
<h5 class="anchored" data-anchor-id="高度可定制化">1.5 高度可定制化</h5>
<p>SAIGE 允许用户根据实际需求调整参数，例如显著性阈值、遗传关系矩阵类型（完整或稀疏）等。此外，它还支持条件分析，可以在现有 GWAS 信号的基础上进行进一步的变异筛选。</p>
</section>
</section>
<section id="saige-的工作原理" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="saige-的工作原理">2. SAIGE 的工作原理</h4>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://saigegit.github.io/SAIGE-doc/assets/img/saige-siage-gene-outline.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">SAIGE 工作流程</figcaption>
</figure>
</div>
<p>SAIGE 使用广义混合模型（GMM）来估计样本之间的相关性，并对每个基因位点进行全基因组关联分析。其核心思想是通过计算每对样本之间的遗传关系矩阵（GRM），从而调整样本间的相关性，避免这些关系对关联分析结果的干扰。</p>
<p>在分析过程中，SAIGE 会先使用 GRM 计算出样本间的相关性，并根据遗传相关性调整表型和基因型数据。接下来，使用 <code>REML（限制最大似然法）</code>或其他拟合方法进行模型估计，最后通过统计检验得到每个 SNP 与表型之间的关联。</p>
<section id="计算遗传关系矩阵grm" class="level5">
<h5 class="anchored" data-anchor-id="计算遗传关系矩阵grm">2.1 计算遗传关系矩阵（GRM）</h5>
<p>遗传关系矩阵（GRM）用于量化样本之间的基因型相似性。SAIGE 支持两种类型的 GRM：完整 GRM 和 稀疏 GRM。对于大规模数据集，稀疏 GRM 可以显著减少计算成本。我们可以使用 PLINK 等工具计算 GRM 文件，并将其作为输入提供给 SAIGE。</p>
</section>
<section id="模型拟合与关联分析" class="level5">
<h5 class="anchored" data-anchor-id="模型拟合与关联分析">2.2 模型拟合与关联分析</h5>
<p>SAIGE 使用 限制最大似然法（REML） 或其他拟合方法来估计基因型和表型之间的关系。对于稀有变异，SAIGE 还提供了 Firth 偏差减少逻辑回归，提高了小样本数据和稀有变异分析的准确性。</p>


<!-- -->

</section>
</section>
</section>

 ]]></description>
  <category>saige</category>
  <category>gwas</category>
  <category>genomics</category>
  <guid>https://leslie-lu.github.io/blog/2024/11/28/SAIGE/</guid>
  <pubDate>Thu, 28 Nov 2024 00:00:00 GMT</pubDate>
  <media:content url="https://saigegit.github.io/SAIGE-doc/assets/img/saige-siage-gene-outline.png" medium="image" type="image/png"/>
</item>
<item>
  <title>连锁不平衡</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/11/26/LD/</link>
  <description><![CDATA[ 





<section id="连锁不平衡linkage-disequilibrium-ld" class="level3">
<h3 class="anchored" data-anchor-id="连锁不平衡linkage-disequilibrium-ld">连锁不平衡（Linkage Disequilibrium, LD）</h3>
<p><strong><a href="https://en.wikipedia.org/wiki/Linkage_disequilibrium" title="wiki">连锁不平衡（LD）</a></strong> 是群体遗传学和基因组学中的一个基本概念，用于描述两个或多个遗传标记（通常是单核苷酸多态性，SNP）之间的<strong>非随机关联</strong>。当某些 SNP 的等位基因 （allele）的组合在一个群体中出现的频率高于根据单独等位基因频率计算的预期频率时，这种现象被称为连锁不平衡。LD 是基因组关联分析（GWAS）和基因组选择等研究的重要基础，用于识别与复杂性状相关的遗传变异，并帮助推断遗传位点之间的关系。</p>
<p>连锁是指基因组中靠得很近的基因或遗传标记倾向于一起遗传的现象，这是由染色体重组的随机性和空间上的接近性引起的。而 LD 则描述了在一个群体中等位基因组合的统计学偏差，如果遗传标记之间的组合频率偏离预期（非随机关联），就表明存在 LD。</p>
</section>
<section id="ld的数学描述" class="level3">
<h3 class="anchored" data-anchor-id="ld的数学描述"><strong>LD的数学描述</strong></h3>
<p>连锁不平衡通常用两个指标来描述：<img src="https://latex.codecogs.com/png.latex?D'"> 和 <img src="https://latex.codecogs.com/png.latex?r%5E2">。</p>
<section id="不平衡系数d" class="level4">
<h4 class="anchored" data-anchor-id="不平衡系数d"><strong>1. 不平衡系数（D）</strong></h4>
<p>定义两个标记 <img src="https://latex.codecogs.com/png.latex?A"> 和 <img src="https://latex.codecogs.com/png.latex?B"> 的四种可能等位基因组合及其频率： - <img src="https://latex.codecogs.com/png.latex?A_1B_1">, <img src="https://latex.codecogs.com/png.latex?A_1B_2">, <img src="https://latex.codecogs.com/png.latex?A_2B_1">, <img src="https://latex.codecogs.com/png.latex?A_2B_2">，分别表示两位点上的不同等位基因组合。</p>
<p>设： - <img src="https://latex.codecogs.com/png.latex?P(A_1B_1)">：观察到 <img src="https://latex.codecogs.com/png.latex?A_1"> 和 <img src="https://latex.codecogs.com/png.latex?B_1"> 同时出现的频率。 - <img src="https://latex.codecogs.com/png.latex?P(A_1)">：<img src="https://latex.codecogs.com/png.latex?A_1"> 的边际频率。 - <img src="https://latex.codecogs.com/png.latex?P(B_1)">：<img src="https://latex.codecogs.com/png.latex?B_1"> 的边际频率。</p>
<p>则不平衡系数 <img src="https://latex.codecogs.com/png.latex?D"> 定义为：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AD%20=%20P(A_1B_1)%20-%20P(A_1)P(B_1)%0A"></p>
<ul>
<li>当 <img src="https://latex.codecogs.com/png.latex?D%20=%200"> 时，标记之间没有 LD，即独立遗传。</li>
<li>当 <img src="https://latex.codecogs.com/png.latex?D%20%5Cneq%200"> 时，标记之间存在 LD。</li>
</ul>
<p>然而，由于 <img src="https://latex.codecogs.com/png.latex?D"> 的值依赖于等位基因的频率，其绝对值没有固定的范围，因此通常会对其进行标准化。</p>
</section>
<section id="标准化不平衡系数d" class="level4">
<h4 class="anchored" data-anchor-id="标准化不平衡系数d"><strong>2. 标准化不平衡系数（<img src="https://latex.codecogs.com/png.latex?D'">）</strong></h4>
<p><img src="https://latex.codecogs.com/png.latex?%0AD'%20=%20%5Cfrac%7BD%7D%7BD_%7B%5Ctext%7Bmax%7D%7D%7D%0A"></p>
<p>其中 <img src="https://latex.codecogs.com/png.latex?D_%7B%5Ctext%7Bmax%7D%7D"> 是 <img src="https://latex.codecogs.com/png.latex?D"> 的可能最大值或最小值，取决于等位基因频率。</p>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?D'"> 的范围为 [-1, 1]。</li>
<li><img src="https://latex.codecogs.com/png.latex?D'%20=%201"> 表示完全连锁不平衡。</li>
</ul>
</section>
<section id="相关系数r2" class="level4">
<h4 class="anchored" data-anchor-id="相关系数r2"><strong>3. 相关系数（<img src="https://latex.codecogs.com/png.latex?r%5E2">）</strong></h4>
<p>但在群体遗传学中，其实我们更常用 <img src="https://latex.codecogs.com/png.latex?r%5E2"> 来衡量 LD：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0Ar%5E2%20=%20%5Cfrac%7BD%5E2%7D%7BP(A_1)P(A_2)P(B_1)P(B_2)%7D%0A"></p>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?r%5E2"> 的范围为 [0, 1]。</li>
<li><img src="https://latex.codecogs.com/png.latex?r%5E2%20=%200">：标记之间完全独立。</li>
<li><img src="https://latex.codecogs.com/png.latex?r%5E2%20=%201">：标记之间完全关联。</li>
<li><img src="https://latex.codecogs.com/png.latex?r%5E2"> 的值通常用于评估 GWAS 研究中的 SNP 冗余。</li>
</ul>


<!-- -->

</section>
</section>

 ]]></description>
  <category>linkage disequilibrium</category>
  <category>genetics</category>
  <guid>https://leslie-lu.github.io/blog/2024/11/26/LD/</guid>
  <pubDate>Tue, 26 Nov 2024 00:00:00 GMT</pubDate>
  <media:content url="https://upload.wikimedia.org/wikipedia/commons/9/92/Linkage_Disequilibrium_Heatmap.png" medium="image" type="image/png"/>
</item>
<item>
  <title>累积风险图（Cumulative Hazard Plot）中的 Y 轴含义</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/11/22/cumulative_hazard/</link>
  <description><![CDATA[ 





<section id="问题" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="问题">问题</h3>
<p><a href="https://mp.weixin.qq.com/s/4IR-KMAZ-q2VbI0Fz4fYRg">星球</a>里有同学提问：</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202411221925709.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">cumulative hazard plot</figcaption>
</figure>
</div>
<section id="累积风险函数" class="level4">
<h4 class="anchored" data-anchor-id="累积风险函数">累积风险函数</h4>
<p>在时间事件数据中，<strong>累积风险图（cumulative hazard plot）</strong>的 Y 轴表示的是累积风险函数（cumulative hazard function, <img src="https://latex.codecogs.com/png.latex?H(t)">）。<img src="https://latex.codecogs.com/png.latex?H(t)"> 描述的是从起始时间到 <img src="https://latex.codecogs.com/png.latex?t"> 时刻，某个事件发生的<strong>累积风险总和</strong>。它是通过对瞬时风险函数（即危险率，hazard rate, <img src="https://latex.codecogs.com/png.latex?h(t)">）在时间上的积分得到的，公式为 <span class="citation" data-cites="RN529">(Allison 2010)</span>：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AH(t)%20=%20%5Cint_%7B0%7D%5E%7Bt%7D%20h(u)%20%5C,%20du%0A"></p>
<p>其中，<img src="https://latex.codecogs.com/png.latex?h(t)"> 是已生存到 <img src="https://latex.codecogs.com/png.latex?t"> 时刻的对象在 <img src="https://latex.codecogs.com/png.latex?t"> 时刻发生事件的速率。<img src="https://latex.codecogs.com/png.latex?H(t)"> 没有上限值，它随着时间 <img src="https://latex.codecogs.com/png.latex?t"> 的增加而单调递增。</p>
</section>
<section id="累积风险与-hr风险比的关系" class="level4">
<h4 class="anchored" data-anchor-id="累积风险与-hr风险比的关系">累积风险与 HR（风险比）的关系</h4>
<p>HR 是比较两组（如治疗组与对照组）瞬时风险率 <img src="https://latex.codecogs.com/png.latex?h(t)"> 的比值：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AHR%20=%20%5Cfrac%7Bh_1(t)%7D%7Bh_2(t)%7D%0A"></p>
<p>它是一个相对指标，表示某组的风险率是另一组的多少倍。对 HR 的理解，可以类比 OR 的概念，只是 HR 是在时间上的比值，而 OR 无时间信息。如果时间对事件的影响较小（比如事件发生概率很低或者随访时间很短），HR 和 OR 的数值可能接近。但在事件发生率较高时，OR 通常会高于 HR，因为 OR 夸大了实际的效应。</p>
<p>前面的累积风险函数 <img src="https://latex.codecogs.com/png.latex?H(t)"> 与瞬时风险率 <img src="https://latex.codecogs.com/png.latex?h(t)"> 紧密相关，若 HR 在所有时间上恒定（即比例风险假设成立），则累积风险函数之间的关系为：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AH_1(t)%20=%20HR%20%5Ccdot%20H_2(t)%0A"></p>
<p>这意味着在比例风险假设成立的情况下，<strong>累积风险图中两组曲线的斜率比值大致等于 HR</strong>，即如果两组的 HR 恒定不变，则累积风险曲线在对数尺度下呈现平行关系。而如果 HR 随时间变化，累积风险曲线的差异会随着时间的推移而增大或缩小。从这个角度看，累积风险图可以通过曲线的趋势和两组曲线间的相对关系直观地展示 HR 的变化。</p>


<!-- -->


</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0">
<div id="ref-RN529" class="csl-entry">
Allison, Paul D. 2010. <em>Survival Analysis Using SAS: A Practical Guide</em>. Book. Sas Institute.
</div>
</div></section></div> ]]></description>
  <category>surival analysis</category>
  <category>cumulative hazard plot</category>
  <category>hazard function</category>
  <guid>https://leslie-lu.github.io/blog/2024/11/22/cumulative_hazard/</guid>
  <pubDate>Fri, 22 Nov 2024 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202411221925709.png" medium="image" type="image/png"/>
</item>
<item>
  <title>R 中面向对象编程系统选择</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/10/02/oop/</link>
  <description><![CDATA[ <blockquote class="blockquote">
<p>我们在很久以前稍微介绍过 <a href="https://mp.weixin.qq.com/s/Y5qaF5pPnY3DS2FTm4njkA">R 语言的面向对象编程</a>，但是没有深入对比。今天我们将讨论 R 语言中的面向对象编程系统，包括 S3、S4 和 R6。</p>
</blockquote>
<p>在R语言中，面向对象编程（OOP，object oriented programming）提供了多种系统供用户选择。每种系统都有其独特的特点、优缺点以及适用场景。</p>
<section id="oop系统概述" class="level3"><h3 class="anchored" data-anchor-id="oop系统概述">OOP系统概述</h3>
<p>R主要有三种面向对象编程系统：</p>
<ol type="1">
<li><p><strong>S3</strong></p></li>
<li><p><strong>S4</strong></p></li>
<li><p><strong>R6</strong></p></li>
</ol>
<section id="s3-系统" class="level4"><h4 class="anchored" data-anchor-id="s3-系统">S3 系统</h4>
<p>S3 是一种轻量级的面向对象系统，主要通过使用属性来实现。它的优点在于简单易用，适合快速开发。</p>
<section id="特点" class="level5"><h5 class="anchored" data-anchor-id="特点">特点</h5>
<ul>
<li><p><strong>灵活性</strong>: S3 允许任意对象成为类。</p></li>
<li><p><strong>简洁性</strong>: 类定义和方法定义非常简单。</p></li>
<li><p><strong>动态性</strong>: 可以在运行时添加方法和属性。</p></li>
</ul></section><section id="示例代码" class="level5"><h5 class="anchored" data-anchor-id="示例代码">示例代码</h5>
<div class="cell">
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">my_s3_class</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">function</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">x</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span></span>
<span>  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;"><a href="https://rdrr.io/r/base/structure.html">structure</a></span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>value <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">x</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span>, class <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"my_class"</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span></span>
<span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span>
<span></span>
<span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">print.my_class</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">function</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">obj</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span></span>
<span>  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"The value is:"</span>, <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">obj</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">$</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">value</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"\n"</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span></span>
<span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span>
<span></span>
<span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">obj</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">my_s3_class</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">10</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span></span>
<span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;"><a href="https://rdrr.io/r/base/print.html">print</a></span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">obj</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span></span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>The value is: 10 </code></pre>
</div>
</div>
</section></section><section id="s4系统" class="level4"><h4 class="anchored" data-anchor-id="s4系统">S4系统</h4>
<p>S4 系统比 S3 更严格，支持正式的类定义和方法。适合需要高可靠性的应用。</p>
<section id="特点-1" class="level5"><h5 class="anchored" data-anchor-id="特点-1">特点</h5>
<ul>
<li><p><strong>严格性</strong>: 类和方法都需要明确定义。</p></li>
<li><p><strong>类型检查</strong>: 提供更好的类型安全性。</p></li>
<li><p><strong>多重继承</strong>: 支持多重继承，增加灵活性。</p></li>
</ul></section><section id="示例代码-1" class="level5"><h5 class="anchored" data-anchor-id="示例代码-1">示例代码</h5>
<div class="cell">
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">setClass</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"myS4Class"</span>, slots <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>value <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"numeric"</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span></span>
<span></span>
<span><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">setMethod</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"show"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"myS4Class"</span>, <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">function</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">object</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span></span>
<span>  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"The value is:"</span>, <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">object</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">@</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">value</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"\n"</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span></span>
<span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span></span>
<span></span>
<span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">obj</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">new</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"myS4Class"</span>, value <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">20</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span></span>
<span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">show</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">obj</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span></span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>The value is: 20 </code></pre>
</div>
</div>
</section></section><section id="r6-系统" class="level4"><h4 class="anchored" data-anchor-id="r6-系统">R6 系统</h4>
<p>R6 是最新的 OOP 系统，支持封装、私有字段和方法，使得代码更模块化。</p>
<section id="特点-2" class="level5"><h5 class="anchored" data-anchor-id="特点-2">特点</h5>
<ul>
<li><p><strong>封装性</strong>: 支持私有字段和方法。</p></li>
<li><p><strong>简洁性</strong>: 语法与其他 OOP 语言相似。</p></li>
<li><p><strong>高效性</strong>: 对性能有较好的优化。</p></li>
</ul></section><section id="示例代码-2" class="level5"><h5 class="anchored" data-anchor-id="示例代码-2">示例代码</h5>
<div class="cell">
<div class="sourceCode" id="cb5" style="background: #f1f3f5;"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;"><a href="https://r6.r-lib.org">R6</a></span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span></span>
<span></span>
<span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">MyR6Class</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;"><a href="https://r6.r-lib.org/reference/R6Class.html">R6Class</a></span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"MyR6Class"</span>,</span>
<span>  public <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span></span>
<span>    value <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="cn" style="color: #8f5902;
background-color: null;
font-style: inherit;">NULL</span>,</span>
<span>    initialize <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">function</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">value</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span></span>
<span>      <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">$</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">value</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">value</span></span>
<span>    <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span>,</span>
<span>    print_value <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">function</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span></span>
<span>      <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"The value is:"</span>, <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">$</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">value</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"\n"</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span></span>
<span>    <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span>
<span>  <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span></span>
<span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span></span>
<span></span>
<span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">obj</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">MyR6Class</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">$</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">new</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">30</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span></span>
<span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">obj</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">$</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">print_value</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span></span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>The value is: 30 </code></pre>
</div>
</div>
</section></section></section><section id="选择合适的系统" class="level3"><h3 class="anchored" data-anchor-id="选择合适的系统">选择合适的系统</h3>
<p>在选择 R 中的 OOP 系统时，考虑项目的复杂性、可维护性及团队的熟悉程度是关键。</p>
<ul>
<li><p>S3: 适合快速开发和简单应用。适合初学者或小型项目。</p></li>
<li><p>S4: 适合需要严格类型检查和复杂结构的应用。常用于研究领域或需要高可靠性的项目。</p></li>
<li><p>R6: 适合需要封装和私有成员的场景。适合大型项目和复杂数据结构的开发。</p></li>
</ul>
<p>完整代码已经放在了<a href="https://mp.weixin.qq.com/s/4IR-KMAZ-q2VbI0Fz4fYRg">星球</a>里，感兴趣的同学可以自行查看。</p>


<!-- -->

</section> ]]></description>
  <category>r</category>
  <category>object oriented programming</category>
  <guid>https://leslie-lu.github.io/blog/2024/10/02/oop/</guid>
  <pubDate>Wed, 02 Oct 2024 00:00:00 GMT</pubDate>
  <media:content url="https://d2jdgazzki9vjm.cloudfront.net/tutorial/r/images/r-object-oriented-programming.png" medium="image" type="image/png"/>
</item>
<item>
  <title>星球JC | 高尿酸血症及相关代谢疾病风险模型</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/09/25/jc/</link>
  <description><![CDATA[ 





<blockquote class="blockquote">
<p>大家好，这一期预测模型星球Journal Club的分享来自青岛大学的 hedwig 同学。</p>
</blockquote>
<p>这篇文章是 2024年 发表在 science 子刊 advanced scicence，题为 Multimodal Machine Learning-Based Marker Enables Early Detection and Prognosis Prediction for Hyperuricemia <span class="citation" data-cites="RN1343">(Zeng et al. 2024)</span>。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202409251439788.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">title</figcaption>
</figure>
</div>
<section id="研究背景" class="level3">
<h3 class="anchored" data-anchor-id="研究背景">研究背景</h3>
<p>高尿酸血症（HUA）是指由于体内尿酸生成增加或排泄减少而导致的血清尿酸（SUA）水平升高。SUA 升高不仅会导致痛风，同时也会增加其他代谢异常风险，如慢性肾病、高血压、心血管疾病以及糖尿病。因此，早期识别HUA和预测痛风风险，能够为提早干预和预后管理提供宝贵见解。</p>
<p>目前，HUA 或痛风的风险评估主要依赖于临床指标或多基因风险评分（PRSs），缺乏将遗传和临床特征相结合的预测模型。另外，现有模型只是单纯预测 HUA 是否发生，但没有更加具体地量化 HUA 风险。</p>
<p>本研究旨在结合遗传和临床数据，开发并验证一个叠加的多模态机器学习模型，以便及时识别 HUA，及早预测痛风以及代谢相关疾病。</p>
</section>
<section id="研究方法" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="研究方法">研究方法</h3>
<section id="研究类型" class="level4">
<h4 class="anchored" data-anchor-id="研究类型">研究类型</h4>
<p>多中心研究。</p>
</section>
<section id="研究人群" class="level4">
<h4 class="anchored" data-anchor-id="研究人群">研究人群</h4>
<p>英国和中国两个队列。</p>
<p>UKBB 是一项正在进行的前瞻性研究，研究对象为 2006 年至 2010 年间招募的 50 万名年龄在 40-69 岁之间的个体，收集数据包括临床、基因型以及多次随访数据；南方医院数据集包括接受健康体检的参与者的信息。参与者为从 2015 年至 2020 年期间到医院体检的年龄 ≥18 岁的人群。</p>
</section>
<section id="模型构建" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="模型构建">模型构建</h4>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202409251446365.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">study design</figcaption>
</figure>
</div>
<p>UKBB 数据随机按 8:2 分为训练集和内部测试集；南方医院数据作为外部测试集。</p>
<p>筛选相关临床特征：根据以往文献选择了 10 个重要变量，此外，对于基因数据，采用 LASSO 筛选对 HUA 有预测价值的 SNP。考虑到基因数据和临床特征变量的尺度不同，研究对所有变量进行标准化处理。</p>
<p>构建预测模型：研究采用集成学习的方式，将多个机器学习模型集成起来，将基分类器输出的预测概率作为 meta-classifier 的输入特征。其中，基分类器包含 7 个模型：Light Gradient-Boosting Machine、classical extreme Gradient Boosting、Categorical Boosting、Random Forest、Adaptive Boosting、Logistic Regression 以及 K-Nearest Neighbor，meta-classifier 为 classical extreme Gradient Boosting。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202409251448150.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">ensemble learning</figcaption>
</figure>
</div>
<p>预后价值判断：对于 meta-classifier 输出的概率，研究即视为 ISHUA 分值，使用最大约登指数进行 cutoff 的确定（全部使用终点为痛风的 cutoff），依据 ISHUA 的 cutoff 值，研究将人群分为低风险与高风险亚组，进而利用随访数据，使用 KM 生存曲线及 Cox 回归，评价其对痛风及代谢相关疾病预后的预测价值。</p>
<p>生活方式评价：利用模型划分的风险亚组，估计高风险组中生活方式与痛风及代谢相关疾病发生的相关关系。</p>
</section>
</section>
<section id="研究结果" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="研究结果">研究结果</h3>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202409251450510.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">Table 1</figcaption>
</figure>
</div>
<p>对于临床特征：利用单因素 Logistic 回归分析 10 个临床特征与 HUA 之间的相关关系，筛选的临床特征均与高尿酸血症具有显著相关性。此外使用 Cox 回归分析这 10 个特征与与痛风之间的关系。</p>
<p>对于基因特征：从 GWAS 分析结果中选择与 SUA 相关（p 值小于 <img src="https://latex.codecogs.com/png.latex?5%5Ctimes%7B10%7D%5E5"> 或以往研究报道在跨种族人群中相关）的 SNP，对选中的 SNP 进行注释，并基于确定的 SNP 进行富集分析（GO 和 KEGG 分析）。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202409251453156.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">enrichment analysis</figcaption>
</figure>
</div>
<section id="模型性能评价" class="level4">
<h4 class="anchored" data-anchor-id="模型性能评价">模型性能评价</h4>
<p>在训练集中，使用遗传特征的模型预测 HUA 的 AUC 为 0.703（95%CI：0.700-0.705），使用临床特征的模型预测 HUA 的 AUC 为 0.822（95%CI：0.820-0.824），而结合了遗传和临床特征的堆叠多模态模型 AUC 为 0.859（95%CI：0.857-0.861）。</p>
<p>在内部测试集和外部测试集中，堆叠多模态模型的预测性能也明显优于单独的遗传或临床模型。此外，基于两个年龄亚组（以 40 岁为界）评价模型表现，发现模型在不同年龄组中均具有较好的性能。</p>
</section>
<section id="ishua-的预后评估" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="ishua-的预后评估">ISHUA 的预后评估</h4>
<p>ISHUA 与已知的 HUA 风险因素（人口统计、临床和遗传）相关性。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202409251455716.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">association</figcaption>
</figure>
</div>
<p>ISHUA 预测痛风及其他代谢相关性结局（Gout、AF、CAD、DmT2、HF、Hypertension、ESRD、All-cause death），Kaplan-Meier 生存曲线显示，ISHUA 分组能够较好地区分痛风及其他代谢相关性疾病。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202409251456843.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">prognosis</figcaption>
</figure>
</div>
<p>此外，还探讨了改变生活方式对不良结局的潜在获益。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202409251457970.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">lifestyle</figcaption>
</figure>
</div>
</section>
</section>
<section id="take-home-message" class="level3">
<h3 class="anchored" data-anchor-id="take-home-message">Take home message</h3>
<ol type="1">
<li><p>文章同时纳入基因和临床特征数据，提升对 HUA 的预测能力；</p></li>
<li><p>结合长期随访数据，观察模型的风险分组对相关疾病发生发展的预测价值。</p></li>
</ol>


<!-- -->


</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0">
<div id="ref-RN1343" class="csl-entry">
Zeng, Lin, Pengcheng Ma, Zeyang Li, Shengxing Liang, Chengkai Wu, Chang Hong, Yan Li, et al. 2024. <span>“Multimodal Machine Learning-Based Marker Enables Early Detection and Prognosis Prediction for Hyperuricemia.”</span> Journal Article. <em>Advanced Science</em> 11 (34): 2404047. <a href="https://doi.org/10.1002/advs.202404047">https://doi.org/10.1002/advs.202404047</a>.
</div>
</div></section></div> ]]></description>
  <category>journal club</category>
  <guid>https://leslie-lu.github.io/blog/2024/09/25/jc/</guid>
  <pubDate>Wed, 25 Sep 2024 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202409251439788.png" medium="image" type="image/png"/>
</item>
<item>
  <title>解析 Beta 分布与贝叶斯</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/09/16/beta_dist/</link>
  <description><![CDATA[ 





<p>看到<a href="https://mp.weixin.qq.com/s/sLj_DzkLGHb0qlKQWBXzgg" title="Beta分布">小白学统计</a>发了一篇文章介绍 Beta 分布，我们也更新一篇文章解析 Beta 分布与贝叶斯。</p>
<section id="什么是-beta-分布" class="level3">
<h3 class="anchored" data-anchor-id="什么是-beta-分布">1. 什么是 Beta 分布？</h3>
<p>Beta 分布是一种定义在 <code>(0,1)</code> 区间的连续概率分布，用来描述比例或概率等数据。例如，应用于研究某事件发生的概率。它由两个参数 <img src="https://latex.codecogs.com/png.latex?%5Calpha"> 和 <img src="https://latex.codecogs.com/png.latex?%5Cbeta"> 决定：</p>
<ul>
<li><p><strong><img src="https://latex.codecogs.com/png.latex?%5Calpha"> = <img src="https://latex.codecogs.com/png.latex?%5Cbeta"> = 1</strong>：均匀分布，即所有概率值等可能。</p></li>
<li><p><strong><img src="https://latex.codecogs.com/png.latex?%5Calpha"> &gt; 1</strong> 和 <strong><img src="https://latex.codecogs.com/png.latex?%5Cbeta"> &gt; 1</strong>：生成钟形分布，集中于中间。</p></li>
<li><p><strong><img src="https://latex.codecogs.com/png.latex?%5Calpha"> &lt; 1</strong> 或 <strong><img src="https://latex.codecogs.com/png.latex?%5Cbeta"> &lt; 1</strong>：分布会更靠近 0 或 1。</p></li>
</ul>
<p>这种灵活性使得 Beta 分布特别适合于建模那些约束在 (0,1) 之间的变量，比如成功概率、比率等。其概率密度函数为：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0Af(x;%20%5Calpha,%20%5Cbeta)%20=%20%5Cfrac%7Bx%5E%7B%5Calpha-1%7D%20(1-x)%5E%7B%5Cbeta-1%7D%7D%7BB(%5Calpha,%20%5Cbeta)%7D%0A"></p>
<p>其中，B(<img src="https://latex.codecogs.com/png.latex?%5Calpha">, <img src="https://latex.codecogs.com/png.latex?%5Cbeta">) 为 Beta 函数，相当于归一化因子，使得概率密度函数的积分等于 1。</p>
<p>Beta 分布广泛用于表示成功概率的先验分布，是 <strong>贝叶斯推断</strong> 中的常用工具。通过观察数据，不断更新 Beta 分布的 <img src="https://latex.codecogs.com/png.latex?%5Calpha"> 和 <img src="https://latex.codecogs.com/png.latex?%5Cbeta"> 参数，进而得到后验分布。</p>
</section>
<section id="贝叶斯视角下的-beta-分布" class="level3">
<h3 class="anchored" data-anchor-id="贝叶斯视角下的-beta-分布">2. 贝叶斯视角下的 Beta 分布</h3>
<p>在贝叶斯统计中，Beta 分布通常作为 <strong>二项分布</strong> 的共轭先验分布。</p>
<blockquote class="blockquote">
<p>当先验分布和后验分布属于同一族分布时，我们说这个先验分布是似然函数的共轭先验。共轭分布的主要优点是它们简化了后验分布的计算。</p>
</blockquote>
<p>例如，如果我们有某事件的观测数据，并且希望估计成功概率 p，假设 p 的先验分布为 Beta 分布，则观测到 n 次成功和 m 次失败后，新的后验分布仍为 Beta 分布，其更新规则为：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Calpha_%7B%5Ctext%7B%E5%90%8E%E9%AA%8C%7D%7D%20=%20%5Calpha_%7B%5Ctext%7B%E5%85%88%E9%AA%8C%7D%7D%20+%20n%0A"></p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbeta_%7B%5Ctext%7B%E5%90%8E%E9%AA%8C%7D%7D%20=%20%5Cbeta_%7B%5Ctext%7B%E5%85%88%E9%AA%8C%7D%7D%20+%20m%0A"></p>
<p>这意味着 Beta 分布可以在贝叶斯分析中通过数据观察逐步更新。这也是小白说统计文章里例子的原理来源。</p>
</section>
<section id="betareg-包的功能" class="level3">
<h3 class="anchored" data-anchor-id="betareg-包的功能">3. <code>betareg</code> 包的功能</h3>
<p><strong><a href="https://topmodels.r-forge.r-project.org/betareg/" title="betareg 包">betareg</a></strong> 包是 R 语言中用于处理 Beta 回归模型的工具，适用于 (0,1) 区间的比例数据建模。这些数据通常不适合使用传统的线性回归模型，因为响应变量的范围受到限制。Beta 回归模型假设响应变量服从 Beta 分布，提供了一种灵活的方式来处理这些约束性数据。主要功能包括：</p>
<ul>
<li><p><strong>处理边界值</strong>：如接近 0 或 1 的极端数据点。</p></li>
<li><p><strong>偏差校正</strong>：特别在样本量小的情况下，能够进行精确估计。</p></li>
<li><p><strong>扩展模型</strong>：支持有限混合模型，用于处理具有不同组别特征的数据。</p></li>
</ul>
</section>
<section id="beta-回归的应用场景" class="level3">
<h3 class="anchored" data-anchor-id="beta-回归的应用场景">4. Beta 回归的应用场景</h3>
<p>Beta 回归在实际数据分析中有许多应用，尤其在以下几类问题中：</p>
<ul>
<li><p><strong>生物统计学</strong>：如疾病发病率、药物疗效等。</p></li>
<li><p><strong>金融</strong>：如股票收益率、风险度量等。</p></li>
<li><p><strong>市场营销</strong>：如用户转化率、广告点击率等。</p></li>
</ul>


<!-- -->

</section>

 ]]></description>
  <category>beta distribution</category>
  <category>bayesian</category>
  <category>probability</category>
  <category>biostatistics</category>
  <guid>https://leslie-lu.github.io/blog/2024/09/16/beta_dist/</guid>
  <pubDate>Mon, 16 Sep 2024 00:00:00 GMT</pubDate>
  <media:content url="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f3/Beta_distribution_pdf.svg/325px-Beta_distribution_pdf.svg.png" medium="image" type="image/png"/>
</item>
<item>
  <title>Software 2.0</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/09/11/software_2.0/</link>
  <description><![CDATA[ 





<p>在过去几十年里，软件开发的核心一直是由人类编写规则和逻辑的传统编程，即<code>Software 1.0</code>。程序员用代码构建起一个个复杂的系统，通过显式的规则解决问题。但随着深度学习和神经网络技术的崛起，这种模式正在逐渐被颠覆。<a href="https://karpathy.medium.com/software-2-0-a64152b37c35">Andrej Karpathy</a> 提出的<code>Software 2.0</code>概念，深入探讨了其对未来的影响。</p>
<section id="什么是-software-2.0" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="什么是-software-2.0">什么是 Software 2.0 ？</h3>
<p>Software 2.0 是指通过训练神经网络来生成程序，替代手动编写代码。简单来说，机器不再依赖程序员的硬编码，而是通过大量的数据和学习算法来获得解决问题的能力。例如，过去我们可能需要为图像识别编写复杂的规则，而在 Software 2.0 中，算法通过提供大量标记图像进行训练，自动学会识别不同类别的物体。</p>
<p>在这个新的编程范式中，<strong>代码不再由人类编写，而是通过机器学习生成</strong>。这个过程的核心不再是编写清晰的规则，而是设计良好的神经网络架构，并用足够多的高质量数据进行训练。最终，机器通过训练模型来预测和处理任务。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*7aTCueMW8oBRiqkyobunVA.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">software 2.0</figcaption>
</figure>
</div>
</section>
<section id="software-1.0-与-2.0-的对比" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="software-1.0-与-2.0-的对比">Software 1.0 与 2.0 的对比</h3>
<p>传统的 Software 1.0 主要依赖人类编写的逻辑和规则。在这种模式下，开发者根据明确的需求编写代码，并对程序行为进行详细的控制。而在 Software 2.0 中，开发人员的角色更多地转向了管理数据、设计模型架构以及优化算法。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*CHcu2L0NmAZwCpQgmS1ByA.jpeg" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">programming</figcaption>
</figure>
</div>
<table class="caption-top table">
<colgroup>
<col style="width: 13%">
<col style="width: 43%">
<col style="width: 42%">
</colgroup>
<thead>
<tr class="header">
<th>特性</th>
<th>Software 1.0</th>
<th>Software 2.0</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>开发方式</td>
<td>人类编写显式规则</td>
<td>通过神经网络训练自动生成</td>
</tr>
<tr class="even">
<td>代码控制</td>
<td>开发人员详细控制代码逻辑</td>
<td>依赖数据和训练模型生成解决方案</td>
</tr>
<tr class="odd">
<td>依赖因素</td>
<td>编程语言、开发工具</td>
<td>数据质量、模型架构、训练算法</td>
</tr>
<tr class="even">
<td>开发者角色</td>
<td>编写程序和调试代码</td>
<td>管理数据、设计架构、优化模型</td>
</tr>
</tbody>
</table>
<p>从表中可以看出，Software 2.0 是一种更为抽象的开发模式，开发者的工作重心从直接编写代码转移到了更高层次的架构设计和数据处理。</p>
</section>
<section id="数据的重要性" class="level3">
<h3 class="anchored" data-anchor-id="数据的重要性">数据的重要性</h3>
<p>在 Software 2.0 中，数据是最关键的资源。模型的性能和准确性与数据量和质量息息相关。因此，数据的标注、收集和处理成为了决定模型成败的关键。与传统编程不同，开发人员不再关心每一个细节的实现，而是通过大量高质量的数据来训练神经网络，使其能够自主推导出解决问题的最佳方案。</p>
</section>
<section id="开发者角色的转变" class="level3">
<h3 class="anchored" data-anchor-id="开发者角色的转变">开发者角色的转变</h3>
<p>在这种新的编程范式下，开发者的角色发生了根本性变化。程序员不再需要直接编写实现任务的规则，而是专注于以下几方面：</p>
<ol type="1">
<li><p><strong>数据管理</strong>：负责收集、清理和标注数据。</p></li>
<li><p><strong>模型设计</strong>：选择和设计合适的神经网络架构，如卷积神经网络（CNN）或循环神经网络（RNN）。</p></li>
<li><p><strong>超参数调整</strong>：在训练过程中调整参数优化模型。</p></li>
<li><p><strong>模型评估与调优</strong>：通过测试集评估模型效果，分析模型的表现并不断改进。</p></li>
</ol>
<p>这种转变带来了开发流程的简化，也使开发人员的工作重点转移到了模型架构和数据质量的把控上。</p>
</section>
<section id="神经网络的能力与挑战" class="level3">
<h3 class="anchored" data-anchor-id="神经网络的能力与挑战">神经网络的能力与挑战</h3>
<p>通过神经网络，机器可以在各种复杂任务上表现出超越传统规则编程的能力。这些任务包括图像分类、自然语言处理、自动驾驶等领域。然而，神经网络本身也带来了新的挑战，例如：</p>
<ul>
<li><p><strong>黑箱问题</strong>：难以解释其决策过程。</p></li>
<li><p><strong>数据依赖性</strong>：模型的性能高度依赖数据质量。</p></li>
</ul>
</section>
<section id="未来展望" class="level3">
<h3 class="anchored" data-anchor-id="未来展望">未来展望</h3>
<p>Software 2.0 的出现标志着软件开发进入了一个全新的时代。随着计算能力的增强、数据资源的增长以及深度学习技术的突破，越来越多的领域将从传统编程模式转向数据驱动的神经网络模型。</p>
<p>未来，开发者将逐渐从具体的代码编写中解放出来，转而专注于更高层次的架构设计和数据优化。Software 2.0 不仅提高了开发效率，还能在许多复杂任务中表现出前所未有的能力，彻底改变我们构建软件的方式。</p>
<hr>
<p><strong>结语</strong></p>
<p>Software 2.0 的核心思想是用数据和神经网络取代传统代码编写。随着这项技术的进步，编程范式将发生深刻变革。开发者需要适应这一趋势，掌握更多的数据处理和模型设计技能，以应对这个数据驱动的新时代。</p>


<!-- -->

</section>

 ]]></description>
  <category>deep learning</category>
  <category>software</category>
  <guid>https://leslie-lu.github.io/blog/2024/09/11/software_2.0/</guid>
  <pubDate>Wed, 11 Sep 2024 00:00:00 GMT</pubDate>
  <media:content url="https://miro.medium.com/v2/resize:fit:720/format:webp/1*5NG3U8MsaTqmQpjkr_-UOw.png" medium="image" type="image/png"/>
</item>
<item>
  <title>爱因斯坦求和</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/09/09/einsum/</link>
  <description><![CDATA[ 





<p>在物理学、机器学习、科学计算等领域，张量的操作是常见而又复杂的。而在张量操作中，有一种优雅的数学简化工具，即爱因斯坦求和约定（Einstein Summation Convention），它极大地减少了公式的复杂性，特别是在高维张量的运算中。</p>
<section id="什么是爱因斯坦求和" class="level3">
<h3 class="anchored" data-anchor-id="什么是爱因斯坦求和">什么是爱因斯坦求和？</h3>
<p>爱因斯坦求和约定是由著名物理学家阿尔伯特·爱因斯坦提出的一种简化公式的符号约定。根据这一约定，当一个表达式中有重复的索引变量时，默认对该索引进行求和运算，而不需要显式地写出求和符号。</p>
<p>例如，两个矩阵 (A) 和 (B) 的乘法可以通过爱因斯坦求和简化。通常，矩阵乘法公式为：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AC_%7Bik%7D%20=%20%5Csum_%7Bj%7D%20A_%7Bij%7D%20B_%7Bjk%7D%0A"></p>
<p>在爱因斯坦求和的符号下，重复出现的索引 (j) 表示对其求和，因此公式可以写为：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AC_%7Bik%7D%20=%20A_%7Bij%7D%20B_%7Bjk%7D%0A"></p>
<p>我们用torch实现这个例子：</p>
<div id="5d639b15" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> torch</span>
<span id="cb1-2">a <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> torch.arange(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">6</span>).reshape(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>)</span>
<span id="cb1-3">b <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> torch.arange(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">15</span>).reshape(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>)</span>
<span id="cb1-4">torch.einsum(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'ik,kj-&gt;ij'</span>, [a, b])</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>tensor([[ 25,  28,  31,  34,  37],
        [ 70,  82,  94, 106, 118]])</code></pre>
</div>
</div>
<section id="column-sum" class="level4">
<h4 class="anchored" data-anchor-id="column-sum">column sum</h4>
<div id="5cfdd508" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1">a <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> torch.arange(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">6</span>).reshape(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>)</span>
<span id="cb3-2">torch.einsum(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'ij-&gt;j'</span>, [a])</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="2">
<pre><code>tensor([3, 5, 7])</code></pre>
</div>
</div>
</section>
<section id="row-sum" class="level4">
<h4 class="anchored" data-anchor-id="row-sum">row sum</h4>
<div id="7348f3bb" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1">torch.einsum(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'ij-&gt;i'</span>, [a])</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="3">
<pre><code>tensor([ 3, 12])</code></pre>
</div>
</div>
</section>
<section id="sum" class="level4">
<h4 class="anchored" data-anchor-id="sum">sum</h4>
<div id="0ac88c29" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb7" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1">torch.einsum(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'ij-&gt;'</span>, [a])</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<pre><code>tensor(15)</code></pre>
</div>
</div>
</section>
<section id="transpose" class="level4">
<h4 class="anchored" data-anchor-id="transpose">transpose</h4>
<div id="4090c7f7" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb9" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1">torch.einsum(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'ij-&gt;ji'</span>, [a])</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="5">
<pre><code>tensor([[0, 3],
        [1, 4],
        [2, 5]])</code></pre>
</div>
</div>
</section>
<section id="batch-matrix-multiplication" class="level4">
<h4 class="anchored" data-anchor-id="batch-matrix-multiplication">batch matrix multiplication</h4>
<div id="c97bbcab" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb11" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1">a <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> torch.randn(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>)</span>
<span id="cb11-2">b <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> torch.randn(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>)</span>
<span id="cb11-3">torch.einsum(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'ijk,ikl-&gt;ijl'</span>, [a, b])</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="6">
<pre><code>tensor([[[ 0.3441,  5.6171,  1.0638],
         [ 0.9260, -2.2363, -1.8712]],

        [[ 1.4274, -2.0074,  0.7764],
         [ 0.0090,  0.2938, -0.7700]],

        [[ 3.5008,  0.8896,  4.1950],
         [ 0.7483,  0.8596,  0.3544]]])</code></pre>
</div>
</div>
</section>
</section>
<section id="为什么爱因斯坦求和如此重要" class="level3">
<h3 class="anchored" data-anchor-id="为什么爱因斯坦求和如此重要">为什么爱因斯坦求和如此重要？</h3>
<p>爱因斯坦求和的核心优势在于它可以极大地简化复杂的张量运算，特别是在涉及高维度张量时。这种简洁的符号不仅减少了书写和理解的困难，还可以避免出错，因为我们不再需要反复地书写求和符号。</p>
<p>在物理学中，尤其是在广义相对论和量子力学中，张量的运算无处不在，而爱因斯坦求和约定为这些运算提供了极大的便利。</p>


<!-- -->

</section>

 ]]></description>
  <category>linear algebra</category>
  <category>deep learning</category>
  <category>tensor</category>
  <guid>https://leslie-lu.github.io/blog/2024/09/09/einsum/</guid>
  <pubDate>Mon, 09 Sep 2024 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202409092357183.png" medium="image" type="image/png"/>
</item>
<item>
  <title>2023年中科院期刊分区表升级版</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/09/08/journal_category/</link>
  <description><![CDATA[ 





<p>前面我们爬了<a href="https://mp.weixin.qq.com/s/NdCZcUq2sdFhvk-s0B1COw">2023年最新JCR影响因子</a>，一直没有提供给大家2023年中科院期刊分区表。</p>
<p>今天我们爬了下中国科学院文献情报中心期刊分区表中的2023年升级版，大家公众号后台回复<code>2023年中科院分区</code>，即可拿到分区excel表格。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202409081452781.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">2023年中科院期刊分区表</figcaption>
</figure>
</div>
<p>ps：直接复制这几个字后台回复即可。</p>


<!-- -->


 ]]></description>
  <category>journal category</category>
  <guid>https://leslie-lu.github.io/blog/2024/09/08/journal_category/</guid>
  <pubDate>Sun, 08 Sep 2024 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202409081452781.png" medium="image" type="image/png"/>
</item>
<item>
  <title>星球JC | 心脏功能障碍诊断模型</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/09/06/jc/</link>
  <description><![CDATA[ 





<blockquote class="blockquote">
<p>大家好，这一期预测模型星球Journal Club的分享来自中国中医科学院西苑医院的小格格同学。</p>
</blockquote>
<p>今天分享的是2024年发表在中科院医学1区的顶刊JACC: CardioOncology上，题为 A Biomarker-Based Diagnostic Model for Cardiac Dysfunction in Childhood Cancer Survivors <span class="citation" data-cites="leerink2024biomarker">(Leerink et al. 2024)</span> 的研究论文。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202409062141816.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">figure abstract</figcaption>
</figure>
</div>
<section id="研究背景" class="level3">
<h3 class="anchored" data-anchor-id="研究背景">研究背景</h3>
<p>心血管疾病越来越多地在长期儿童癌症幸存者（CCS, childhood cancer survivors）中受到关注。在接受蒽环类药物、米托蒽醌和/或胸部定向放疗治疗的CCS患者中，约11%在癌症诊断后40年内发生心力衰竭。目前推荐终生超声心动图监测，通过早期发现左心室功能障碍（LV功能障碍）来预防或延缓心衰，监测间隔根据蒽环类药物、米托蒽醌和胸部定向放疗的累积剂量确定。</p>
<p>而心脏生物标志物在CCS长期监测中的作用仍不确定。生物标志物可能能够作为一种具有成本效益的鉴别检测，帮助确定是否继续或延迟应用超声心动图。如果血液生物标志物检测可以有效排除LV功能障碍，超声心动图可以推迟到下一个计划的监测时间点。尽管以往研究报告N末端B型利钠肽前体（NT-proBNP）和高敏心肌肌钙蛋白T（hs-cTnT）在长期CCS中检测LV功能障碍的诊断准确性有限，以致不建议使用心脏生物标志物进行CCS监测，但仍存在一些未解决的问题：</p>
<ol type="1">
<li><p>尽管先前的研究将心脏生物标志物作为检测LV功能障碍的独立诊断检测进行了研究，但若将其与临床信息结合可能会提高诊断性能。</p></li>
<li><p>CCS相关研究尚未探索用于rule out或rule in LV功能障碍的特定生物标志物的cutoff浓度，而这是提高诊断性能的潜在因素。</p></li>
<li><p>目前尚不清楚 CCS 中心脏生物标志物是否可能更有效地诊断更为严重的LV功能障碍，这一点在之前的一项针对普通人群的研究中得到了提示。</p></li>
</ol>
<p>基于横断面多中心研究，文章致力于开发和内部验证将心脏生物标志物与临床特征相结合的诊断模型，主要目的是确定其在先前未诊断出心肌病的 CCS 患者中rule in或rule out LV功能障碍的有效性。</p>
</section>
<section id="研究方法" class="level3">
<h3 class="anchored" data-anchor-id="研究方法">研究方法</h3>
<section id="研究类型" class="level4">
<h4 class="anchored" data-anchor-id="研究类型">研究类型</h4>
<p>多中心、横断面研究。</p>
</section>
<section id="研究人群" class="level4">
<h4 class="anchored" data-anchor-id="研究人群">研究人群</h4>
<p>CCS及其兄弟姐妹，其中，兄弟姐妹作为CSS的对照。</p>
</section>
<section id="数据收集" class="level4">
<h4 class="anchored" data-anchor-id="数据收集">数据收集</h4>
<p>通过问卷调查、血清学检测（NT-proBNP、hs-cTnT和肌酐水平、肾小球滤过率）、超声心动图检查收集数据。</p>
</section>
<section id="统计分析" class="level4">
<h4 class="anchored" data-anchor-id="统计分析">统计分析</h4>
<p>缺失值处理：探索了缺失值的可能模式，假设缺失值随机缺失（MAR），使用predictive mean matching进行重复20次的多重填补，继而基于每个填补的数据集进行独立分析，使用Rubin’s rules进行汇总，此外，文章做了一步填补结果与complete case analysis结果的比较。</p>
<p>生物标志物与LVEF的关系：通过local polynomial regression拟合CCS中生物标志物浓度与LVEF之间的关系。</p>
<p>预定义诊断标准：基于先前对呼吸困难患者心力衰竭诊断的研究，建立预定义的标准来rule out（阴性预测值NPV&gt;=98%，敏感度&gt;=90%）和rule in（阳性预测值PPV&gt;=75%，特异度&gt;=90%）LV功能障碍。</p>
<p>评价诊断准确性：包括AUC、敏感度、特异度、PPV和NPV；校准曲线进行评价；NRI（net reclassification improvement）。</p>
<p>预测模型的开发：基于logistic。第一个模型仅考虑临床预测因素，使用后向筛选关键变量，阈值设为0.05，由于使用了多重填补，最终选择出现在一半以上模型的变量进入最终模型；第二个模型加入NT-proBNP和hscTnT，使用pooled Wald test检验这两个变量给模型拟合带来的改善，此外，考虑到生物标志物与终点的非线性关系，文章进行了限制性立方样条分析。通过500次bootstrap进行内部验证。</p>
</section>
</section>
<section id="研究结果" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="研究结果">研究结果</h3>
<p>此研究共纳入1334例CCS，共有278名兄弟姐妹作为对照。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202409062142408.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">Table 1</figcaption>
</figure>
</div>
<p>与兄弟姐妹相比，CCS患者的心脏生物标志物：NT-proBNP水平的中位数和异常比例都高于他们的兄弟姐妹，hs-cTnT浓度无显著差异。</p>
<section id="仅使用生物标志物建模" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="仅使用生物标志物建模">仅使用生物标志物建模</h4>
<p>local polynomial regression发现随着LVEF的降低，CCS患者中的NT-proBNP和hs-cTnT浓度呈现升高的趋势，特别是当LVEF下降到低于50%时，这种趋势更为明显。但单独使用NT-proBNP异常或hs-cTnT不足以rule out或rule in任何类型的LV功能障碍。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202409062144175.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">Table 2</figcaption>
</figure>
</div>
</section>
<section id="结合临床特征与生物标志物" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="结合临床特征与生物标志物">结合临床特征与生物标志物</h4>
<p>将心脏生物标志物NT-proBNP和hs-cTnT结合到临床特征中，可以显著提高模型能力，特别是用于rule out LV功能障碍。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202409062146996.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">Table 3</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202409062148184.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">NRI</figcaption>
</figure>
</div>
<p>且校准度较好。</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202409062148642.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">Figure 2</figcaption>
</figure>
</div>
</section>
</section>
<section id="take-home-message" class="level3">
<h3 class="anchored" data-anchor-id="take-home-message">Take home message</h3>
<ol type="1">
<li><p>文章在关注常规模型评价指标的基础上，特别关注biomarker对模型rule out结局的影响，从rule in和rule out两方面来评价多个模型的不同用途。</p></li>
<li><p>文章通过建立多个生物标志物结合临床特征的诊断模型，展示了其最优cutoff值下可能的预测价值，同时对最新指南提到的高风险人群更新了分析。</p></li>
</ol>


<!-- -->


</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0">
<div id="ref-leerink2024biomarker" class="csl-entry">
Leerink, Jan M, Elizabeth AM Feijen, Esmee C de Baat, Remy Merkx, Helena JH van der Pal, Wim JE Tissing, Marloes Louwerens, et al. 2024. <span>“A Biomarker-Based Diagnostic Model for Cardiac Dysfunction in Childhood Cancer Survivors.”</span> <em>Cardio Oncology</em> 6 (2): 236–47.
</div>
</div></section></div> ]]></description>
  <category>journal club</category>
  <guid>https://leslie-lu.github.io/blog/2024/09/06/jc/</guid>
  <pubDate>Fri, 06 Sep 2024 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202409062131894.png" medium="image" type="image/png"/>
</item>
<item>
  <title>从随意推断（casual inference）到因果推断（causal inference）</title>
  <dc:creator>Zhen Lu</dc:creator>
  <link>https://leslie-lu.github.io/blog/2024/09/04/casual_inference/</link>
  <description><![CDATA[ <blockquote class="blockquote">
<p>因果分析的核心首先是因果问题，它决定了我们分析什么数据、如何分析这些数据以及我们的推断结论适用于什么人群。提出一个好的因果问题是比较难的，相对来讲，因果分析则要简单得多。本书属于方法应用性质，主要聚焦于因果推断的分析阶段。在本书前六章中，我们将讨论什么是因果问题，如何改进我们的问题，以及思考一些例子。</p>
</blockquote>
<p>因果问题是我们可以通过统计方法提出的一组更广泛问题中的一部分，这些问题依据数据科学的主要目的可以大致分为：描述、预测和因果推断 <span class="citation" data-cites="hernan2019">(Hernán, Hsu, and Healy 2019)</span>。然而，在实际中，受到所使用统计方法的影响（如，这三类问题都可使用回归来处理）以及我们讨论它们的方式影响，我们常常会将这三种问题混淆在一起。当我们实际想要进行的是基于非随机数据的因果推断时，我们经常使用“关联”（association）这样的委婉说法，而不是直接声明我们想要估计因果效应 <span class="citation" data-cites="Hernan2018">(Hernán 2018)</span>。</p>
<p>例如，最近一项关于流行病学研究中所使用语言的研究显示，估计效应的描述中最常见的词根是 “associate”，而许多研究人员也默认 “associate” 至少暗示了某种因果效应 (Figure&nbsp;1) <span class="citation" data-cites="haber_causal_language">(Haber et al. 2022)</span>。在分析的全部研究中，只有大约 1% 使用了 “cause” 这个词根。此外，三分之一的研究基于结论提出了相关的行动建议，而其中 80% 的建议都暗含了某种因果效应。而提出了行动建议的这些研究通常比那些只是描述效应的研究（如，使用 “associate” 和 “compare” 这样的词根）要有更强的因果效应暗示。另一方面，尽管一些研究暗示其目标是因果推断，但只有大约 4% 使用了本书将讨论的那些正式的因果推断模型，其它研究更多的做法是通过对先前相关研究或理论的引用讨论来证明他们建立的因果关系的合理性。</p>
<div class="cell page-columns page-full">
<div class="cell-output cell-output-stderr">
<pre><code>── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
✔ dplyr     1.1.4     ✔ readr     2.1.5
✔ forcats   1.0.0     ✔ stringr   1.5.1
✔ ggplot2   3.5.1     ✔ tibble    3.2.1
✔ lubridate 1.9.3     ✔ tidyr     1.3.1
✔ purrr     1.0.2     
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors</code></pre>
</div>
<div class="cell-output-display page-columns page-full">
<div id="fig-word-ranking" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="quarto-float quarto-float-fig figure page-columns page-full"><div aria-describedby="fig-word-ranking-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="https://leslie-lu.github.io/blog/2024/09/04/casual_inference/index_files/figure-html/fig-word-ranking-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-word-ranking-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: 研究人员使用的词根的因果强度排名。具有更多 “Strong” 排名的词根比那些具有更多 “None” 或 “Weak” 评分的词根具有更强的因果暗示。数据来自 Haber 等人。
</figcaption></figure>
</div>
</div>
</div>
<p>因为没有明确地提出带有具体因果假设和目标的因果问题，我们最终都得到了“薛定谔的因果推断”：</p>
<blockquote class="blockquote">
<p>我们的结果表明，“薛定谔的因果推断”是很常见的，即研究一方面避免声明（甚至明确否认）对估计因果效应的兴趣，但另一方面又充满了因果意图、推断、因果暗示和行动建议。</p>
<p>— <span class="citation" data-cites="haber_causal_language">Haber et al. (2022)</span></p>
</blockquote>
<p>这种方法是随意推断（casual inference）的一个例子：在没有做必要的工作来理解因果问题并处理因果假设的情况下进行推断。</p>


<!-- -->



<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0">
<div id="ref-haber_causal_language" class="csl-entry">
Haber, N. A., S. E. Wieten, J. M. Rohrer, O. A. Arah, P. W. G. Tennant, E. A. Stuart, E. J. Murray, et al. 2022. <span>“<span class="nocase"><span>C</span>ausal and <span>A</span>ssociational <span>L</span>anguage in <span>O</span>bservational <span>H</span>ealth <span>R</span>esearch: <span>A</span> <span>S</span>ystematic <span>E</span>valuation</span>.”</span> <em>Am J Epidemiol</em> 191 (12): 2084–97.
</div>
<div id="ref-Hernan2018" class="csl-entry">
Hernán, Miguel A. 2018. <span>“The C-Word: Scientific Euphemisms Do Not Improve Causal Inference From Observational Data.”</span> <em>American Journal of Public Health</em> 108 (5): 616–19. <a href="https://doi.org/10.2105/ajph.2018.304337">https://doi.org/10.2105/ajph.2018.304337</a>.
</div>
<div id="ref-hernan2019" class="csl-entry">
Hernán, Miguel A., John Hsu, and Brian Healy. 2019. <span>“A Second Chance to Get Causal Inference Right: A Classification of Data Science Tasks.”</span> <em>CHANCE</em> 32 (1): 42–49. <a href="https://doi.org/10.1080/09332480.2019.1579578">https://doi.org/10.1080/09332480.2019.1579578</a>.
</div>
</div></section><section class="quarto-appendix-contents" id="quarto-citation"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@online{lu2024,
  author = {Lu, Zhen},
  title = {从随意推断（casual {inference）到因果推断（causal}
    Inference）},
  date = {2024-09-04},
  url = {https://leslie-lu.github.io/blog/2024/09/04/casual_inference/},
  langid = {en}
}
</code></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-lu2024" class="csl-entry quarto-appendix-citeas">
Lu, Zhen. 2024. <span>“从随意推断（casual Inference）到因果推断（causal
Inference）.”</span> September 4, 2024. <a href="https://leslie-lu.github.io/blog/2024/09/04/casual_inference/">https://leslie-lu.github.io/blog/2024/09/04/casual_inference/</a>.
</div></div></section></div> ]]></description>
  <category>causal inference</category>
  <guid>https://leslie-lu.github.io/blog/2024/09/04/casual_inference/</guid>
  <pubDate>Wed, 04 Sep 2024 00:00:00 GMT</pubDate>
  <media:content url="https://cdn.jsdelivr.net/gh/Leslie-Lu/WeChatOfficialAccount/img/202409051340717.webp" medium="image" type="image/webp"/>
</item>
</channel>
</rss>
